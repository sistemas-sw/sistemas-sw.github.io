{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Datos de la asignatura \u00b6 Presentaci\u00f3n Bibliograf\u00eda Temario Temario \u00b6 Objetos Aspectos Contratos Funciones Eventos","title":"Inicio"},{"location":"#datos-de-la-asignatura","text":"Presentaci\u00f3n Bibliograf\u00eda Temario","title":"Datos de la asignatura"},{"location":"#temario","text":"Objetos Aspectos Contratos Funciones Eventos","title":"Temario"},{"location":"about/","text":"Apuntes de IISS Created with MkDocs. For full documentation visit mkdocs.org . Commands \u00b6 mkdocs new [dir-name] - Create a new project. mkdocs serve - Start the live-reloading docs server. mkdocs build - Build the documentation site. mkdocs help - Print this help message.","title":"About"},{"location":"about/#commands","text":"mkdocs new [dir-name] - Create a new project. mkdocs serve - Start the live-reloading docs server. mkdocs build - Build the documentation site. mkdocs help - Print this help message.","title":"Commands"},{"location":"bibliografia/","text":"Bibliograf\u00eda A. Hunt & D. Thomas. The Pragmatic Programmer. Addison-Wesley, 1999. D. Thomas & A. Hunt. The Pragmatic Programmer: your journey to mastery , 20 th Anniversary Edition, 2 nd Edition, Addison-Wesley Professional, 2020. M. Fowler. Refactoring. Improving the Design of Existing Code. Addison-Wesley, 2 nd Edition, 2008. E. Yourdon & L. Constantine. Structured Design: Fundamentals of a Discipline of Computer Program and Systems Design. Prentice Hall, 2 nd edition, 1986. B. Eckel. Thinking in Java | C++. Prentice-Hall, 4 th | 2 nd edition, 2006 | 2003. E. Gamma, R. Helm, R. Johnson & J. Vlissides. Design Patterns. Elements of Reusable Object-Oriented Software. Addison-Wesley, 1995. B. McLaughlin, G. Pollice & D. West. Head First Object-Oriented Analysis and Design. O'Reilly, 2006. B. Meyer. Object-Oriented Software Construction. Prentice-Hall, 2 nd edition, 1997. C. Walls & R. Breidenbach. Spring in Action. Manning Publications, 2005. T. DeMarco. Structured Analysis and System Specification . Yourdon Press, 1979. Robert C. Martin & Micah Martin. Agile Principles, Patterns and Practices in C# , Prentice Hall, 2006. Robert C. Martin. Clean Architecture: A Craftsman's Guide to Software Structure and Design , Prentice Hall, 2018. Nathan Rozentals. Mastering TypeScript , Packt Publishing, 2 nd edition, 2017 Steve McConnel. Code Complete: A practical handbook of software construction , 2 nd edition, 2004. F. Buschmann, R. Meunier, H. Rohnert, P. Sommerlad, M. Stal. Pattern-Oriented Software Architecture Volume 1: A System of Patterns , Wiley, 1996. R. Taylor, N. Medvidovic, E. M. Dashofy: Software Architecture. Foundations, Theory and Practice , Wiley, 2010.","title":"Bibliograf\u00eda"},{"location":"iiss-aop/","text":"ASPECTOS Caso 5 - Editor de figuras \u00b6 Ortogonalidad con aspectos \u00b6 Ejemplo: editor de figuras \u00b6 class Line implements FigureElement { private Point p1 , p2 ; Point getP1 () { return p1 ; } Point getP2 () { return p2 ; } void setP1 ( Point p1 ) { this . p1 = p1 ; } void setP2 ( Point p2 ) { this . p2 = p2 ; } } class Point implements FigureElement { private int x = 0 , y = 0 ; int getX () { return x ; } int getY () { return y ; } void setX ( int x ) { this . x = x ; } void setY ( int y ) { this . y = y ; } } Hay que actualizar la pantalla tras mover los objetos Hay una colecci\u00f3n de figuras que cambian peri\u00f3dicamente. Se deben monitorizar los cambios para refrescar el display. class Line { private Point p1 , p2 ; Point getP1 () { return p1 ; } Point getP2 () { return p2 ; } void setP1 ( Point p1 ) { this . p1 = p1 ; } void setP2 ( Point p2 ) { this . p2 = p2 ; } } class Point { private int x = 0 , y = 0 ; int getX () { return x ; } int getY () { return y ; } void setX ( int x ) { this . x = x ; } void setY ( int y ) { this . y = y ; } } Implementamos MoveTracking . \u00bfQu\u00e9 dependencias aparecen? Line \\dashrightarrow \\dashrightarrow MoveTracking Point \\dashrightarrow \\dashrightarrow MoveTracking Implementaci\u00f3n sin aspectos \u00b6 Versi\u00f3n 1 sin aspectos \u00b6 Solo detecta el cambio de los extremos de una l\u00ednea. Line \\dashrightarrow \\dashrightarrow MoveTracking class Line { private Point p1 , p2 ; Point getP1 () { return _p1 ; } Point getP2 () { return _p2 ; } void setP1 ( Point p1 ) { this . p1 = p1 ; MoveTracking . setFlag (); // a\u00f1adido } void setP2 ( Point p2 ) { this . p2 = p2 ; MoveTracking . setFlag (); // a\u00f1adido } } class Point { private int x = 0 , y = 0 ; int getX () { return x ; } int getY () { return y ; } void setX ( int x ) { this . x = x ; } void setY ( int y ) { this . y = y ; } } class MoveTracking { private static boolean flag = false ; public static void setFlag () { flag = true ; } public static boolean testAndClear () { boolean result = flag ; flag = false ; return result ; } } Versi\u00f3n 2 sin aspectos \u00b6 Tambi\u00e9n detecta el cambio de coordenadas de un punto. Line \\dashrightarrow \\dashrightarrow MoveTracking Point \\dashrightarrow \\dashrightarrow MoveTracking class Line { private Point p1 , p2 ; Point getP1 () { return p1 ; } Point getP2 () { return p2 ; } void setP1 ( Point p1 ) { this . p1 = p1 ; MoveTracking . setFlag (); } void setP2 ( Point p2 ) { this . p2 = p2 ; MoveTracking . setFlag (); } } class Point { private int x = 0 , y = 0 ; int getX () { return x ; } int getY () { return y ; } void setX ( int x ) { this . x = x ; MoveTracking . setFlag (); //a\u00f1adido } void setY ( int y ) { this . y = y ; MoveTracking . setFlag (); //a\u00f1adido } } class MoveTracking { private static boolean flag = false ; public static void setFlag () { flag = true ; } public static boolean testAndClear () { boolean result = flag ; flag = false ; return result ; } } Versi\u00f3n 3 sin aspectos \u00b6 Las colecciones de figuras son complejas. Las estructuras de objetos son jer\u00e1rquicas y se producen eventos as\u00edncronos: La versi\u00f3n 2 hace que un cambio en cualquier elemento provoque un refresco de todas las figuras. Mejor monitorizar las figuras que cambian... Decidimos modificar la implementaci\u00f3n: cambiar el m\u00e9todo setFlag por collectOne , indicando la figura que se mueve. class Line { private Point p1 , p2 ; Point getP1 () { return p1 ; } Point getP2 () { return p2 ; } void setP1 ( Point p1 ) { this . p1 = p1 ; MoveTracking . collectOne ( this ); // modificado } void setP2 ( Point p2 ) { this . p2 = p2 ; MoveTracking . collectOne ( this ); // modificado } } class Point { private int x = 0 , y = 0 ; int getX () { return x ; } int getY () { return y ; } void setX ( int x ) { this . x = x ; MoveTracking . collectOne ( this ); // modificado } void setY ( int y ) { this . y = y ; MoveTracking . collectOne ( this ); // modificado } } class MoveTracking { private static Set movees = new HashSet (); public static void collectOne ( Object o ) { movees . add ( o ); } public static Set getmovees () { Set result = movees ; movees = new HashSet (); return result ; } } La no ortogonalidad de MoveTracking con respecto a Line y Point hace que la solicitud de un cambio de implementaci\u00f3n (el seguimiento de los cambios en las figuras para el refresco en pantalla) provoque un camnbio en los otros m\u00f3dulos (clases). El cambio de implementaci\u00f3n del seguimiento de los cambios para el refresco en pantalla ha dado lugar a modificaciones en todas las clases: Line , Point y MoveTracking Programaci\u00f3n orientada a aspectos \u00b6 La programaci\u00f3n orientada a aspectos ( AOP ) es un paradigma de programaci\u00f3n cuyo objetivo es incrementar la modularidad (ortogonalidad) de las implementaciones mediante la separaci\u00f3n de aspectos transversales ( cross-cutting concerns ). aspect = modularizaci\u00f3n de un aspecto de inter\u00e9s ( concern ) que afecta a varias clases o m\u00f3dulos joinpoint = especificaci\u00f3n declarativa de un punto en la ejecuci\u00f3n de un programa (por ejemplo, la ejecuci\u00f3n de un m\u00e9todo, el manejo de una excepci\u00f3n, etc.) advice = acci\u00f3n a tomar por la especificaci\u00f3n de un aspecto dado en un determinado joinpoint . Interceptan la ejecuci\u00f3n de un joinpoint . Hay una cadena de interceptores alrededor de cada joinpoint . Tipos de advice : after , before , around , etc. pointcut = predicado que define cu\u00e1ndo se aplica un advice de un aspecto en un jointpoint determinado. Se asocia un advice con la expresi\u00f3n de un pointcut y se ejecuta el advice en todos los joinpoint que cumplan la expresi\u00f3n del pointcut . Implementaci\u00f3n con aspectos \u00b6 En el ejemplo anterior, las clases Line y Point no se ven afectadas: class Line { private Point p1 , p2 ; Point getP1 () { return p1 ; } Point getP2 () { return p2 ; } void setP1 ( Point p1 ) { this . p1 = p1 ; } void setP2 ( Point p2 ) { this . p2 = p2 ; } } class Point { private int x = 0 , y = 0 ; int getX () { return x ; } int getY () { return y ; } void setX ( int x ) { this . x = x ; } void setY ( int y ) { this . y = y ; } } Versi\u00f3n 1 con aspectos \u00b6 Line \\not\\dashrightarrow \\not\\dashrightarrow MoveTracking aspect MoveTracking { private boolean flag = false ; public boolean testAndClear () { boolean result = flag ; flag = false ; return result ; } pointcut move (): call ( void Line . setP1 ( Point )) || call ( void Line . setP2 ( Point )); after (): move () { flag = true ; } } Versi\u00f3n 2 con aspectos \u00b6 Line \\not\\dashrightarrow \\not\\dashrightarrow MoveTracking Point \\not\\dashrightarrow \\not\\dashrightarrow MoveTracking aspect MoveTracking { private boolean flag = false ; public boolean testAndClear () { boolean result = flag ; flag = false ; return result ; } pointcut move (): call ( void Line . setP1 ( Point )) || call ( void Line . setP2 ( Point )) || call ( void Point . setX ( int )) || call ( void Point . setY ( int )); after (): move () { flag = true ; } } Ejemplos de pointcut: call ( void Figure . set * (..)) call ( public * Figure . * (..)) Versi\u00f3n 3 con aspectos \u00b6 Line \\perp \\perp MoveTracking Point \\perp \\perp MoveTracking Versi\u00f3n m\u00e1s ortogonal. Todos los cambios est\u00e1n concentrados en un solo aspecto. aspect MoveTracking { private Set movees = new HashSet (); public Set getmovees () { Set result = movees ; movees = new HashSet (); return result ; } pointcut move ( FigureElement figElt ): target ( figElt ) && ( call ( void Line . setP1 ( Point )) || call ( void Line . setP2 ( Point )) || call ( void Point . setX ( int )) || call ( void Point . setY ( int ))); after ( FigureElement fe ): move ( fe ) { movees . add ( fe ); } } Lecturas recomendadas de AspectJ \u00b6 Lenguaje de AspectJ Introducci\u00f3n a AspectJ Ejercicios: AspectJ y Spring AOP \u00b6 Introducci\u00f3n a AspectJ Introducci\u00f3n a Spring AOP","title":"II. Aspectos"},{"location":"iiss-aop/#caso-5-editor-de-figuras","text":"","title":"Caso 5 - Editor de figuras"},{"location":"iiss-aop/#ortogonalidad-con-aspectos","text":"","title":"Ortogonalidad con aspectos"},{"location":"iiss-aop/#ejemplo-editor-de-figuras","text":"class Line implements FigureElement { private Point p1 , p2 ; Point getP1 () { return p1 ; } Point getP2 () { return p2 ; } void setP1 ( Point p1 ) { this . p1 = p1 ; } void setP2 ( Point p2 ) { this . p2 = p2 ; } } class Point implements FigureElement { private int x = 0 , y = 0 ; int getX () { return x ; } int getY () { return y ; } void setX ( int x ) { this . x = x ; } void setY ( int y ) { this . y = y ; } } Hay que actualizar la pantalla tras mover los objetos Hay una colecci\u00f3n de figuras que cambian peri\u00f3dicamente. Se deben monitorizar los cambios para refrescar el display. class Line { private Point p1 , p2 ; Point getP1 () { return p1 ; } Point getP2 () { return p2 ; } void setP1 ( Point p1 ) { this . p1 = p1 ; } void setP2 ( Point p2 ) { this . p2 = p2 ; } } class Point { private int x = 0 , y = 0 ; int getX () { return x ; } int getY () { return y ; } void setX ( int x ) { this . x = x ; } void setY ( int y ) { this . y = y ; } } Implementamos MoveTracking . \u00bfQu\u00e9 dependencias aparecen? Line \\dashrightarrow \\dashrightarrow MoveTracking Point \\dashrightarrow \\dashrightarrow MoveTracking","title":"Ejemplo: editor de figuras"},{"location":"iiss-aop/#implementacion-sin-aspectos","text":"","title":"Implementaci\u00f3n sin aspectos"},{"location":"iiss-aop/#version-1-sin-aspectos","text":"Solo detecta el cambio de los extremos de una l\u00ednea. Line \\dashrightarrow \\dashrightarrow MoveTracking class Line { private Point p1 , p2 ; Point getP1 () { return _p1 ; } Point getP2 () { return _p2 ; } void setP1 ( Point p1 ) { this . p1 = p1 ; MoveTracking . setFlag (); // a\u00f1adido } void setP2 ( Point p2 ) { this . p2 = p2 ; MoveTracking . setFlag (); // a\u00f1adido } } class Point { private int x = 0 , y = 0 ; int getX () { return x ; } int getY () { return y ; } void setX ( int x ) { this . x = x ; } void setY ( int y ) { this . y = y ; } } class MoveTracking { private static boolean flag = false ; public static void setFlag () { flag = true ; } public static boolean testAndClear () { boolean result = flag ; flag = false ; return result ; } }","title":"Versi\u00f3n 1 sin aspectos"},{"location":"iiss-aop/#version-2-sin-aspectos","text":"Tambi\u00e9n detecta el cambio de coordenadas de un punto. Line \\dashrightarrow \\dashrightarrow MoveTracking Point \\dashrightarrow \\dashrightarrow MoveTracking class Line { private Point p1 , p2 ; Point getP1 () { return p1 ; } Point getP2 () { return p2 ; } void setP1 ( Point p1 ) { this . p1 = p1 ; MoveTracking . setFlag (); } void setP2 ( Point p2 ) { this . p2 = p2 ; MoveTracking . setFlag (); } } class Point { private int x = 0 , y = 0 ; int getX () { return x ; } int getY () { return y ; } void setX ( int x ) { this . x = x ; MoveTracking . setFlag (); //a\u00f1adido } void setY ( int y ) { this . y = y ; MoveTracking . setFlag (); //a\u00f1adido } } class MoveTracking { private static boolean flag = false ; public static void setFlag () { flag = true ; } public static boolean testAndClear () { boolean result = flag ; flag = false ; return result ; } }","title":"Versi\u00f3n 2 sin aspectos"},{"location":"iiss-aop/#version-3-sin-aspectos","text":"Las colecciones de figuras son complejas. Las estructuras de objetos son jer\u00e1rquicas y se producen eventos as\u00edncronos: La versi\u00f3n 2 hace que un cambio en cualquier elemento provoque un refresco de todas las figuras. Mejor monitorizar las figuras que cambian... Decidimos modificar la implementaci\u00f3n: cambiar el m\u00e9todo setFlag por collectOne , indicando la figura que se mueve. class Line { private Point p1 , p2 ; Point getP1 () { return p1 ; } Point getP2 () { return p2 ; } void setP1 ( Point p1 ) { this . p1 = p1 ; MoveTracking . collectOne ( this ); // modificado } void setP2 ( Point p2 ) { this . p2 = p2 ; MoveTracking . collectOne ( this ); // modificado } } class Point { private int x = 0 , y = 0 ; int getX () { return x ; } int getY () { return y ; } void setX ( int x ) { this . x = x ; MoveTracking . collectOne ( this ); // modificado } void setY ( int y ) { this . y = y ; MoveTracking . collectOne ( this ); // modificado } } class MoveTracking { private static Set movees = new HashSet (); public static void collectOne ( Object o ) { movees . add ( o ); } public static Set getmovees () { Set result = movees ; movees = new HashSet (); return result ; } } La no ortogonalidad de MoveTracking con respecto a Line y Point hace que la solicitud de un cambio de implementaci\u00f3n (el seguimiento de los cambios en las figuras para el refresco en pantalla) provoque un camnbio en los otros m\u00f3dulos (clases). El cambio de implementaci\u00f3n del seguimiento de los cambios para el refresco en pantalla ha dado lugar a modificaciones en todas las clases: Line , Point y MoveTracking","title":"Versi\u00f3n 3 sin aspectos"},{"location":"iiss-aop/#programacion-orientada-a-aspectos","text":"La programaci\u00f3n orientada a aspectos ( AOP ) es un paradigma de programaci\u00f3n cuyo objetivo es incrementar la modularidad (ortogonalidad) de las implementaciones mediante la separaci\u00f3n de aspectos transversales ( cross-cutting concerns ). aspect = modularizaci\u00f3n de un aspecto de inter\u00e9s ( concern ) que afecta a varias clases o m\u00f3dulos joinpoint = especificaci\u00f3n declarativa de un punto en la ejecuci\u00f3n de un programa (por ejemplo, la ejecuci\u00f3n de un m\u00e9todo, el manejo de una excepci\u00f3n, etc.) advice = acci\u00f3n a tomar por la especificaci\u00f3n de un aspecto dado en un determinado joinpoint . Interceptan la ejecuci\u00f3n de un joinpoint . Hay una cadena de interceptores alrededor de cada joinpoint . Tipos de advice : after , before , around , etc. pointcut = predicado que define cu\u00e1ndo se aplica un advice de un aspecto en un jointpoint determinado. Se asocia un advice con la expresi\u00f3n de un pointcut y se ejecuta el advice en todos los joinpoint que cumplan la expresi\u00f3n del pointcut .","title":"Programaci\u00f3n orientada a aspectos"},{"location":"iiss-aop/#implementacion-con-aspectos","text":"En el ejemplo anterior, las clases Line y Point no se ven afectadas: class Line { private Point p1 , p2 ; Point getP1 () { return p1 ; } Point getP2 () { return p2 ; } void setP1 ( Point p1 ) { this . p1 = p1 ; } void setP2 ( Point p2 ) { this . p2 = p2 ; } } class Point { private int x = 0 , y = 0 ; int getX () { return x ; } int getY () { return y ; } void setX ( int x ) { this . x = x ; } void setY ( int y ) { this . y = y ; } }","title":"Implementaci\u00f3n con aspectos"},{"location":"iiss-aop/#version-1-con-aspectos","text":"Line \\not\\dashrightarrow \\not\\dashrightarrow MoveTracking aspect MoveTracking { private boolean flag = false ; public boolean testAndClear () { boolean result = flag ; flag = false ; return result ; } pointcut move (): call ( void Line . setP1 ( Point )) || call ( void Line . setP2 ( Point )); after (): move () { flag = true ; } }","title":"Versi\u00f3n 1 con aspectos"},{"location":"iiss-aop/#version-2-con-aspectos","text":"Line \\not\\dashrightarrow \\not\\dashrightarrow MoveTracking Point \\not\\dashrightarrow \\not\\dashrightarrow MoveTracking aspect MoveTracking { private boolean flag = false ; public boolean testAndClear () { boolean result = flag ; flag = false ; return result ; } pointcut move (): call ( void Line . setP1 ( Point )) || call ( void Line . setP2 ( Point )) || call ( void Point . setX ( int )) || call ( void Point . setY ( int )); after (): move () { flag = true ; } } Ejemplos de pointcut: call ( void Figure . set * (..)) call ( public * Figure . * (..))","title":"Versi\u00f3n 2 con aspectos"},{"location":"iiss-aop/#version-3-con-aspectos","text":"Line \\perp \\perp MoveTracking Point \\perp \\perp MoveTracking Versi\u00f3n m\u00e1s ortogonal. Todos los cambios est\u00e1n concentrados en un solo aspecto. aspect MoveTracking { private Set movees = new HashSet (); public Set getmovees () { Set result = movees ; movees = new HashSet (); return result ; } pointcut move ( FigureElement figElt ): target ( figElt ) && ( call ( void Line . setP1 ( Point )) || call ( void Line . setP2 ( Point )) || call ( void Point . setX ( int )) || call ( void Point . setY ( int ))); after ( FigureElement fe ): move ( fe ) { movees . add ( fe ); } }","title":"Versi\u00f3n 3 con aspectos"},{"location":"iiss-aop/#lecturas-recomendadas-de-aspectj","text":"Lenguaje de AspectJ Introducci\u00f3n a AspectJ","title":"Lecturas recomendadas de AspectJ"},{"location":"iiss-aop/#ejercicios-aspectj-y-spring-aop","text":"Introducci\u00f3n a AspectJ Introducci\u00f3n a Spring AOP","title":"Ejercicios: AspectJ y Spring AOP"},{"location":"iiss-dbc/","text":"ASERCIONES Y CONTRATOS Aserciones y contratos \u00b6 Aserciones \u00b6 Oscar Wilde, The Picture of Dorian Gray There is a luxury in self-reproach. When we blame ourselves we feel no one else has a right to blame us. Programaci\u00f3n asertiva \u00b6 Ejemplos de situaciones que no van a ocurrir nunca : Con dos d\u00edgitos para el a\u00f1o basta Esta aplicaci\u00f3n nunca va a usarse en el extranjero Este contador nunca va a ser negativo A\u00f1adir aserciones al c\u00f3digo para chequear esas situaciones: void writeString ( String s ) { assert ( s != null ); ... } ... for ( int i = 0 ; i < num_entries - 1 ; i ++ ) { assert ( sorted [ i ] <= sorted [ i + 1 ] ); } Aserciones e invariantes \u00b6 Las aserciones sirven para expresar invariantes . Invariante Condici\u00f3n que se puede considerar cierta durante la ejecuci\u00f3n de un programa o de parte del mismo. Es un predicado l\u00f3gico que se debe mantener siempre cierto durante una cierta fase de la ejecuci\u00f3n. Por ejemplo, una invariante de bucle es una condici\u00f3n que es cierta al principio y al final de cada ejecuci\u00f3n de un bucle Aserciones en Java \u00b6 Forma 1: assert Expression1 ; Forma 2: assert Expression1 : Expression2 ; Expression1 es boolean Expression2 devuelve un valor que es pasado al constructor de AssertionError , que usa una representaci\u00f3n en forma de String del valor como detalle del mensaje En versiones antiguas del JDK, notificar al compilador que las acepte: javac -source 1 .4 *.java Las aserciones en Java imponen un alto coste en rendimiento y puede ser conveniente desabilitarlas en tiempo de ejecuci\u00f3n: java [ -enableassertions | -ea ] [ :<package name> \"...\" | :<class name> ] java [ -disableassertions | -da ] [ :<package name> \"...\" | :<class name> ] \u00bfGesti\u00f3n de errores? \u00b6 Las aserciones no son para gesti\u00f3n de errores: try { BufferedReader in = new BufferedReader ( new InputStreamReader ( System . in )); String input ; System . out . print ( \"Please Type Something here: \" ); input = in . readLine (); assert (( input . equalsIgnoreCase ( \"Y\" ) || ( input . equalsIgnoreCase ( \"N\" )); /* bad idea! */ ... } catch ( Exception ex ) { System . out . print ( \"We've had an Exception: \" + ex . getMessage ()); } Efectos colaterales \u00b6 Cuidado con los efectos colaterales de las expresiones de una aserci\u00f3n: while ( Iterator i . hasNext () { assert ( i . next () != null ); /* side effect */ Object obj = i . next (); // ... } while ( Iterator i . hasNext () { Object obj = i . next (); assert ( obj != null ); // ... } Tipos de invariantes \u00b6 Invariantes internas \u00b6 Sustituir los comentarios que indicaban invariantes: if ( i % 3 == 0 ) { ... } else if ( i % 3 == 1 ) { ... } else { // We know (i % 3 == 2) ... } Mejor con aserciones: if ( i % 3 == 0 ) { ... } else if ( i % 3 == 1 ) { ... } else { assert i % 3 == 2 : i ; ... } Invariantes de control de flujo \u00b6 Para selectivas : switch ( suit ) { case Suit . CLUBS : ... break ; case Suit . DIAMONDS : ... break ; case Suit . HEARTS : ... break ; case Suit . SPADES : ... } A\u00f1adir: default : assert false : suit ; o tambi\u00e9n (protecci\u00f3n aunque se deshabiliten las aserciones, pero sin coste extra): default : throw new AssertionError ( suit ); Puntos inalcanzables : void foo () { for (...) { if (...) return ; } assert false ; // Execution should never reach this point!!! } Invariantes de clase \u00b6 Son un tipo de invariantes internas que se aplican a todas las instancias de una clase, en todos los momentos, excepto cuando una instancia est\u00e1 en transici\u00f3n de un estado consistente a otro. Por ejemplo, en un \u00e1rbol binario equilibrado, una invariante de clase puede indicar que est\u00e1 ordenado y equilibrado: A\u00f1adir c\u00f3digo en Java: // Returns true if this tree is properly balanced private boolean isBalanced () { ... } Todo constructor y m\u00e9todo p\u00fablico debe llamar a assert isBalanced (); antes del return . Es recomendable incluir comprobaciones de invariantes de clase al principio de los m\u00e9todos de clases cuyo estado es modificable por otras clases (v.g. setters ). Idiom para definir aserciones finales \u00b6 A veces hace falta guardar datos antes de hacer un c\u00f3mputo, para poder luego comprobar una condici\u00f3n cuando el c\u00f3mputo se haya completado. Ejemplo de c\u00f3mo hacerlo con una inner class que guarda el estado de variables: void foo ( int [] array ) { // Manipulate array ... // At this point, array will contain exactly the ints that it did // prior to manipulation, in the same order. } void foo ( final int [] array ) { class DataCopy { private int [] arrayCopy ; DataCopy () { arrayCopy = ( int [] )( array . clone ()); } boolean isConsistent () { return Arrays . equals ( array , arrayCopy ); } } DataCopy copy = null ; // Always succeeds; has side effect of saving a copy of array assert ( copy = new DataCopy ()) != null ; ... // Manipulate array assert copy . isConsistent (); } Programaci\u00f3n por contratos \u00b6 Contrato \u00b6 Un contrato entre dos partes define derechos y responsabilidades por ambas partes Define las repercusiones por incumplimiento del contrato Design By Contract (DBC) \u00b6 Desarrollado para lenguaje Eiffel por Bertrand Meyer Documentar y aceptar los derechos y responsabilidades de cada m\u00f3dulo de software para asegurar la correci\u00f3n de un programa Un programa correcto es aqu\u00e9l que hace nada m\u00e1s y nada menos que lo que dice hacer Precondiciones, postcondiciones e invariantes \u00b6 Precondici\u00f3n \u00b6 Qu\u00e9 debe ser cierto antes de llamar a una rutina/m\u00e9todo (sus requisitos) Una rutina jam\u00e1s debe ser llamada si se violan sus precondiciones Es responsabilidad del que la llama hacer que se cumplan Postcondici\u00f3n \u00b6 Qu\u00e9 garantiza la rutina: estado del mundo cuando la rutina/m\u00e9todo termina Implica que la rutina debe finalizar: no puede haber bucles infinitos Invariante de clase \u00b6 Condici\u00f3n que se cumple para todas las instancias de la clase, desde la perspectiva del llamador Durante el procesamiento interno, la invariante puede no cumplirse, pero s\u00ed cuando la rutina termina y se devuelve el control al llamador Una clase no puede dar permiso de escritura sin restricciones sobre las propiedades ( data members ) que participan en la definici\u00f3n de la invariante Ejemplo: Ra\u00edz cuadrada en Eiffel \u00b6 sqrt : DOUBLE is -- Square root routine require sqrt_arg_must_be_positive : Current >= 0 ; --- ... --- calculate square root here --- ... ensure (( Result * Result ) - Current ). abs <= epsilon * Current . abs ; -- Result should be within error tolerance end ; Si el usuario introduce un n\u00famero negativo en la consola, es responsabilidad del c\u00f3digo que llama a sqrt que dicho valor no se pase nunca a sqrt . Opciones: Terminar Emitir una advertencia y leer otro n\u00famero Pasar el n\u00famero a complejo (ponerlo en positivo y a\u00f1adir una i ) Si se llega a pasar un n\u00famero negativo, Eiffel imprime el error sqrt_arg_must_be_positive en tiempo de ejecuci\u00f3n y una traza de la pila (En otros lenguajes, como Java, se devolver\u00eda un Nan ). Ejemplo: Cuenta Bancaria \u00b6 Cuenta Bancaria sin contratos \u00b6 class ACCOUNT feature balance : INTEGER owner : PERSON minimum_balance : INTEGER is 1000 open ( who : PERSON ) is -- Assign the account to owner who. do owner := who end deposit ( sum : INTEGER ) is -- Deposit sum into the account. do add ( sum ) end withdraw ( sum : INTEGER ) is -- Withdraw sum from the account. do add ( - sum ) end may_withdraw ( sum : INTEGER ): BOOLEAN is -- Is there enough money to withdraw sum? do Result := ( balance >= sum + minimum_balance ) end feature { NONE } add ( sum : INTEGER ) is -- Add sum to the balance. do balance := balance + sum end end -- class ACCOUNT feature son las operaciones de la clase feature { NONE } son privados make para definir el constructor Cuenta Bancaria con contratos \u00b6 class ACCOUNT create make feature -- ... Attributes as before: balance , minimum_balance , owner , open ... deposit ( sum : INTEGER ) is -- Deposit sum into the account. require sum >= 0 do add ( sum ) ensure balance = old balance + sum end withdraw ( sum : INTEGER ) is -- Withdraw sum from the account. require sum >= 0 sum <= balance - minimum_balance do add ( - sum ) ensure balance = old balance - sum end may_withdraw ... -- As before feature { NONE } add ... -- As before make ( initial : INTEGER ) is -- Initialize account with initial balance. require initial >= minimum_balance do balance := initial end invariant balance >= minimum_balance end -- class ACCOUNT Contratos en los lenguajes \u00b6 Contratos en Java iContract , inactiva, recuperada en Java Contract Suite o JContractS Contracts for Java o Cofoja Etc. Actividad: Contratos en Scala Scala permite especificar aserciones ( assert ), precondiciones ( require ), postcondiciones ( ensuring ) e invariantes ( assume ). Ejemplo: def divide ( x : Int , y : Int ) : Int = { require ( x > y , s\" $x > $y \" ) require ( y > 0 , s\" $y > 0\" ) x / y } ensuring ( _ * y == x ) Seguir el tutorial Design by Contract Actividad: \u00bfHay contratos en C++? A\u00fan no hay contratos en C++17 ni en C++20. Ver el video de J. D. Garc\u00eda sobre Contracts programming after C++17 : Desde el minuto 4'10'' Ejemplo: Java + iContract \u00b6 Java no permite especificar contratos (los assert no son lo mismo). As\u00ed que hay que utilizar extensiones como iContract Ejemplo : Inserci\u00f3n en una lista ordenada /** * @invariant forall Node n in elements() | * n.prev() != null * implies * n.value().compareTo(n.prev().value()) > 0 */ public class OrderedList { /** * @pre contains(aNode) == false * @post contains(aNode) == true */ public void insertNode ( final Node aNode ) { // ... } // ... } Una postcondici\u00f3n puede necesitar expresarse con par\u00e1metros pasados a un m\u00e9todo para verificar un comportamiento correcto. Si el m\u00e9todo puede cambiar el valor del par\u00e1metro pasado (par\u00e1metro mutable), el contrato puede incumplirse. Par\u00e1metros inmutables \u00b6 Eiffel no permite que se pueda cambiar el valor de un par\u00e1metro (es inmutable) En C++ usar const Opciones en Java: Usar final para marcar un par\u00e1metro constante. Sin embargo, las subclases podr\u00edan redefinir los par\u00e1metros y volver a hacerlos mutables. Adem\u00e1s final se aplica a la referencia, no al objeto en s\u00ed. Usar variable@pre de iContract Muchos lenguajes funcionales (Lisp, Haskell, Erlang, Clojure, etc.) definen inmutabilidad por defecto \u00bfPor qu\u00e9 la inmutabilidad? \u00b6 Por rendimiento (v.g. String en Java): si es inmutable, para copiar un objeto basta con copiar la referencia ( interning ) Por thread-safety para c\u00f3digo concurrente C\u00f3digo perezoso \u00b6 Se recomienda escribir c\u00f3digo \"perezoso\" para los contratos: ser estricto en lo que se acepta al empezar y prometer lo menos posible al terminar. Si un contrato indica que se acepta cualquier cosa y promete la luna a cambio, habr\u00e1 que escribir un mont\u00f3n de c\u00f3digo! Dead programs tell no lies \u00b6 El dise\u00f1o y la programaci\u00f3n basada en contratos son una forma de incrementar la calidad del c\u00f3digo mediante early crash . Hay otras t\u00e9cnicas (que veremos m\u00e1s adelante), pero en general el principio b\u00e1sico es: cuando el c\u00f3digo descubre que sucede algo que supuestamente es imposible o \"no deber\u00eda suceder\", el programa ya no es viable: eutanasia. En Java se lanza una RuntimeException cuando sucede algo extra\u00f1o en tiempo de ejecuci\u00f3n. Se puede/debe hacer lo mismo con cualquier lenguaje Aserciones versus contratos en Java \u00b6 No hay soporte para propagar aserciones por una jerarqu\u00eda de herencia: si se redefine un m\u00e9todo con contrato, las aserciones que implementan el contrato no ser\u00e1n llamadas correctamente (excepto si se duplican en el c\u00f3digo) No hay soporte para valores antiguos : si se implementara un contrato mediante aserciones, habr\u00eda que a\u00f1adir c\u00f3digo a la precondici\u00f3n para guardar la informaci\u00f3n que quiera usarse en la postcondici\u00f3n. (v.g. variable@pre en iContract versus old expression en Eiffel) El sistema de runtime y las bibliotecas no est\u00e1n dise\u00f1adas para dar soporte a contratos, as\u00ed que estos no se chequean . Y es precisamente en la frontera entre el cliente y la biblioteca donde hay m\u00e1s problemas. Redefinici\u00f3n de contratos \u00b6 Redefinici\u00f3n de contratos A routine redeclaration [in a derivative] may only replace the original precondition by one equal or weaker, and the original post-condition by one equal or stronger Bertrand Meyer Los m\u00e9todos de clase declaran precondiciones y postcondiciones al redefinir una operaci\u00f3n en una subclase derivada. Las precondiciones s\u00f3lo pueden sustituirse por otras m\u00e1s d\u00e9biles/laxas. Los m\u00e9todos pueden redefinirse con implementaciones que aceptan un rango m\u00e1s amplio de entradas. Las postcondiciones s\u00f3lo pueden sustituirse por otras m\u00e1s fuertes/estrictas. Los m\u00e9todos pueden redefinirse con implementaciones que generan un rango m\u00e1s estrecho de salidas. Las invariantes s\u00f3lo pueden sustituirse por otras m\u00e1s fuertes/estrictas. Las clases e interfaces pueden derivarse para restringir el conjunto de estados v\u00e1lidos. Un objeto debe tener un estado consistente con cualquiera de sus superclases o interfaces.","title":"III. Contratos"},{"location":"iiss-dbc/#aserciones-y-contratos","text":"","title":"Aserciones y contratos"},{"location":"iiss-dbc/#aserciones","text":"Oscar Wilde, The Picture of Dorian Gray There is a luxury in self-reproach. When we blame ourselves we feel no one else has a right to blame us.","title":"Aserciones"},{"location":"iiss-dbc/#programacion-asertiva","text":"Ejemplos de situaciones que no van a ocurrir nunca : Con dos d\u00edgitos para el a\u00f1o basta Esta aplicaci\u00f3n nunca va a usarse en el extranjero Este contador nunca va a ser negativo A\u00f1adir aserciones al c\u00f3digo para chequear esas situaciones: void writeString ( String s ) { assert ( s != null ); ... } ... for ( int i = 0 ; i < num_entries - 1 ; i ++ ) { assert ( sorted [ i ] <= sorted [ i + 1 ] ); }","title":"Programaci\u00f3n asertiva"},{"location":"iiss-dbc/#aserciones-e-invariantes","text":"Las aserciones sirven para expresar invariantes . Invariante Condici\u00f3n que se puede considerar cierta durante la ejecuci\u00f3n de un programa o de parte del mismo. Es un predicado l\u00f3gico que se debe mantener siempre cierto durante una cierta fase de la ejecuci\u00f3n. Por ejemplo, una invariante de bucle es una condici\u00f3n que es cierta al principio y al final de cada ejecuci\u00f3n de un bucle","title":"Aserciones e invariantes"},{"location":"iiss-dbc/#aserciones-en-java","text":"Forma 1: assert Expression1 ; Forma 2: assert Expression1 : Expression2 ; Expression1 es boolean Expression2 devuelve un valor que es pasado al constructor de AssertionError , que usa una representaci\u00f3n en forma de String del valor como detalle del mensaje En versiones antiguas del JDK, notificar al compilador que las acepte: javac -source 1 .4 *.java Las aserciones en Java imponen un alto coste en rendimiento y puede ser conveniente desabilitarlas en tiempo de ejecuci\u00f3n: java [ -enableassertions | -ea ] [ :<package name> \"...\" | :<class name> ] java [ -disableassertions | -da ] [ :<package name> \"...\" | :<class name> ]","title":"Aserciones en Java"},{"location":"iiss-dbc/#gestion-de-errores","text":"Las aserciones no son para gesti\u00f3n de errores: try { BufferedReader in = new BufferedReader ( new InputStreamReader ( System . in )); String input ; System . out . print ( \"Please Type Something here: \" ); input = in . readLine (); assert (( input . equalsIgnoreCase ( \"Y\" ) || ( input . equalsIgnoreCase ( \"N\" )); /* bad idea! */ ... } catch ( Exception ex ) { System . out . print ( \"We've had an Exception: \" + ex . getMessage ()); }","title":"\u00bfGesti\u00f3n de errores?"},{"location":"iiss-dbc/#efectos-colaterales","text":"Cuidado con los efectos colaterales de las expresiones de una aserci\u00f3n: while ( Iterator i . hasNext () { assert ( i . next () != null ); /* side effect */ Object obj = i . next (); // ... } while ( Iterator i . hasNext () { Object obj = i . next (); assert ( obj != null ); // ... }","title":"Efectos colaterales"},{"location":"iiss-dbc/#tipos-de-invariantes","text":"","title":"Tipos de invariantes"},{"location":"iiss-dbc/#invariantes-internas","text":"Sustituir los comentarios que indicaban invariantes: if ( i % 3 == 0 ) { ... } else if ( i % 3 == 1 ) { ... } else { // We know (i % 3 == 2) ... } Mejor con aserciones: if ( i % 3 == 0 ) { ... } else if ( i % 3 == 1 ) { ... } else { assert i % 3 == 2 : i ; ... }","title":"Invariantes internas"},{"location":"iiss-dbc/#invariantes-de-control-de-flujo","text":"Para selectivas : switch ( suit ) { case Suit . CLUBS : ... break ; case Suit . DIAMONDS : ... break ; case Suit . HEARTS : ... break ; case Suit . SPADES : ... } A\u00f1adir: default : assert false : suit ; o tambi\u00e9n (protecci\u00f3n aunque se deshabiliten las aserciones, pero sin coste extra): default : throw new AssertionError ( suit ); Puntos inalcanzables : void foo () { for (...) { if (...) return ; } assert false ; // Execution should never reach this point!!! }","title":"Invariantes de control de flujo"},{"location":"iiss-dbc/#invariantes-de-clase","text":"Son un tipo de invariantes internas que se aplican a todas las instancias de una clase, en todos los momentos, excepto cuando una instancia est\u00e1 en transici\u00f3n de un estado consistente a otro. Por ejemplo, en un \u00e1rbol binario equilibrado, una invariante de clase puede indicar que est\u00e1 ordenado y equilibrado: A\u00f1adir c\u00f3digo en Java: // Returns true if this tree is properly balanced private boolean isBalanced () { ... } Todo constructor y m\u00e9todo p\u00fablico debe llamar a assert isBalanced (); antes del return . Es recomendable incluir comprobaciones de invariantes de clase al principio de los m\u00e9todos de clases cuyo estado es modificable por otras clases (v.g. setters ).","title":"Invariantes de clase"},{"location":"iiss-dbc/#idiom-para-definir-aserciones-finales","text":"A veces hace falta guardar datos antes de hacer un c\u00f3mputo, para poder luego comprobar una condici\u00f3n cuando el c\u00f3mputo se haya completado. Ejemplo de c\u00f3mo hacerlo con una inner class que guarda el estado de variables: void foo ( int [] array ) { // Manipulate array ... // At this point, array will contain exactly the ints that it did // prior to manipulation, in the same order. } void foo ( final int [] array ) { class DataCopy { private int [] arrayCopy ; DataCopy () { arrayCopy = ( int [] )( array . clone ()); } boolean isConsistent () { return Arrays . equals ( array , arrayCopy ); } } DataCopy copy = null ; // Always succeeds; has side effect of saving a copy of array assert ( copy = new DataCopy ()) != null ; ... // Manipulate array assert copy . isConsistent (); }","title":"Idiom para definir aserciones finales"},{"location":"iiss-dbc/#programacion-por-contratos","text":"","title":"Programaci\u00f3n por contratos"},{"location":"iiss-dbc/#contrato","text":"Un contrato entre dos partes define derechos y responsabilidades por ambas partes Define las repercusiones por incumplimiento del contrato","title":"Contrato"},{"location":"iiss-dbc/#design-by-contract-dbc","text":"Desarrollado para lenguaje Eiffel por Bertrand Meyer Documentar y aceptar los derechos y responsabilidades de cada m\u00f3dulo de software para asegurar la correci\u00f3n de un programa Un programa correcto es aqu\u00e9l que hace nada m\u00e1s y nada menos que lo que dice hacer","title":"Design By Contract (DBC)"},{"location":"iiss-dbc/#precondiciones-postcondiciones-e-invariantes","text":"","title":"Precondiciones, postcondiciones e invariantes"},{"location":"iiss-dbc/#precondicion","text":"Qu\u00e9 debe ser cierto antes de llamar a una rutina/m\u00e9todo (sus requisitos) Una rutina jam\u00e1s debe ser llamada si se violan sus precondiciones Es responsabilidad del que la llama hacer que se cumplan","title":"Precondici\u00f3n"},{"location":"iiss-dbc/#postcondicion","text":"Qu\u00e9 garantiza la rutina: estado del mundo cuando la rutina/m\u00e9todo termina Implica que la rutina debe finalizar: no puede haber bucles infinitos","title":"Postcondici\u00f3n"},{"location":"iiss-dbc/#invariante-de-clase","text":"Condici\u00f3n que se cumple para todas las instancias de la clase, desde la perspectiva del llamador Durante el procesamiento interno, la invariante puede no cumplirse, pero s\u00ed cuando la rutina termina y se devuelve el control al llamador Una clase no puede dar permiso de escritura sin restricciones sobre las propiedades ( data members ) que participan en la definici\u00f3n de la invariante","title":"Invariante de clase"},{"location":"iiss-dbc/#ejemplo-raiz-cuadrada-en-eiffel","text":"sqrt : DOUBLE is -- Square root routine require sqrt_arg_must_be_positive : Current >= 0 ; --- ... --- calculate square root here --- ... ensure (( Result * Result ) - Current ). abs <= epsilon * Current . abs ; -- Result should be within error tolerance end ; Si el usuario introduce un n\u00famero negativo en la consola, es responsabilidad del c\u00f3digo que llama a sqrt que dicho valor no se pase nunca a sqrt . Opciones: Terminar Emitir una advertencia y leer otro n\u00famero Pasar el n\u00famero a complejo (ponerlo en positivo y a\u00f1adir una i ) Si se llega a pasar un n\u00famero negativo, Eiffel imprime el error sqrt_arg_must_be_positive en tiempo de ejecuci\u00f3n y una traza de la pila (En otros lenguajes, como Java, se devolver\u00eda un Nan ).","title":"Ejemplo: Ra\u00edz cuadrada en Eiffel"},{"location":"iiss-dbc/#ejemplo-cuenta-bancaria","text":"","title":"Ejemplo: Cuenta Bancaria"},{"location":"iiss-dbc/#cuenta-bancaria-sin-contratos","text":"class ACCOUNT feature balance : INTEGER owner : PERSON minimum_balance : INTEGER is 1000 open ( who : PERSON ) is -- Assign the account to owner who. do owner := who end deposit ( sum : INTEGER ) is -- Deposit sum into the account. do add ( sum ) end withdraw ( sum : INTEGER ) is -- Withdraw sum from the account. do add ( - sum ) end may_withdraw ( sum : INTEGER ): BOOLEAN is -- Is there enough money to withdraw sum? do Result := ( balance >= sum + minimum_balance ) end feature { NONE } add ( sum : INTEGER ) is -- Add sum to the balance. do balance := balance + sum end end -- class ACCOUNT feature son las operaciones de la clase feature { NONE } son privados make para definir el constructor","title":"Cuenta Bancaria sin contratos"},{"location":"iiss-dbc/#cuenta-bancaria-con-contratos","text":"class ACCOUNT create make feature -- ... Attributes as before: balance , minimum_balance , owner , open ... deposit ( sum : INTEGER ) is -- Deposit sum into the account. require sum >= 0 do add ( sum ) ensure balance = old balance + sum end withdraw ( sum : INTEGER ) is -- Withdraw sum from the account. require sum >= 0 sum <= balance - minimum_balance do add ( - sum ) ensure balance = old balance - sum end may_withdraw ... -- As before feature { NONE } add ... -- As before make ( initial : INTEGER ) is -- Initialize account with initial balance. require initial >= minimum_balance do balance := initial end invariant balance >= minimum_balance end -- class ACCOUNT","title":"Cuenta Bancaria con contratos"},{"location":"iiss-dbc/#contratos-en-los-lenguajes","text":"Contratos en Java iContract , inactiva, recuperada en Java Contract Suite o JContractS Contracts for Java o Cofoja Etc. Actividad: Contratos en Scala Scala permite especificar aserciones ( assert ), precondiciones ( require ), postcondiciones ( ensuring ) e invariantes ( assume ). Ejemplo: def divide ( x : Int , y : Int ) : Int = { require ( x > y , s\" $x > $y \" ) require ( y > 0 , s\" $y > 0\" ) x / y } ensuring ( _ * y == x ) Seguir el tutorial Design by Contract Actividad: \u00bfHay contratos en C++? A\u00fan no hay contratos en C++17 ni en C++20. Ver el video de J. D. Garc\u00eda sobre Contracts programming after C++17 : Desde el minuto 4'10''","title":"Contratos en los lenguajes"},{"location":"iiss-dbc/#ejemplo-java-icontract","text":"Java no permite especificar contratos (los assert no son lo mismo). As\u00ed que hay que utilizar extensiones como iContract Ejemplo : Inserci\u00f3n en una lista ordenada /** * @invariant forall Node n in elements() | * n.prev() != null * implies * n.value().compareTo(n.prev().value()) > 0 */ public class OrderedList { /** * @pre contains(aNode) == false * @post contains(aNode) == true */ public void insertNode ( final Node aNode ) { // ... } // ... } Una postcondici\u00f3n puede necesitar expresarse con par\u00e1metros pasados a un m\u00e9todo para verificar un comportamiento correcto. Si el m\u00e9todo puede cambiar el valor del par\u00e1metro pasado (par\u00e1metro mutable), el contrato puede incumplirse.","title":"Ejemplo: Java + iContract"},{"location":"iiss-dbc/#parametros-inmutables","text":"Eiffel no permite que se pueda cambiar el valor de un par\u00e1metro (es inmutable) En C++ usar const Opciones en Java: Usar final para marcar un par\u00e1metro constante. Sin embargo, las subclases podr\u00edan redefinir los par\u00e1metros y volver a hacerlos mutables. Adem\u00e1s final se aplica a la referencia, no al objeto en s\u00ed. Usar variable@pre de iContract Muchos lenguajes funcionales (Lisp, Haskell, Erlang, Clojure, etc.) definen inmutabilidad por defecto","title":"Par\u00e1metros inmutables"},{"location":"iiss-dbc/#por-que-la-inmutabilidad","text":"Por rendimiento (v.g. String en Java): si es inmutable, para copiar un objeto basta con copiar la referencia ( interning ) Por thread-safety para c\u00f3digo concurrente","title":"\u00bfPor qu\u00e9 la inmutabilidad?"},{"location":"iiss-dbc/#codigo-perezoso","text":"Se recomienda escribir c\u00f3digo \"perezoso\" para los contratos: ser estricto en lo que se acepta al empezar y prometer lo menos posible al terminar. Si un contrato indica que se acepta cualquier cosa y promete la luna a cambio, habr\u00e1 que escribir un mont\u00f3n de c\u00f3digo!","title":"C\u00f3digo perezoso"},{"location":"iiss-dbc/#dead-programs-tell-no-lies","text":"El dise\u00f1o y la programaci\u00f3n basada en contratos son una forma de incrementar la calidad del c\u00f3digo mediante early crash . Hay otras t\u00e9cnicas (que veremos m\u00e1s adelante), pero en general el principio b\u00e1sico es: cuando el c\u00f3digo descubre que sucede algo que supuestamente es imposible o \"no deber\u00eda suceder\", el programa ya no es viable: eutanasia. En Java se lanza una RuntimeException cuando sucede algo extra\u00f1o en tiempo de ejecuci\u00f3n. Se puede/debe hacer lo mismo con cualquier lenguaje","title":"Dead programs tell no lies"},{"location":"iiss-dbc/#aserciones-versus-contratos-en-java","text":"No hay soporte para propagar aserciones por una jerarqu\u00eda de herencia: si se redefine un m\u00e9todo con contrato, las aserciones que implementan el contrato no ser\u00e1n llamadas correctamente (excepto si se duplican en el c\u00f3digo) No hay soporte para valores antiguos : si se implementara un contrato mediante aserciones, habr\u00eda que a\u00f1adir c\u00f3digo a la precondici\u00f3n para guardar la informaci\u00f3n que quiera usarse en la postcondici\u00f3n. (v.g. variable@pre en iContract versus old expression en Eiffel) El sistema de runtime y las bibliotecas no est\u00e1n dise\u00f1adas para dar soporte a contratos, as\u00ed que estos no se chequean . Y es precisamente en la frontera entre el cliente y la biblioteca donde hay m\u00e1s problemas.","title":"Aserciones versus contratos en Java"},{"location":"iiss-dbc/#redefinicion-de-contratos","text":"Redefinici\u00f3n de contratos A routine redeclaration [in a derivative] may only replace the original precondition by one equal or weaker, and the original post-condition by one equal or stronger Bertrand Meyer Los m\u00e9todos de clase declaran precondiciones y postcondiciones al redefinir una operaci\u00f3n en una subclase derivada. Las precondiciones s\u00f3lo pueden sustituirse por otras m\u00e1s d\u00e9biles/laxas. Los m\u00e9todos pueden redefinirse con implementaciones que aceptan un rango m\u00e1s amplio de entradas. Las postcondiciones s\u00f3lo pueden sustituirse por otras m\u00e1s fuertes/estrictas. Los m\u00e9todos pueden redefinirse con implementaciones que generan un rango m\u00e1s estrecho de salidas. Las invariantes s\u00f3lo pueden sustituirse por otras m\u00e1s fuertes/estrictas. Las clases e interfaces pueden derivarse para restringir el conjunto de estados v\u00e1lidos. Un objeto debe tener un estado consistente con cualquiera de sus superclases o interfaces.","title":"Redefinici\u00f3n de contratos"},{"location":"iiss-err/","text":"CALIDAD Calidad \u00b6 Tratamiento de errores \u00b6 C\u00f3digos de error \u00b6 Un ejemplo habitual de tratamiento de errores con c\u00f3digos de error en un lenguaje como C: if ( deletePage ( page ) == E_OK ) { if ( registry . deleteReference ( page . name ) == E_OK ) { if ( configKeys . deleteKey ( page . name . makeKey ()) == E_OK ){ logger . log ( \"page deleted\" ); } else { logger . log ( \"configKey not deleted\" ); } } else { logger . log ( \"deleteReference from registry failed\" ); } } else { logger . log ( \"delete failed\" ); return E_ERROR ; } Con esta t\u00e9cnica creamos imanes de dependencias : public enum Error { OK , INVALID , NO_SUCH , LOCKED , OUT_OF_RESOURCES , WAITING_FOR_EVENT ; } Failure Los programadores intentan evitar a\u00f1adir nuevos motivos de error, porque eso significa tener que volver a compilar y desplegar todo el c\u00f3digo. Excepciones \u00b6 Muchos lenguajes usan excepciones en lugar de c\u00f3digos de error: try { deletePage ( page ); registry . deleteReference ( page . name ); configKeys . deleteKey ( page . name . makeKey ()); } catch ( Exception e ) { logger . log ( e . getMessage ()); } \u00bfNo queda m\u00e1s claro? Ventaja Las nuevas excepciones son derivadas de una clase base Exception , lo que facilita la definici\u00f3n de nuevos motivos de error. \u00bfD\u00f3nde se produce el error? Si se eleva una excepci\u00f3n en el ejemplo anterior, \u00bfen cu\u00e1l de las instrucciones del bloque try se ha producido? Separar la funci\u00f3n y el tratamiento de errores \u00b6 public void delete ( Page page ) { try { deletePageAndAllReferences ( page ); } catch ( Exception e ) { logError ( e ); } } private void deletePageAndAllReferences ( Page page ) throws Exception { deletePage ( page ); registry . deleteReference ( page . name ); configKeys . deleteKey ( page . name . makeKey ()); } private void logError ( Exception e ) { logger . log ( e . getMessage ()); } \u00bfNo queda m\u00e1s f\u00e1cil de comprender, modificar y depurar? Excepciones en Java \u00b6 Tipos de excepciones en Java \u00b6 Checked Instancias de clases derivadas de java.lang.Throwable (menos RuntimeException ). Deben declararse en el m\u00e9todo mediante throws y obligan al llamador a tratar la excepci\u00f3n. Unchecked Instancias de clases derivadas de java.lang.RuntimeException . No se declaran en el m\u00e9todo y no obligan al llamador a tratar la excepci\u00f3n. \u00bfQu\u00e9 implica elevar una excepci\u00f3n e en Java? Deshacer ( roll back ) la llamada a un m\u00e9todo... ...hasta que se encuentre un bloque catch para el tipo de e y... si no se encuentra, la excepci\u00f3n es capturada por la JVM, que detiene el programa Tratamiento de excepciones en Java \u00b6 try { /* guarded region that can send IOException or Exception */ } catch ( IOException e ) { /* decide what to do when an IOException or a sub-class of IOException occurs */ } catch ( Exception e ) { // Treats any other exceptions } finally { // in all cases execute this } Recomendaciones \u00b6 Incluir el contexto de la ejecuci\u00f3n: Incluir informaci\u00f3n suficiente con cada excepci\u00f3n para determinar el motivo y la ubicaci\u00f3n de un error No basta con el stack trace Escribir mensajes informativos: operaci\u00f3n fallida y tipo de fallo Los beneficios de las excepciones checked en Java son m\u00ednimos: \u00bfpor qu\u00e9 . Se recomienda usar solamente excepciones unchecked . C#, C++, Python o Ruby no ofrecen excepciones checked . Scala no usa excepciones checked como Java: Scala exception handling Se paga el precio de violar el principio OCP ( Open-Closed Principle ): si lanzamos una excepci\u00f3n checked desde un m\u00e9todo y el catch est\u00e1 tres niveles por encima, hay que declarar la excepci\u00f3n en la signatura de todos los m\u00e9todos que van entre medias. Esto significa que un cambio en un nivel bajo del software puede forzar cambios en niveles altos. Transformaci\u00f3n de excepciones \u00b6 Transformar en unchecked \u00b6 Muchas APIs de Java lanzan excepciones checked cuando deber\u00edan ser unchecked Ejemplo : Al ejecutar una consulta mediante executeQuery en el API de JDBC se lanza una excepci\u00f3n java.sql.SQLException (de tipo checked) si la SQL es err\u00f3nea. Soluci\u00f3n : Transformar las excepciones checked en unchecked: try { // Codigo que genera la excepcion checked } catch ( Exception ex ) { throw new RuntimeException ( \"Unchecked exception\" , ex ) } Excepciones encapsuladas \u00b6 Criticar la siguiente implementaci\u00f3n: ACMEPort port = new ACMEPort ( 12 ); try { port . open (); } catch ( DeviceResponseException e ) { reportPortError ( e ); logger . log ( \"Device response exception\" , e ); } catch ( ATM1212UnlockedException e ) { reportPortError ( e ); logger . log ( \"Unlock exception\" , e ); } catch ( GMXError e ) { reportPortError ( e ); logger . log ( \"Device response exception\" ); } finally { ... } Excesiva duplicaci\u00f3n de c\u00f3digo La llamada a reportPortError() se repite mucho. \u00bfC\u00f3mo evitar la excesiva duplicaci\u00f3n? Soluci\u00f3n: Excepci\u00f3n encapsulada LocalPort port = new LocalPort ( 12 ); try { port . open (); } catch ( PortDeviceFailure e ) { reportPortError ( e ); logger . log ( e . getMessage (), e ); } finally { ... } public class LocalPort { private ACMEPort innerPort ; public LocalPort ( int portNumber ) { innerPort = new ACMEPort ( portNumber ); } public void open () throws PortDeviceFailure { try { innerPort . open (); } catch ( DeviceResponseException e ) { throw new PortDeviceFailure ( e ); } catch ( ATM1212UnlockedException e ) { throw new PortDeviceFailure ( e ); } catch ( GMXError e ) { throw new PortDeviceFailure ( e ); } } ... } La encapsulaci\u00f3n de excepciones es recomendable cuando se usa un API de terceros, para minimizar las dependencias con respecto al API elegido. Tambi\u00e9n facilitan la implementaci\u00f3n de mocks del componente que proporciona el API para construir pruebas. Las excepciones son excepcionales \u00b6 Recomendaci\u00f3n de uso : Usar excepciones para problemas excepcionales (eventos inesperados) Excepciones tras la apertura de ficheros \u00bfUsar excepciones cuando se intenta abrir un fichero para leer y el fichero no existe? Depende de si el fichero debe estar ah\u00ed Caso en que se debe lanzar una excepci\u00f3n: public void open_passwd () throws FileNotFoundException { // This may throw FileNotFoundException... ipstream = new FileInputStream ( \"/etc/passwd\" ); // ... } Caso en que no se debe lanzar una excepci\u00f3n: public boolean open_user_file ( String name ) throws FileNotFoundException { File f = new File ( name ); if ( ! f . exists ()) return false ; ipstream = new FileInputStream ( f ); return true ; } Uso de null \u00b6 Obtener un null cuando no se espera puede ser un quebradero de cabeza para el tratamiento de errores Principio general: no devolver null \u00b6 Este c\u00f3digo puede parecer inofensivo, pero es maligno: public void registerItem ( Item item ) { if ( item != null ) { ItemRegistry registry = peristentStore . getItemRegistry (); if ( registry != null ) { Item existing = registry . getItem ( item . getID ()); if ( existing . getBillingPeriod (). hasRetailOwner ()) { existing . register ( item ); } } } } \u00bfQu\u00e9 pasa si persistentStore es null? Peligro de NullPointerException \u00bfSe nos ha olvidado a\u00f1adir un if null ? El problema no es que se haya olvidado uno, sino que hay demasiados En su lugar, elevar una excepci\u00f3n o devolver un objeto especial No devolver null \u00b6 Evitar: List < Employee > employees = getEmployees (); if ( employees != null ) { for ( Employee e : employees ) { totalPay += e . getPay (); } } Mejor as\u00ed: List < Employee > employees = getEmployees (); for ( Employee e : employees ) { totalPay += e . getPay (); } public List < Employee > getEmployees () { if ( /* there are no employees */ ) return Collections . emptyList (); } No pasar valores null \u00b6 public class MetricsCalculator { public double xProjection ( Point p1 , Point p2 ) { return ( p2 . x - p1 . x ) * 1.5 ; } \u00bfQu\u00e9 sucede si llamamos a xProjection() as\u00ed...? calculator . xProjection ( null , new Point ( 12 , 13 )) Devolver null es malo, pero \u00a1pasar un valor null es peor! \u00bfEs mejor as\u00ed...? public class MetricsCalculator { public double xProjection ( Point p1 , Point p2 ) { if ( p1 == null || p2 == null ) { throw InvalidArgumentException ( \"Invalid argument for MetricsCalculator.xProjection\" ); } return ( p2 . x - p1 . x ) * 1.5 ; } } \u00bfQu\u00e9 curso de acci\u00f3n tomar ante un InvalidArgumentException ? \u00bfHay alguno? Alternativa con aserciones \u00b6 Solo para JDK \\geq \\geq 5.0 public class MetricsCalculator { public double xProjection ( Point p1 , Point p2 ) { assert p1 != null : \"p1 should not be null\" ; assert p2 != null : \"p2 should not be null\" ; return ( p2 . x - p1 . x ) * 1.5 ; } } El uso de assert es una buena forma de documentar, pero no resuelve el problema. Optionals \u00b6 En la mayor\u00eda de lenguajes no hay forma satisfactoria de tratar con nulls pasados como argumento accidentalmente. Para eso est\u00e1n los options u optionals , disponibles actualmente en muchos lenguajes como: Scala Option Java 8 java . util . Optional C++17 std :: optional TypeScript recomienda usar undefined (algo que no se ha inicializado) en lugar de null (algo que no est\u00e1 disponible) Lecturas recomendadas Leer el Tutorial de Option en Scala Scala Option \u00b6 En Scala, Option [ T ] es un contenedor de un valor opcional de tipo T. Si el valor de tipo T est\u00e1 presente, Option [ T ] es una intancia de Some [ T ] que contiene el valor presente de tipo T. Si el valor est\u00e1 ausente, Option [ T ] es el objeto None . Valores vac\u00edos en Scala Conocer las diferencias entre Null , null , Nil , Nothing , None y Unit en Scala object Demo { def main ( args : Array [ String ]) { val a : Option [ Int ] = Some ( 5 ) val b : Option [ Int ] = None println ( \"a.isEmpty: \" + a . isEmpty ) //false println ( \"b.isEmpty: \" + b . isEmpty ) //true } } object Demo { def main ( args : Array [ String ]) { val capitals = Map ( \"France\" -> \"Paris\" , \"Japan\" -> \"Tokyo\" ) println ( \"show(capitals.get( \\\"Japan\\\")) : \" + show ( capitals . get ( \"Japan\" )) ) println ( \"show(capitals.get( \\\"India\\\")) : \" + show ( capitals . get ( \"India\" )) ) } def show ( x : Option [ String ]) = x match { case Some ( s ) => s case None => \"?\" } } Java 8 Optional \u00b6 Lecturas recomendadas Leer Java 8 Optional in Depth . Leer Jugando con Optional en Java 8 . Ejemplo en Java 8 con sintaxis imperativa private static Optional < Double > getDurationOfAlbumWithName ( String name ) { Album album ; Optional < Album > albumOptional = getAlbum ( name ); if ( albumOptional . isPresent ()) { // equivalente a albumOptional == null album = albumOptional . get (); Optional < List < Track >> tracksOptional = getAlbumTracks ( album . getName ()); double duration = 0 ; if ( tracksOptional . isPresent ()) { // equivalente a tracksOptional == null List < Track > tracks = tracksOptional . get (); for ( Track track : tracks ) { duration += track . getDuration (); } return Optional . of ( duration ); } else { return Optional . empty (); } } else { return Optional . empty (); } } Al ejecutar varias operaciones seguidas que pueden devolver null, el nivel de anidamiento del c\u00f3digo aumenta y queda menos claro (se mezcla c\u00f3digo funcional con c\u00f3digo de gesti\u00f3n de errores). Soluci\u00f3n... Ejemplo en Java 8 con sintaxis fluent Optional < Double > getDurationOfAlbumWithName ( String name ) { Optional < Double > duration = getAlbum ( name ) . flatMap (( album ) -> getAlbumTracks ( album . getName ())) . map (( tracks ) -> getTracksDuration ( tracks )); return duration ; } La funci\u00f3n map comprueba si el Optional que recibe est\u00e1 vac\u00edo. Si lo est\u00e1 devuelve un Optional vac\u00edo y, si no, aplica la funci\u00f3n que le hemos pasado por par\u00e1metro, pas\u00e1ndole el valor del Optional . Es decir, si el Optional est\u00e1 vac\u00edo, el m\u00e9todo map no hace nada. Esto sirve para concatenar operaciones sin necesidad de comprobar en cada momento si el Optional est\u00e1 vac\u00edo. Cuando queremos encadenar distintas operaciones que devuelvan Optional , es necesario usar flatMap , ya que si no acabar\u00edamos teniendo un Optional<Optional<Double>> . private static double getDurationOfAlbumWithName ( String name ) { return getAlbum ( name ) . flatMap (( album ) -> getAlbumTracks ( album . getName ())) . map (( tracks ) -> getTracksDuration ( tracks )) . orElse ( 0.0 ); } Podr\u00edamos seguir devolviendo Optional por toda la aplicaci\u00f3n, pero en alg\u00fan momento tenemos que decidir qu\u00e9 hacer en caso de que el valor que queremos no estuviera presente. Para ello se usa orElse() para proporcionar un valor alternativo en caso de que el valor no estuviera presente. Ejemplo sin Optional Programa de prueba: public class MobileTesterWithoutOptional { public static void main ( String [] args ) { ScreenResolution resolution = new ScreenResolution ( 750 , 1334 ); DisplayFeatures dfeatures = new DisplayFeatures ( \"4.7\" , resolution ); Mobile mobile = new Mobile ( 2015001 , \"Apple\" , \"iPhone 6s\" , dfeatures ); MobileService mService = new MobileService (); int mobileWidth = mService . getMobileScreenWidth ( mobile ); System . out . println ( \"Apple iPhone 6s Screen Width = \" + mobileWidth ); ScreenResolution resolution2 = new ScreenResolution ( 0 , 0 ); DisplayFeatures dfeatures2 = new DisplayFeatures ( \"0\" , resolution2 ); Mobile mobile2 = new Mobile ( 2015001 , \"Apple\" , \"iPhone 6s\" , dfeatures2 ); int mobileWidth2 = mService . getMobileScreenWidth ( mobile2 ); System . out . println ( \"Apple iPhone 16s Screen Width = \" + mobileWidth2 ); } } Dependencias: MobileService \\dashrightarrow \\dashrightarrow DisplayFeatures , ScreenResolution Cantidad de c\u00f3digo boilerplate para comprobar los nulos en la clase principal: public class MobileService { public int getMobileScreenWidth ( Mobile mobile ){ if ( mobile != null ){ DisplayFeatures dfeatures = mobile . getDisplayFeatures (); if ( dfeatures != null ){ ScreenResolution resolution = dfeatures . getResolution (); if ( resolution != null ){ return resolution . getWidth (); } } } return 0 ; } } Clases de utilidad: public class ScreenResolution { private int width ; private int height ; public ScreenResolution ( int width , int height ){ this . width = width ; this . height = height ; } public int getWidth () { return width ; } public int getHeight () { return height ; } } public class DisplayFeatures { private String size ; // In inches private ScreenResolution resolution ; public DisplayFeatures ( String size , ScreenResolution resolution ){ this . size = size ; this . resolution = resolution ; } public String getSize () { return size ; } public ScreenResolution getResolution () { return resolution ; } } public class Mobile { private long id ; private String brand ; private String name ; private DisplayFeatures displayFeatures ; // Likewise we can see Memory Features, Camera Features etc. public Mobile ( long id , String brand , String name , DisplayFeatures displayFeatures ){ this . id = id ; this . brand = brand ; this . name = name ; this . displayFeatures = displayFeatures ; } public long getId () { return id ; } public String getBrand () { return brand ; } public String getName () { return name ; } public DisplayFeatures getDisplayFeatures () { return displayFeatures ; } } Ejemplo con Optionals Uso de m\u00e9todos de Optional en el programa de prueba: public class MobileTesterWithOptional { public static void main ( String [] args ) { ScreenResolution resolution = new ScreenResolution ( 750 , 1334 ); DisplayFeatures dfeatures = new DisplayFeatures ( \"4.7\" , Optional . of ( resolution )); Mobile mobile = new Mobile ( 2015001 , \"Apple\" , \"iPhone 6s\" , Optional . of ( dfeatures )); MobileService mService = new MobileService (); int width = mService . getMobileScreenWidth ( Optional . of ( mobile )); System . out . println ( \"Apple iPhone 6s Screen Width = \" + width ); Mobile mobile2 = new Mobile ( 2015001 , \"Apple\" , \"iPhone 6s\" , Optional . empty ()); int width2 = mService . getMobileScreenWidth ( Optional . of ( mobile2 )); System . out . println ( \"Apple iPhone 16s Screen Width = \" + width2 ); } } Menos c\u00f3digo boilerplate en la clase principal: public class MobileService { public Integer getMobileScreenWidth ( Optional < Mobile > mobile ){ return mobile . flatMap ( Mobile :: getDisplayFeatures ) . flatMap ( DisplayFeatures :: getResolution ) . map ( ScreenResolution :: getWidth ) . orElse ( 0 ); } } Clases de utilidad: import java.util.Optional ; public class DisplayFeatures { private String size ; // In inches private Optional < ScreenResolution > resolution ; public DisplayFeatures ( String size , Optional < ScreenResolution > resolution ){ this . size = size ; this . resolution = resolution ; } public String getSize () { return size ; } public Optional < ScreenResolution > getResolution () { return resolution ; } } public class Mobile { private long id ; private String brand ; private String name ; private Optional < DisplayFeatures > displayFeatures ; // Like wise we can see MemoryFeatures, CameraFeatures etc. // For simplicity, using only one Features public Mobile ( long id , String brand , String name , Optional < DisplayFeatures > displayFeatures ){ this . id = id ; this . brand = brand ; this . name = name ; this . displayFeatures = displayFeatures ; } public long getId () { return id ; } public String getBrand () { return brand ; } public String getName () { return name ; } public Optional < DisplayFeatures > getDisplayFeatures () { return displayFeatures ; } } Carencias de Optional \u00b6 El tratamiento de errores cl\u00e1sico del lenguaje C (con el que empez\u00e1bamos este cap\u00edtulo) se basa en devolver un valor especial que contiene un c\u00f3digo de error (normalmente negativo) que indica qu\u00e9 ha salido mal. Se podr\u00edan representar tantos motivos de error como posibles valores devueltos. Los Optional no ofrecen la posibilidad de que decir qu\u00e9 es lo que ha salido mal (en caso de que no haya valor a devolver). Por tanto, no son apropiados para m\u00e9todos en los que pueden salir varias cosas mal y no solo una (que no exista un valor a devolver) Lenguajes como Scala proponen alternativas como Either y Validation . object EitherLeftRightExample extends App { /** * A method to demonstrate how to declare that a method returns an Either, * and code that returns a Left or Right. */ def divideXByY ( x : Int , y : Int ) : Either [ String , Int ] = { if ( y == 0 ) Left ( \"Dude, can't divide by 0\" ) else Right ( x / y ) } // a few different ways to use Either, Left, and Right println ( divideXByY ( 1 , 0 )) println ( divideXByY ( 1 , 1 )) divideXByY ( 1 , 0 ) match { case Left ( s ) => println ( \"Answer: \" + s ) case Right ( i ) => println ( \"Answer: \" + i ) } }","title":"Calidad"},{"location":"iiss-err/#calidad","text":"","title":"Calidad"},{"location":"iiss-err/#tratamiento-de-errores","text":"","title":"Tratamiento de errores"},{"location":"iiss-err/#codigos-de-error","text":"Un ejemplo habitual de tratamiento de errores con c\u00f3digos de error en un lenguaje como C: if ( deletePage ( page ) == E_OK ) { if ( registry . deleteReference ( page . name ) == E_OK ) { if ( configKeys . deleteKey ( page . name . makeKey ()) == E_OK ){ logger . log ( \"page deleted\" ); } else { logger . log ( \"configKey not deleted\" ); } } else { logger . log ( \"deleteReference from registry failed\" ); } } else { logger . log ( \"delete failed\" ); return E_ERROR ; } Con esta t\u00e9cnica creamos imanes de dependencias : public enum Error { OK , INVALID , NO_SUCH , LOCKED , OUT_OF_RESOURCES , WAITING_FOR_EVENT ; } Failure Los programadores intentan evitar a\u00f1adir nuevos motivos de error, porque eso significa tener que volver a compilar y desplegar todo el c\u00f3digo.","title":"C\u00f3digos de error"},{"location":"iiss-err/#excepciones","text":"Muchos lenguajes usan excepciones en lugar de c\u00f3digos de error: try { deletePage ( page ); registry . deleteReference ( page . name ); configKeys . deleteKey ( page . name . makeKey ()); } catch ( Exception e ) { logger . log ( e . getMessage ()); } \u00bfNo queda m\u00e1s claro? Ventaja Las nuevas excepciones son derivadas de una clase base Exception , lo que facilita la definici\u00f3n de nuevos motivos de error. \u00bfD\u00f3nde se produce el error? Si se eleva una excepci\u00f3n en el ejemplo anterior, \u00bfen cu\u00e1l de las instrucciones del bloque try se ha producido?","title":"Excepciones"},{"location":"iiss-err/#separar-la-funcion-y-el-tratamiento-de-errores","text":"public void delete ( Page page ) { try { deletePageAndAllReferences ( page ); } catch ( Exception e ) { logError ( e ); } } private void deletePageAndAllReferences ( Page page ) throws Exception { deletePage ( page ); registry . deleteReference ( page . name ); configKeys . deleteKey ( page . name . makeKey ()); } private void logError ( Exception e ) { logger . log ( e . getMessage ()); } \u00bfNo queda m\u00e1s f\u00e1cil de comprender, modificar y depurar?","title":"Separar la funci\u00f3n y el tratamiento de errores"},{"location":"iiss-err/#excepciones-en-java","text":"","title":"Excepciones en Java"},{"location":"iiss-err/#tipos-de-excepciones-en-java","text":"Checked Instancias de clases derivadas de java.lang.Throwable (menos RuntimeException ). Deben declararse en el m\u00e9todo mediante throws y obligan al llamador a tratar la excepci\u00f3n. Unchecked Instancias de clases derivadas de java.lang.RuntimeException . No se declaran en el m\u00e9todo y no obligan al llamador a tratar la excepci\u00f3n. \u00bfQu\u00e9 implica elevar una excepci\u00f3n e en Java? Deshacer ( roll back ) la llamada a un m\u00e9todo... ...hasta que se encuentre un bloque catch para el tipo de e y... si no se encuentra, la excepci\u00f3n es capturada por la JVM, que detiene el programa","title":"Tipos de excepciones en Java"},{"location":"iiss-err/#tratamiento-de-excepciones-en-java","text":"try { /* guarded region that can send IOException or Exception */ } catch ( IOException e ) { /* decide what to do when an IOException or a sub-class of IOException occurs */ } catch ( Exception e ) { // Treats any other exceptions } finally { // in all cases execute this }","title":"Tratamiento de excepciones en Java"},{"location":"iiss-err/#recomendaciones","text":"Incluir el contexto de la ejecuci\u00f3n: Incluir informaci\u00f3n suficiente con cada excepci\u00f3n para determinar el motivo y la ubicaci\u00f3n de un error No basta con el stack trace Escribir mensajes informativos: operaci\u00f3n fallida y tipo de fallo Los beneficios de las excepciones checked en Java son m\u00ednimos: \u00bfpor qu\u00e9 . Se recomienda usar solamente excepciones unchecked . C#, C++, Python o Ruby no ofrecen excepciones checked . Scala no usa excepciones checked como Java: Scala exception handling Se paga el precio de violar el principio OCP ( Open-Closed Principle ): si lanzamos una excepci\u00f3n checked desde un m\u00e9todo y el catch est\u00e1 tres niveles por encima, hay que declarar la excepci\u00f3n en la signatura de todos los m\u00e9todos que van entre medias. Esto significa que un cambio en un nivel bajo del software puede forzar cambios en niveles altos.","title":"Recomendaciones"},{"location":"iiss-err/#transformacion-de-excepciones","text":"","title":"Transformaci\u00f3n de excepciones"},{"location":"iiss-err/#transformar-en-unchecked","text":"Muchas APIs de Java lanzan excepciones checked cuando deber\u00edan ser unchecked Ejemplo : Al ejecutar una consulta mediante executeQuery en el API de JDBC se lanza una excepci\u00f3n java.sql.SQLException (de tipo checked) si la SQL es err\u00f3nea. Soluci\u00f3n : Transformar las excepciones checked en unchecked: try { // Codigo que genera la excepcion checked } catch ( Exception ex ) { throw new RuntimeException ( \"Unchecked exception\" , ex ) }","title":"Transformar en unchecked"},{"location":"iiss-err/#excepciones-encapsuladas","text":"Criticar la siguiente implementaci\u00f3n: ACMEPort port = new ACMEPort ( 12 ); try { port . open (); } catch ( DeviceResponseException e ) { reportPortError ( e ); logger . log ( \"Device response exception\" , e ); } catch ( ATM1212UnlockedException e ) { reportPortError ( e ); logger . log ( \"Unlock exception\" , e ); } catch ( GMXError e ) { reportPortError ( e ); logger . log ( \"Device response exception\" ); } finally { ... } Excesiva duplicaci\u00f3n de c\u00f3digo La llamada a reportPortError() se repite mucho. \u00bfC\u00f3mo evitar la excesiva duplicaci\u00f3n? Soluci\u00f3n: Excepci\u00f3n encapsulada LocalPort port = new LocalPort ( 12 ); try { port . open (); } catch ( PortDeviceFailure e ) { reportPortError ( e ); logger . log ( e . getMessage (), e ); } finally { ... } public class LocalPort { private ACMEPort innerPort ; public LocalPort ( int portNumber ) { innerPort = new ACMEPort ( portNumber ); } public void open () throws PortDeviceFailure { try { innerPort . open (); } catch ( DeviceResponseException e ) { throw new PortDeviceFailure ( e ); } catch ( ATM1212UnlockedException e ) { throw new PortDeviceFailure ( e ); } catch ( GMXError e ) { throw new PortDeviceFailure ( e ); } } ... } La encapsulaci\u00f3n de excepciones es recomendable cuando se usa un API de terceros, para minimizar las dependencias con respecto al API elegido. Tambi\u00e9n facilitan la implementaci\u00f3n de mocks del componente que proporciona el API para construir pruebas.","title":"Excepciones encapsuladas"},{"location":"iiss-err/#las-excepciones-son-excepcionales","text":"Recomendaci\u00f3n de uso : Usar excepciones para problemas excepcionales (eventos inesperados) Excepciones tras la apertura de ficheros \u00bfUsar excepciones cuando se intenta abrir un fichero para leer y el fichero no existe? Depende de si el fichero debe estar ah\u00ed Caso en que se debe lanzar una excepci\u00f3n: public void open_passwd () throws FileNotFoundException { // This may throw FileNotFoundException... ipstream = new FileInputStream ( \"/etc/passwd\" ); // ... } Caso en que no se debe lanzar una excepci\u00f3n: public boolean open_user_file ( String name ) throws FileNotFoundException { File f = new File ( name ); if ( ! f . exists ()) return false ; ipstream = new FileInputStream ( f ); return true ; }","title":"Las excepciones son excepcionales"},{"location":"iiss-err/#uso-de-null","text":"Obtener un null cuando no se espera puede ser un quebradero de cabeza para el tratamiento de errores","title":"Uso de null"},{"location":"iiss-err/#principio-general-no-devolver-null","text":"Este c\u00f3digo puede parecer inofensivo, pero es maligno: public void registerItem ( Item item ) { if ( item != null ) { ItemRegistry registry = peristentStore . getItemRegistry (); if ( registry != null ) { Item existing = registry . getItem ( item . getID ()); if ( existing . getBillingPeriod (). hasRetailOwner ()) { existing . register ( item ); } } } } \u00bfQu\u00e9 pasa si persistentStore es null? Peligro de NullPointerException \u00bfSe nos ha olvidado a\u00f1adir un if null ? El problema no es que se haya olvidado uno, sino que hay demasiados En su lugar, elevar una excepci\u00f3n o devolver un objeto especial","title":"Principio general: no devolver null"},{"location":"iiss-err/#no-devolver-null","text":"Evitar: List < Employee > employees = getEmployees (); if ( employees != null ) { for ( Employee e : employees ) { totalPay += e . getPay (); } } Mejor as\u00ed: List < Employee > employees = getEmployees (); for ( Employee e : employees ) { totalPay += e . getPay (); } public List < Employee > getEmployees () { if ( /* there are no employees */ ) return Collections . emptyList (); }","title":"No devolver null"},{"location":"iiss-err/#no-pasar-valores-null","text":"public class MetricsCalculator { public double xProjection ( Point p1 , Point p2 ) { return ( p2 . x - p1 . x ) * 1.5 ; } \u00bfQu\u00e9 sucede si llamamos a xProjection() as\u00ed...? calculator . xProjection ( null , new Point ( 12 , 13 )) Devolver null es malo, pero \u00a1pasar un valor null es peor! \u00bfEs mejor as\u00ed...? public class MetricsCalculator { public double xProjection ( Point p1 , Point p2 ) { if ( p1 == null || p2 == null ) { throw InvalidArgumentException ( \"Invalid argument for MetricsCalculator.xProjection\" ); } return ( p2 . x - p1 . x ) * 1.5 ; } } \u00bfQu\u00e9 curso de acci\u00f3n tomar ante un InvalidArgumentException ? \u00bfHay alguno?","title":"No pasar valores null"},{"location":"iiss-err/#alternativa-con-aserciones","text":"Solo para JDK \\geq \\geq 5.0 public class MetricsCalculator { public double xProjection ( Point p1 , Point p2 ) { assert p1 != null : \"p1 should not be null\" ; assert p2 != null : \"p2 should not be null\" ; return ( p2 . x - p1 . x ) * 1.5 ; } } El uso de assert es una buena forma de documentar, pero no resuelve el problema.","title":"Alternativa con aserciones"},{"location":"iiss-err/#optionals","text":"En la mayor\u00eda de lenguajes no hay forma satisfactoria de tratar con nulls pasados como argumento accidentalmente. Para eso est\u00e1n los options u optionals , disponibles actualmente en muchos lenguajes como: Scala Option Java 8 java . util . Optional C++17 std :: optional TypeScript recomienda usar undefined (algo que no se ha inicializado) en lugar de null (algo que no est\u00e1 disponible) Lecturas recomendadas Leer el Tutorial de Option en Scala","title":"Optionals"},{"location":"iiss-err/#scala-option","text":"En Scala, Option [ T ] es un contenedor de un valor opcional de tipo T. Si el valor de tipo T est\u00e1 presente, Option [ T ] es una intancia de Some [ T ] que contiene el valor presente de tipo T. Si el valor est\u00e1 ausente, Option [ T ] es el objeto None . Valores vac\u00edos en Scala Conocer las diferencias entre Null , null , Nil , Nothing , None y Unit en Scala object Demo { def main ( args : Array [ String ]) { val a : Option [ Int ] = Some ( 5 ) val b : Option [ Int ] = None println ( \"a.isEmpty: \" + a . isEmpty ) //false println ( \"b.isEmpty: \" + b . isEmpty ) //true } } object Demo { def main ( args : Array [ String ]) { val capitals = Map ( \"France\" -> \"Paris\" , \"Japan\" -> \"Tokyo\" ) println ( \"show(capitals.get( \\\"Japan\\\")) : \" + show ( capitals . get ( \"Japan\" )) ) println ( \"show(capitals.get( \\\"India\\\")) : \" + show ( capitals . get ( \"India\" )) ) } def show ( x : Option [ String ]) = x match { case Some ( s ) => s case None => \"?\" } }","title":"Scala Option"},{"location":"iiss-err/#java-8-optional","text":"Lecturas recomendadas Leer Java 8 Optional in Depth . Leer Jugando con Optional en Java 8 . Ejemplo en Java 8 con sintaxis imperativa private static Optional < Double > getDurationOfAlbumWithName ( String name ) { Album album ; Optional < Album > albumOptional = getAlbum ( name ); if ( albumOptional . isPresent ()) { // equivalente a albumOptional == null album = albumOptional . get (); Optional < List < Track >> tracksOptional = getAlbumTracks ( album . getName ()); double duration = 0 ; if ( tracksOptional . isPresent ()) { // equivalente a tracksOptional == null List < Track > tracks = tracksOptional . get (); for ( Track track : tracks ) { duration += track . getDuration (); } return Optional . of ( duration ); } else { return Optional . empty (); } } else { return Optional . empty (); } } Al ejecutar varias operaciones seguidas que pueden devolver null, el nivel de anidamiento del c\u00f3digo aumenta y queda menos claro (se mezcla c\u00f3digo funcional con c\u00f3digo de gesti\u00f3n de errores). Soluci\u00f3n... Ejemplo en Java 8 con sintaxis fluent Optional < Double > getDurationOfAlbumWithName ( String name ) { Optional < Double > duration = getAlbum ( name ) . flatMap (( album ) -> getAlbumTracks ( album . getName ())) . map (( tracks ) -> getTracksDuration ( tracks )); return duration ; } La funci\u00f3n map comprueba si el Optional que recibe est\u00e1 vac\u00edo. Si lo est\u00e1 devuelve un Optional vac\u00edo y, si no, aplica la funci\u00f3n que le hemos pasado por par\u00e1metro, pas\u00e1ndole el valor del Optional . Es decir, si el Optional est\u00e1 vac\u00edo, el m\u00e9todo map no hace nada. Esto sirve para concatenar operaciones sin necesidad de comprobar en cada momento si el Optional est\u00e1 vac\u00edo. Cuando queremos encadenar distintas operaciones que devuelvan Optional , es necesario usar flatMap , ya que si no acabar\u00edamos teniendo un Optional<Optional<Double>> . private static double getDurationOfAlbumWithName ( String name ) { return getAlbum ( name ) . flatMap (( album ) -> getAlbumTracks ( album . getName ())) . map (( tracks ) -> getTracksDuration ( tracks )) . orElse ( 0.0 ); } Podr\u00edamos seguir devolviendo Optional por toda la aplicaci\u00f3n, pero en alg\u00fan momento tenemos que decidir qu\u00e9 hacer en caso de que el valor que queremos no estuviera presente. Para ello se usa orElse() para proporcionar un valor alternativo en caso de que el valor no estuviera presente. Ejemplo sin Optional Programa de prueba: public class MobileTesterWithoutOptional { public static void main ( String [] args ) { ScreenResolution resolution = new ScreenResolution ( 750 , 1334 ); DisplayFeatures dfeatures = new DisplayFeatures ( \"4.7\" , resolution ); Mobile mobile = new Mobile ( 2015001 , \"Apple\" , \"iPhone 6s\" , dfeatures ); MobileService mService = new MobileService (); int mobileWidth = mService . getMobileScreenWidth ( mobile ); System . out . println ( \"Apple iPhone 6s Screen Width = \" + mobileWidth ); ScreenResolution resolution2 = new ScreenResolution ( 0 , 0 ); DisplayFeatures dfeatures2 = new DisplayFeatures ( \"0\" , resolution2 ); Mobile mobile2 = new Mobile ( 2015001 , \"Apple\" , \"iPhone 6s\" , dfeatures2 ); int mobileWidth2 = mService . getMobileScreenWidth ( mobile2 ); System . out . println ( \"Apple iPhone 16s Screen Width = \" + mobileWidth2 ); } } Dependencias: MobileService \\dashrightarrow \\dashrightarrow DisplayFeatures , ScreenResolution Cantidad de c\u00f3digo boilerplate para comprobar los nulos en la clase principal: public class MobileService { public int getMobileScreenWidth ( Mobile mobile ){ if ( mobile != null ){ DisplayFeatures dfeatures = mobile . getDisplayFeatures (); if ( dfeatures != null ){ ScreenResolution resolution = dfeatures . getResolution (); if ( resolution != null ){ return resolution . getWidth (); } } } return 0 ; } } Clases de utilidad: public class ScreenResolution { private int width ; private int height ; public ScreenResolution ( int width , int height ){ this . width = width ; this . height = height ; } public int getWidth () { return width ; } public int getHeight () { return height ; } } public class DisplayFeatures { private String size ; // In inches private ScreenResolution resolution ; public DisplayFeatures ( String size , ScreenResolution resolution ){ this . size = size ; this . resolution = resolution ; } public String getSize () { return size ; } public ScreenResolution getResolution () { return resolution ; } } public class Mobile { private long id ; private String brand ; private String name ; private DisplayFeatures displayFeatures ; // Likewise we can see Memory Features, Camera Features etc. public Mobile ( long id , String brand , String name , DisplayFeatures displayFeatures ){ this . id = id ; this . brand = brand ; this . name = name ; this . displayFeatures = displayFeatures ; } public long getId () { return id ; } public String getBrand () { return brand ; } public String getName () { return name ; } public DisplayFeatures getDisplayFeatures () { return displayFeatures ; } } Ejemplo con Optionals Uso de m\u00e9todos de Optional en el programa de prueba: public class MobileTesterWithOptional { public static void main ( String [] args ) { ScreenResolution resolution = new ScreenResolution ( 750 , 1334 ); DisplayFeatures dfeatures = new DisplayFeatures ( \"4.7\" , Optional . of ( resolution )); Mobile mobile = new Mobile ( 2015001 , \"Apple\" , \"iPhone 6s\" , Optional . of ( dfeatures )); MobileService mService = new MobileService (); int width = mService . getMobileScreenWidth ( Optional . of ( mobile )); System . out . println ( \"Apple iPhone 6s Screen Width = \" + width ); Mobile mobile2 = new Mobile ( 2015001 , \"Apple\" , \"iPhone 6s\" , Optional . empty ()); int width2 = mService . getMobileScreenWidth ( Optional . of ( mobile2 )); System . out . println ( \"Apple iPhone 16s Screen Width = \" + width2 ); } } Menos c\u00f3digo boilerplate en la clase principal: public class MobileService { public Integer getMobileScreenWidth ( Optional < Mobile > mobile ){ return mobile . flatMap ( Mobile :: getDisplayFeatures ) . flatMap ( DisplayFeatures :: getResolution ) . map ( ScreenResolution :: getWidth ) . orElse ( 0 ); } } Clases de utilidad: import java.util.Optional ; public class DisplayFeatures { private String size ; // In inches private Optional < ScreenResolution > resolution ; public DisplayFeatures ( String size , Optional < ScreenResolution > resolution ){ this . size = size ; this . resolution = resolution ; } public String getSize () { return size ; } public Optional < ScreenResolution > getResolution () { return resolution ; } } public class Mobile { private long id ; private String brand ; private String name ; private Optional < DisplayFeatures > displayFeatures ; // Like wise we can see MemoryFeatures, CameraFeatures etc. // For simplicity, using only one Features public Mobile ( long id , String brand , String name , Optional < DisplayFeatures > displayFeatures ){ this . id = id ; this . brand = brand ; this . name = name ; this . displayFeatures = displayFeatures ; } public long getId () { return id ; } public String getBrand () { return brand ; } public String getName () { return name ; } public Optional < DisplayFeatures > getDisplayFeatures () { return displayFeatures ; } }","title":"Java 8 Optional"},{"location":"iiss-err/#carencias-de-optional","text":"El tratamiento de errores cl\u00e1sico del lenguaje C (con el que empez\u00e1bamos este cap\u00edtulo) se basa en devolver un valor especial que contiene un c\u00f3digo de error (normalmente negativo) que indica qu\u00e9 ha salido mal. Se podr\u00edan representar tantos motivos de error como posibles valores devueltos. Los Optional no ofrecen la posibilidad de que decir qu\u00e9 es lo que ha salido mal (en caso de que no haya valor a devolver). Por tanto, no son apropiados para m\u00e9todos en los que pueden salir varias cosas mal y no solo una (que no exista un valor a devolver) Lenguajes como Scala proponen alternativas como Either y Validation . object EitherLeftRightExample extends App { /** * A method to demonstrate how to declare that a method returns an Either, * and code that returns a Left or Right. */ def divideXByY ( x : Int , y : Int ) : Either [ String , Int ] = { if ( y == 0 ) Left ( \"Dude, can't divide by 0\" ) else Right ( x / y ) } // a few different ways to use Either, Left, and Right println ( divideXByY ( 1 , 0 )) println ( divideXByY ( 1 , 1 )) divideXByY ( 1 , 0 ) match { case Left ( s ) => println ( \"Answer: \" + s ) case Right ( i ) => println ( \"Answer: \" + i ) } }","title":"Carencias de Optional"},{"location":"iiss-evp-1/","text":"EVENTOS AS\u00cdNCRONOS Programaci\u00f3n as\u00edncrona \u00b6 Listeners \u00b6 Listener con un solo control \u00b6 public class DemoKeyEvents { public static void main ( String [] args ) { DemoKeyEventsFrame frame = new DemoKeyEventsFrame (); frame . setDefaultCloseOperation ( JFrame . EXIT_ON_CLOSE ); frame . setTitle ( \"DemoKeyEvents\" ); frame . pack (); frame . setVisible ( true ); } } class DemoKeyEventsFrame extends JFrame implements KeyListener { private JTextField enterField ; public DemoKeyEventsFrame () { enterField = new JTextField ( 10 ); enterField . addKeyListener ( this ); JPanel panel = new JPanel (); panel . add ( new JLabel ( \"Enter some text:\" )); panel . add ( enterField ); panel . setBorder ( BorderFactory . createEmptyBorder ( 10 , 10 , 10 , 10 )); this . setContentPane ( panel ); } public void keyPressed ( KeyEvent ke ) { System . out . println ( ke . paramString ()); final KeyStroke BEL = KeyStroke . getKeyStroke ( KeyEvent . VK_A , KeyEvent . CTRL_MASK ); KeyStroke k = KeyStroke . getKeyStroke ( ke . getKeyCode (), ke . getModifiers ()); if ( k == BEL ) { System . out . println ( \"Ctrl-A pressed!\" ); Toolkit . getDefaultToolkit (). beep (); } } public void keyReleased ( KeyEvent ke ) { System . out . println ( ke . paramString ()); } public void keyTyped ( KeyEvent ke ) { System . out . println ( ke . paramString ()); } } Listener con varios controles \u00b6 public class DemoKeyEvents2 { public static void main ( String [] args ) { DemoKeyEvents2Frame frame = new DemoKeyEvents2Frame (); frame . setDefaultCloseOperation ( JFrame . EXIT_ON_CLOSE ); frame . setTitle ( \"DemoKeyEvents2\" ); frame . pack (); frame . setVisible ( true ); } } class DemoKeyEvents2Frame extends JFrame implements KeyListener { private JTextField pro ; private JTextField con ; // constructor public DemoKeyEvents2Frame () { // construct and configure components pro = new JTextField ( 10 ); con = new JTextField ( 10 ); // add listeners pro . addKeyListener ( this ); con . addKeyListener ( this ); // arrange components // add components to panels JPanel banner = new JPanel (); banner . add ( new JLabel ( \"WHAT'S YOUR OPINION ON ANCHOIVES?\" )); JPanel proPanel = new JPanel (); proPanel . add ( new JLabel ( \"Pro:\" )); proPanel . add ( pro ); JPanel conPanel = new JPanel (); conPanel . add ( new JLabel ( \"Con:\" )); conPanel . add ( con ); // put panels in a content pane panel JPanel contentPane = new JPanel (); contentPane . setLayout ( new GridLayout ( 3 , 1 )); contentPane . add ( banner ); contentPane . add ( proPanel ); contentPane . add ( conPanel ); // make panel this JFrame's content pane this . setContentPane ( contentPane ); } public void keyPressed ( KeyEvent ke ) {} // do nothing public void keyReleased ( KeyEvent ke ) {} // do nothing public void keyTyped ( KeyEvent ke ) { Object source = ke . getSource (); // check if event occurred on pro component if ( source == pro ) System . out . println ( \"Pro : \" + ke . paramString ()); // check if event occurred on con component else if ( source == con ) System . out . println ( \"Con : \" + ke . paramString ()); } } Listener con clases an\u00f3nimas \u00b6 public class DemoKeyEvents3 { public static void main ( String [] args ) { DemoKeyEvents3Frame frame = new DemoKeyEvents3Frame (); frame . setDefaultCloseOperation ( JFrame . EXIT_ON_CLOSE ); frame . setTitle ( \"DemoKeyEvents3\" ); frame . pack (); frame . setVisible ( true ); } } class DemoKeyEvents3Frame extends JFrame { private JTextField enterField ; // constructor public DemoKeyEvents3Frame () { enterField = new JTextField ( 10 ); enterField . addKeyListener ( new KeyListener () { public void keyPressed ( KeyEvent ke ) { System . out . println ( ke . paramString ()); final KeyStroke BEL = KeyStroke . getKeyStroke ( KeyEvent . VK_A , KeyEvent . CTRL_MASK ); KeyStroke k = KeyStroke . getKeyStroke ( ke . getKeyCode (), ke . getModifiers ()); if ( k == BEL ) { System . out . println ( \"Ctrl-A pressed!\" ); Toolkit . getDefaultToolkit (). beep (); } } public void keyReleased ( KeyEvent ke ) { System . out . println ( ke . paramString ()); } public void keyTyped ( KeyEvent ke ) { System . out . println ( ke . paramString ()); } }); JPanel panel = new JPanel (); panel . add ( new JLabel ( \"Enter some text:\" )); panel . add ( enterField ); panel . setBorder ( BorderFactory . createEmptyBorder ( 10 , 10 , 10 , 10 )); this . setContentPane ( panel ); } } Listener con adaptador \u00b6 No hay que redefinir todos los m\u00e9todos de KeyListener Los m\u00e9todos de KeyAdapter est\u00e1n definidos pero vac\u00edos class DemoKeyEvents4Frame extends JFrame { private JTextField enterField ; // constructor public DemoKeyEvents4Frame () { enterField = new JTextField ( 10 ); enterField . addKeyListener ( new KeyAdapter () { @Override public void keyPressed ( KeyEvent ke ) { System . out . println ( ke . paramString ()); final KeyStroke BEL = KeyStroke . getKeyStroke ( KeyEvent . VK_A , KeyEvent . CTRL_MASK ); KeyStroke k = KeyStroke . getKeyStroke ( ke . getKeyCode (), ke . getModifiers ()); if ( k == BEL ) { System . out . println ( \"Ctrl-A pressed!\" ); Toolkit . getDefaultToolkit (). beep (); } } @Override public void keyReleased ( KeyEvent ke ) { System . out . println ( ke . paramString ()); } @Override public void keyTyped ( KeyEvent ke ) { System . out . println ( ke . paramString ()); } }); JPanel panel = new JPanel (); panel . add ( new JLabel ( \"Enter some text:\" )); panel . add ( enterField ); panel . setBorder ( BorderFactory . createEmptyBorder ( 10 , 10 , 10 , 10 )); this . setContentPane ( panel ); } } Listener con lambdas y dispatch table \u00b6 import java.awt.BorderLayout ; import java.awt.event.KeyAdapter ; import java.awt.event.KeyEvent ; import java.util.HashMap ; import javax.swing.JFrame ; import javax.swing.JTextField ; public class Test { @FunctionalInterface interface KeyAction { public void doAction (); //un s\u00f3lo m\u00e9todo abstracto } public static void main ( String [] args ) { HashMap < Integer , KeyAction > keyDispatcher = new HashMap < Integer , KeyAction > (); //Crear instancias de FunctionalInterface mediante lambdas keyDispatcher . put ( KeyEvent . VK_W , () -> moveUp ()); keyDispatcher . put ( KeyEvent . VK_S , () -> moveDown ()); keyDispatcher . put ( KeyEvent . VK_A , () -> moveLeft ()); keyDispatcher . put ( KeyEvent . VK_D , () -> moveRight ()); // Using a JTextField out of simplicity JTextField field = new JTextField (); field . addKeyListener ( new KeyAdapter () { @Override public void keyPressed ( KeyEvent arg0 ) { try { keyDispatcher . get ( arg0 . getKeyCode ()). doAction (); } catch ( NullPointerException e ) { System . out . println ( \"That button doesn't do anything yet...\" ); } } }); JFrame frame = new JFrame ( \"Listener Frame\" ); frame . setDefaultCloseOperation ( JFrame . EXIT_ON_CLOSE ); frame . add ( field , BorderLayout . NORTH ); frame . pack (); frame . setVisible ( true ); } private static void moveUp () { System . out . println ( \"Moving up\" ); } private static void moveDown () { System . out . println ( \"Moving down\" ); } private static void moveLeft () { System . out . println ( \"Moving left\" ); } private static void moveRight () { System . out . println ( \"Moving right\" ); } } Ejemplo de listener con y sin lambdas \u00b6 import java.awt.* ; import java.awt.event.* ; import javax.swing.* ; /** * This simple Swing program demonstrates how to use Lambda expressions in * action listener. * * @author www.codejava.net */ public class ListenerLambdaExample extends JFrame { private JButton button = new JButton ( \"Click Me!\" ); public ListenerLambdaExample () { super ( \"Listener Lambda Example\" ); getContentPane (). setLayout ( new FlowLayout ()); getContentPane (). add ( button ); // Java 7 - tradicional, sin lambdas button . addActionListener ( new ActionListener () { public void actionPerformed ( ActionEvent evt ) { System . out . println ( \"Handled by anonymous class listener\" ); } }); // Java 8 - con lambdas button . addActionListener ( e -> System . out . println ( \"Handled by Lambda listener\" )); button . addActionListener ( e -> { System . out . println ( \"Handled Lambda listener\" ); }); setDefaultCloseOperation ( JFrame . EXIT_ON_CLOSE ); setSize ( 300 , 100 ); setLocationRelativeTo ( null ); } public static void main ( String [] args ) { SwingUtilities . invokeLater ( new Runnable () { public void run () { new ListenerLambdaExample (). setVisible ( true ); } }); } } Ejercicio \u00b6 Refactorizar DemoKeyEvents2 con adaptador, interfaces funcionales (lambdas) y tabla de dispatch","title":"Listeners"},{"location":"iiss-evp-1/#programacion-asincrona","text":"","title":"Programaci\u00f3n as\u00edncrona"},{"location":"iiss-evp-1/#listeners","text":"","title":"Listeners"},{"location":"iiss-evp-1/#listener-con-un-solo-control","text":"public class DemoKeyEvents { public static void main ( String [] args ) { DemoKeyEventsFrame frame = new DemoKeyEventsFrame (); frame . setDefaultCloseOperation ( JFrame . EXIT_ON_CLOSE ); frame . setTitle ( \"DemoKeyEvents\" ); frame . pack (); frame . setVisible ( true ); } } class DemoKeyEventsFrame extends JFrame implements KeyListener { private JTextField enterField ; public DemoKeyEventsFrame () { enterField = new JTextField ( 10 ); enterField . addKeyListener ( this ); JPanel panel = new JPanel (); panel . add ( new JLabel ( \"Enter some text:\" )); panel . add ( enterField ); panel . setBorder ( BorderFactory . createEmptyBorder ( 10 , 10 , 10 , 10 )); this . setContentPane ( panel ); } public void keyPressed ( KeyEvent ke ) { System . out . println ( ke . paramString ()); final KeyStroke BEL = KeyStroke . getKeyStroke ( KeyEvent . VK_A , KeyEvent . CTRL_MASK ); KeyStroke k = KeyStroke . getKeyStroke ( ke . getKeyCode (), ke . getModifiers ()); if ( k == BEL ) { System . out . println ( \"Ctrl-A pressed!\" ); Toolkit . getDefaultToolkit (). beep (); } } public void keyReleased ( KeyEvent ke ) { System . out . println ( ke . paramString ()); } public void keyTyped ( KeyEvent ke ) { System . out . println ( ke . paramString ()); } }","title":"Listener con un solo control"},{"location":"iiss-evp-1/#listener-con-varios-controles","text":"public class DemoKeyEvents2 { public static void main ( String [] args ) { DemoKeyEvents2Frame frame = new DemoKeyEvents2Frame (); frame . setDefaultCloseOperation ( JFrame . EXIT_ON_CLOSE ); frame . setTitle ( \"DemoKeyEvents2\" ); frame . pack (); frame . setVisible ( true ); } } class DemoKeyEvents2Frame extends JFrame implements KeyListener { private JTextField pro ; private JTextField con ; // constructor public DemoKeyEvents2Frame () { // construct and configure components pro = new JTextField ( 10 ); con = new JTextField ( 10 ); // add listeners pro . addKeyListener ( this ); con . addKeyListener ( this ); // arrange components // add components to panels JPanel banner = new JPanel (); banner . add ( new JLabel ( \"WHAT'S YOUR OPINION ON ANCHOIVES?\" )); JPanel proPanel = new JPanel (); proPanel . add ( new JLabel ( \"Pro:\" )); proPanel . add ( pro ); JPanel conPanel = new JPanel (); conPanel . add ( new JLabel ( \"Con:\" )); conPanel . add ( con ); // put panels in a content pane panel JPanel contentPane = new JPanel (); contentPane . setLayout ( new GridLayout ( 3 , 1 )); contentPane . add ( banner ); contentPane . add ( proPanel ); contentPane . add ( conPanel ); // make panel this JFrame's content pane this . setContentPane ( contentPane ); } public void keyPressed ( KeyEvent ke ) {} // do nothing public void keyReleased ( KeyEvent ke ) {} // do nothing public void keyTyped ( KeyEvent ke ) { Object source = ke . getSource (); // check if event occurred on pro component if ( source == pro ) System . out . println ( \"Pro : \" + ke . paramString ()); // check if event occurred on con component else if ( source == con ) System . out . println ( \"Con : \" + ke . paramString ()); } }","title":"Listener con varios controles"},{"location":"iiss-evp-1/#listener-con-clases-anonimas","text":"public class DemoKeyEvents3 { public static void main ( String [] args ) { DemoKeyEvents3Frame frame = new DemoKeyEvents3Frame (); frame . setDefaultCloseOperation ( JFrame . EXIT_ON_CLOSE ); frame . setTitle ( \"DemoKeyEvents3\" ); frame . pack (); frame . setVisible ( true ); } } class DemoKeyEvents3Frame extends JFrame { private JTextField enterField ; // constructor public DemoKeyEvents3Frame () { enterField = new JTextField ( 10 ); enterField . addKeyListener ( new KeyListener () { public void keyPressed ( KeyEvent ke ) { System . out . println ( ke . paramString ()); final KeyStroke BEL = KeyStroke . getKeyStroke ( KeyEvent . VK_A , KeyEvent . CTRL_MASK ); KeyStroke k = KeyStroke . getKeyStroke ( ke . getKeyCode (), ke . getModifiers ()); if ( k == BEL ) { System . out . println ( \"Ctrl-A pressed!\" ); Toolkit . getDefaultToolkit (). beep (); } } public void keyReleased ( KeyEvent ke ) { System . out . println ( ke . paramString ()); } public void keyTyped ( KeyEvent ke ) { System . out . println ( ke . paramString ()); } }); JPanel panel = new JPanel (); panel . add ( new JLabel ( \"Enter some text:\" )); panel . add ( enterField ); panel . setBorder ( BorderFactory . createEmptyBorder ( 10 , 10 , 10 , 10 )); this . setContentPane ( panel ); } }","title":"Listener con clases an\u00f3nimas"},{"location":"iiss-evp-1/#listener-con-adaptador","text":"No hay que redefinir todos los m\u00e9todos de KeyListener Los m\u00e9todos de KeyAdapter est\u00e1n definidos pero vac\u00edos class DemoKeyEvents4Frame extends JFrame { private JTextField enterField ; // constructor public DemoKeyEvents4Frame () { enterField = new JTextField ( 10 ); enterField . addKeyListener ( new KeyAdapter () { @Override public void keyPressed ( KeyEvent ke ) { System . out . println ( ke . paramString ()); final KeyStroke BEL = KeyStroke . getKeyStroke ( KeyEvent . VK_A , KeyEvent . CTRL_MASK ); KeyStroke k = KeyStroke . getKeyStroke ( ke . getKeyCode (), ke . getModifiers ()); if ( k == BEL ) { System . out . println ( \"Ctrl-A pressed!\" ); Toolkit . getDefaultToolkit (). beep (); } } @Override public void keyReleased ( KeyEvent ke ) { System . out . println ( ke . paramString ()); } @Override public void keyTyped ( KeyEvent ke ) { System . out . println ( ke . paramString ()); } }); JPanel panel = new JPanel (); panel . add ( new JLabel ( \"Enter some text:\" )); panel . add ( enterField ); panel . setBorder ( BorderFactory . createEmptyBorder ( 10 , 10 , 10 , 10 )); this . setContentPane ( panel ); } }","title":"Listener con adaptador"},{"location":"iiss-evp-1/#listener-con-lambdas-y-dispatch-table","text":"import java.awt.BorderLayout ; import java.awt.event.KeyAdapter ; import java.awt.event.KeyEvent ; import java.util.HashMap ; import javax.swing.JFrame ; import javax.swing.JTextField ; public class Test { @FunctionalInterface interface KeyAction { public void doAction (); //un s\u00f3lo m\u00e9todo abstracto } public static void main ( String [] args ) { HashMap < Integer , KeyAction > keyDispatcher = new HashMap < Integer , KeyAction > (); //Crear instancias de FunctionalInterface mediante lambdas keyDispatcher . put ( KeyEvent . VK_W , () -> moveUp ()); keyDispatcher . put ( KeyEvent . VK_S , () -> moveDown ()); keyDispatcher . put ( KeyEvent . VK_A , () -> moveLeft ()); keyDispatcher . put ( KeyEvent . VK_D , () -> moveRight ()); // Using a JTextField out of simplicity JTextField field = new JTextField (); field . addKeyListener ( new KeyAdapter () { @Override public void keyPressed ( KeyEvent arg0 ) { try { keyDispatcher . get ( arg0 . getKeyCode ()). doAction (); } catch ( NullPointerException e ) { System . out . println ( \"That button doesn't do anything yet...\" ); } } }); JFrame frame = new JFrame ( \"Listener Frame\" ); frame . setDefaultCloseOperation ( JFrame . EXIT_ON_CLOSE ); frame . add ( field , BorderLayout . NORTH ); frame . pack (); frame . setVisible ( true ); } private static void moveUp () { System . out . println ( \"Moving up\" ); } private static void moveDown () { System . out . println ( \"Moving down\" ); } private static void moveLeft () { System . out . println ( \"Moving left\" ); } private static void moveRight () { System . out . println ( \"Moving right\" ); } }","title":"Listener con lambdas y dispatch table"},{"location":"iiss-evp-1/#ejemplo-de-listener-con-y-sin-lambdas","text":"import java.awt.* ; import java.awt.event.* ; import javax.swing.* ; /** * This simple Swing program demonstrates how to use Lambda expressions in * action listener. * * @author www.codejava.net */ public class ListenerLambdaExample extends JFrame { private JButton button = new JButton ( \"Click Me!\" ); public ListenerLambdaExample () { super ( \"Listener Lambda Example\" ); getContentPane (). setLayout ( new FlowLayout ()); getContentPane (). add ( button ); // Java 7 - tradicional, sin lambdas button . addActionListener ( new ActionListener () { public void actionPerformed ( ActionEvent evt ) { System . out . println ( \"Handled by anonymous class listener\" ); } }); // Java 8 - con lambdas button . addActionListener ( e -> System . out . println ( \"Handled by Lambda listener\" )); button . addActionListener ( e -> { System . out . println ( \"Handled Lambda listener\" ); }); setDefaultCloseOperation ( JFrame . EXIT_ON_CLOSE ); setSize ( 300 , 100 ); setLocationRelativeTo ( null ); } public static void main ( String [] args ) { SwingUtilities . invokeLater ( new Runnable () { public void run () { new ListenerLambdaExample (). setVisible ( true ); } }); } }","title":"Ejemplo de listener con y sin lambdas"},{"location":"iiss-evp-1/#ejercicio","text":"Refactorizar DemoKeyEvents2 con adaptador, interfaces funcionales (lambdas) y tabla de dispatch","title":"Ejercicio"},{"location":"iiss-evp-2/","text":"EVENTOS AS\u00cdNCRONOS Programaci\u00f3n as\u00edncrona \u00b6 La programaci\u00f3n as\u00edncrona promueve la definici\u00f3n de operaciones no bloqueantes . figura por Javier V\u00e9lez Reyes, Programaci\u00f3n as\u00edncrona en JavaScript Las funciones no bloqueantes afectan a: El estado del programa La l\u00f3gica de continuaci\u00f3n del programa programaci\u00f3n secuencial programaci\u00f3n as\u00edncrona figura por Javier V\u00e9lez Reyes, Programaci\u00f3n as\u00edncrona en JavaScript Modelos de paso de continuaciones \u00b6 Aumentar la aridad de la funci\u00f3n no bloqueante en 1 argumento adicional, donde se indica la l\u00f3gica de continuaci\u00f3n. Callbacks \u00b6 La l\u00f3gica de continuaci\u00f3n se indica mediante una funci\u00f3n de retrollamada o callback . figura por Javier V\u00e9lez Reyes, Programaci\u00f3n as\u00edncrona en JavaScript Ejemplos: implementaciones de listener del ejercicio introductorio Con clases an\u00f3nimas Con adaptadores Con funciones an\u00f3nimas o lambdas Ejemplo: Ajax + jQuery callbacks \u00b6 Ajax jQuery jQuery Callbacks object Ejemplo: callback en Javascript \u00b6 Versi\u00f3n s\u00edncrona : // Versi\u00f3n s\u00edncrona function main () { r1 = serv1 ( \"datos iniciales\" ); r2 = serv2 ( r1 ); // Tambi\u00e9n se podr\u00eda haber escrito r2 = serv2(serv1(\"datos iniciales\")) console . log ( \"Resultado final: { \" + r2 + \" }\" ); } function serv1 ( parametros ) { return \"Tardo en calcular r1 a partir de { \" + parametros + \" }\" ; } function serv2 ( resultado1 ) { return \"Tardo en calcular r2 a partir de { \" + resultado1 + \" }\" ; } Ejemplo con callbacks // Versi\u00f3n as\u00edncrona. // Las funciones asinc1() y asinc2() admiten un callback // como segundo par\u00e1metro, al cual llamar\u00e1n pas\u00e1ndole el resultado del c\u00f3mputo function main () { asinc1 ( \"datos iniciales\" , function ( r1 ){ // Tenemos el resultado de asinc1 asinc2 ( r1 , function ( r2 ) { console . log ( \"Resultado final: { \" + r2 + \" }\" ); }); }); } function asinc1 ( parametros , callback ) { r1 = \"Tardo en calcular r1 a partir de { \" + parametros + \" }\" ; callback ( r1 ); } function asinc2 ( resultado1 , callback ) { r2 = \"Tardo en calcular r2 a partir de { \" + resultado1 + \" }\" ; callback ( r2 ); } Callback Hell : \u00b6 El uso de callbacks hace el c\u00f3digo complejo, repetitivo y dif\u00edcil de entender, especialmente cuando el tama\u00f1o del c\u00f3digo crece. La anidaci\u00f3n empeora si se necesita el resultado de una funci\u00f3n para llamar a otra: funciones que son par\u00e1metros de otras funciones, que son par\u00e1metros de otras, etc. El c\u00f3digo fuente se va indentando m\u00e1s y m\u00e1s para luego ir deshaciendo esa indentaci\u00f3n a medida que se cierran llaves y par\u00e9ntesis. La l\u00f3gica est\u00e1 al rev\u00e9s: las funciones no devuelven resultados, sino que pasan esos resultados como par\u00e1metros a otras funciones; las funciones que manejan la respuesta son tambi\u00e9n pasadas como par\u00e1metros El flujo de gesti\u00f3n de errores tambi\u00e9n se complica y no pueden usarse excepciones . Promesas \u00b6 Modelo de futuros y promesas Futuro : marcador de posici\u00f3n ( placeholder ), de solo lectura, para una variable que representa el resultado de un c\u00f3mputo as\u00edncrono Promesa : contenedor de una asignaci\u00f3n escribible (solo para inicializaci\u00f3n), que fija el valor de un futuro . Los futuros y promesas sirven para desacoplar un valor (el futuro) de c\u00f3mo \u00e9ste se calcul\u00f3 (la promesa), permitiendo as\u00ed la paralelizaci\u00f3n de los c\u00e1lculos. figura por Javier V\u00e9lez Reyes, Programaci\u00f3n as\u00edncrona en JavaScript El cliente recibe como respuesta inmediata una abstracci\u00f3n de datos (la Promise ) que representa un compromiso de valor futuro, con inyectores ( then , catch ) para incluir la l\u00f3gica de continuaci\u00f3n. Las promesas se pueden resolver ( resolve ) o rechazar ( reject ): Se pueden encadenar c\u00e1lculos usando futuros computables o escuchables , que sirven para indicar a un thread que ejecute una determinada tarea y, cuando termine, se dirija a hacer otra tarea usando el resultado de la tarea anterior. Promesas en Javascript \u00b6 const promise = new Promise (( resolve , reject ) => { // las funciones resolve/reject controlan el destino de la promesa }); Ejemplo con promesas : // Versi\u00f3n con promesas // Ahora asinc1 y asinc2 se supone que devuelven una promesa (que solo resuelve) function main () { asinc1 ( \"datos iniciales\" ) . then ( function ( r1 ){ return asinc2 ( r1 ); }) . then ( function ( r2 ){ console . log ( \"Resultado final: \" + r2 ); }). catch ( function ( err ){ console . log ( \"Error: \" + err . message ) }); } // Lo anterior puede escribirse m\u00e1s conciso: function main () { asinc1 ( \"datos iniciales\" ) . then ( asinc2 ) . then ( function ( r2 ){ console . log ( \"Resultado final: \" + r2 ); }). catch ( function ( err ){ console . log ( \"Error: \" + err . message ) }); } function asinc1 ( parametros ) { return new Promise (( resolve , reject ) => { resolve ( \"Tardo en calcular r1 a partir de { \" + parametros + \" }\" ); }); } function asinc2 ( resultado1 ) { return new Promise (( resolve , reject ) => { resolve ( \"Tardo en calcular r2 a partir de { \" + resultado1 + \" }\" ); }); } // Si asinc2 devolviera un error function asinc2 ( resultado1 ) { return new Promise (( resolve , reject ) => { reject ( new Error ( \"Ha habido un error en el c\u00e1lculo de r2 a partir de { \" + resultado1 + \" }\" )); }); } // Salida => \"Error: Ha habido un error en el c\u00e1lculo de r2 a partir de { Tardo en calcular r1 a partir de { datos iniciales } }\" // Si asinc1 devolviera un error function asinc1 ( parametros ) { return new Promise (( resolve , reject ) => { reject ( new Error ( \"Ha habido un error en el c\u00e1lculo de r1 a partir de { \" + parametros + \" }\" )); }); } // Salida => \"Error: Ha habido un error en el c\u00e1lculo de r1 a partir de { datos iniciales }\" Soluci\u00f3n al Callback Hell : Las promesas evitan la anidaci\u00f3n y hacen m\u00e1s simple el manejo de errores. La ventaja de las promesas es que se pueden encadenar . Una promesa tiene un m\u00e9todo then() : .then() recibe una funci\u00f3n, que ser\u00e1 ejecutada autom\u00e1ticamente cuando la promesa se resuelva. Esta funci\u00f3n recibir\u00e1 como par\u00e1metro el valor de la promesa (el resultado esperado). .then() devuelve una nueva promesa, que se resolver\u00e1 cuando se ejecute la funci\u00f3n que le hab\u00edamos asociado. Se pueden encadenar varios .then() para simular un c\u00f3digo secuencial, conforme se van resolviendo promesas. Una promesa tiene un m\u00e9todo catch() : Se puede agregar la gesti\u00f3n de errores de cualquier parte de la cadena de llamadas as\u00edncronas con un solo .catch() .catch() devuelve una promesa nueva, creando una cadena de promesas Cualquier error s\u00edncrono generado en un then o un catch hace que la promesa se rechace, y se llame al catch m\u00e1s apropiado Sintaxis async / await \u00b6 El prefijo await hace que se espere a que se llame a la funci\u00f3n as\u00edncrona antes de continuar con la ejecuci\u00f3n del programa. Esto genera un flujo de ejecuci\u00f3n de la l\u00f3gica del programa m\u00e1s f\u00e1cil de leer y de seguir, pausando la ejecuci\u00f3n hasta que se cumpla la promesa. async / await es az\u00facar sint\u00e1ctico para usar promesas con una nueva sintaxis que las oculta y las hace parecer c\u00f3digo s\u00edncrono: await delante de una llamada a una funci\u00f3n entiende que esa funci\u00f3n retorna una promesa. La ejecuci\u00f3n se pausa y s\u00f3lo se reanuda cuando la promesa haya sido resuelta. Entonces await devuelve como resultado el valor de la promesa. Ejemplo con async/await en Javascript async function main () { r1 = await asinc1 ( \"datos iniciales\" ); r2 = await asinc2 ( r1 ); console . log ( \"Resultado final: { \" + r2 + \" }\" ); } Comparar esta versi\u00f3n as\u00edncrona con la versi\u00f3n s\u00edncrona inicial. Futuros \u00b6 Futuros en Java \u00b6 En Java hay definida una interfaz expl\u00edcita para los futuros: Desde Java 5: java.util.concurrent.Future Desde Java 8, inspirado por los ListenableFuture de Guava: java.util.concurrent.CompletableFuture Ejemplo: Future en Java import java.util.concurrent.* ; public class Main { // Callable<V> = Interfaz funcional que representa a una operaci\u00f3n sin args // y que devuelve un resultado de tipo V (permite checked exceptions) public static class MyCallable implements Callable < Integer > { @Override public Integer call () throws Exception { Thread . sleep ( 1000 ); return 1 ; } } public static void main ( String [] args ) throws Exception { ExecutorService exec = Executors . newSingleThreadExecutor (); Future < Integer > f = exec . submit ( new MyCallable ()); System . out . println ( f . isDone ()); //False System . out . println ( f . get ()); //Waits until the task is done, then prints 1 } } Ejemplo: CompletableFuture en Java import java.util.concurrent.* ; import java.util.function.* ; public class Main { // Supplier<T> = Interfaz funcional que representa a una operaci\u00f3n sin args // y que devuelve un resultado de tipo T (no permite checked exceptions) public static class MySupplier implements Supplier < Integer > { @Override public Integer get () { try { Thread . sleep ( 1000 ); } catch ( InterruptedException e ) { //Do nothing } return 1 ; } } public static class PlusOne implements Function < Integer , Integer > { @Override public Integer apply ( Integer x ) { return x + 1 ; } } public static void main ( String [] args ) throws Exception { ExecutorService exec = Executors . newSingleThreadExecutor (); CompletableFuture < Integer > f = CompletableFuture . supplyAsync ( new MySupplier (), exec ); System . out . println ( f . isDone ()); // False CompletableFuture < Integer > f2 = f . thenApply ( new PlusOne ()); System . out . println ( f2 . get ()); // Waits until the \"calculation\" is done, then prints 2 } }","title":"As\u00edncronas"},{"location":"iiss-evp-2/#programacion-asincrona","text":"La programaci\u00f3n as\u00edncrona promueve la definici\u00f3n de operaciones no bloqueantes . figura por Javier V\u00e9lez Reyes, Programaci\u00f3n as\u00edncrona en JavaScript Las funciones no bloqueantes afectan a: El estado del programa La l\u00f3gica de continuaci\u00f3n del programa programaci\u00f3n secuencial programaci\u00f3n as\u00edncrona figura por Javier V\u00e9lez Reyes, Programaci\u00f3n as\u00edncrona en JavaScript","title":"Programaci\u00f3n as\u00edncrona"},{"location":"iiss-evp-2/#modelos-de-paso-de-continuaciones","text":"Aumentar la aridad de la funci\u00f3n no bloqueante en 1 argumento adicional, donde se indica la l\u00f3gica de continuaci\u00f3n.","title":"Modelos de paso de continuaciones"},{"location":"iiss-evp-2/#callbacks","text":"La l\u00f3gica de continuaci\u00f3n se indica mediante una funci\u00f3n de retrollamada o callback . figura por Javier V\u00e9lez Reyes, Programaci\u00f3n as\u00edncrona en JavaScript Ejemplos: implementaciones de listener del ejercicio introductorio Con clases an\u00f3nimas Con adaptadores Con funciones an\u00f3nimas o lambdas","title":"Callbacks"},{"location":"iiss-evp-2/#ejemplo-ajax-jquery-callbacks","text":"Ajax jQuery jQuery Callbacks object","title":"Ejemplo: Ajax + jQuery callbacks"},{"location":"iiss-evp-2/#ejemplo-callback-en-javascript","text":"Versi\u00f3n s\u00edncrona : // Versi\u00f3n s\u00edncrona function main () { r1 = serv1 ( \"datos iniciales\" ); r2 = serv2 ( r1 ); // Tambi\u00e9n se podr\u00eda haber escrito r2 = serv2(serv1(\"datos iniciales\")) console . log ( \"Resultado final: { \" + r2 + \" }\" ); } function serv1 ( parametros ) { return \"Tardo en calcular r1 a partir de { \" + parametros + \" }\" ; } function serv2 ( resultado1 ) { return \"Tardo en calcular r2 a partir de { \" + resultado1 + \" }\" ; } Ejemplo con callbacks // Versi\u00f3n as\u00edncrona. // Las funciones asinc1() y asinc2() admiten un callback // como segundo par\u00e1metro, al cual llamar\u00e1n pas\u00e1ndole el resultado del c\u00f3mputo function main () { asinc1 ( \"datos iniciales\" , function ( r1 ){ // Tenemos el resultado de asinc1 asinc2 ( r1 , function ( r2 ) { console . log ( \"Resultado final: { \" + r2 + \" }\" ); }); }); } function asinc1 ( parametros , callback ) { r1 = \"Tardo en calcular r1 a partir de { \" + parametros + \" }\" ; callback ( r1 ); } function asinc2 ( resultado1 , callback ) { r2 = \"Tardo en calcular r2 a partir de { \" + resultado1 + \" }\" ; callback ( r2 ); }","title":"Ejemplo: callback en Javascript"},{"location":"iiss-evp-2/#callback-hell","text":"El uso de callbacks hace el c\u00f3digo complejo, repetitivo y dif\u00edcil de entender, especialmente cuando el tama\u00f1o del c\u00f3digo crece. La anidaci\u00f3n empeora si se necesita el resultado de una funci\u00f3n para llamar a otra: funciones que son par\u00e1metros de otras funciones, que son par\u00e1metros de otras, etc. El c\u00f3digo fuente se va indentando m\u00e1s y m\u00e1s para luego ir deshaciendo esa indentaci\u00f3n a medida que se cierran llaves y par\u00e9ntesis. La l\u00f3gica est\u00e1 al rev\u00e9s: las funciones no devuelven resultados, sino que pasan esos resultados como par\u00e1metros a otras funciones; las funciones que manejan la respuesta son tambi\u00e9n pasadas como par\u00e1metros El flujo de gesti\u00f3n de errores tambi\u00e9n se complica y no pueden usarse excepciones .","title":"Callback Hell:"},{"location":"iiss-evp-2/#promesas","text":"Modelo de futuros y promesas Futuro : marcador de posici\u00f3n ( placeholder ), de solo lectura, para una variable que representa el resultado de un c\u00f3mputo as\u00edncrono Promesa : contenedor de una asignaci\u00f3n escribible (solo para inicializaci\u00f3n), que fija el valor de un futuro . Los futuros y promesas sirven para desacoplar un valor (el futuro) de c\u00f3mo \u00e9ste se calcul\u00f3 (la promesa), permitiendo as\u00ed la paralelizaci\u00f3n de los c\u00e1lculos. figura por Javier V\u00e9lez Reyes, Programaci\u00f3n as\u00edncrona en JavaScript El cliente recibe como respuesta inmediata una abstracci\u00f3n de datos (la Promise ) que representa un compromiso de valor futuro, con inyectores ( then , catch ) para incluir la l\u00f3gica de continuaci\u00f3n. Las promesas se pueden resolver ( resolve ) o rechazar ( reject ): Se pueden encadenar c\u00e1lculos usando futuros computables o escuchables , que sirven para indicar a un thread que ejecute una determinada tarea y, cuando termine, se dirija a hacer otra tarea usando el resultado de la tarea anterior.","title":"Promesas"},{"location":"iiss-evp-2/#promesas-en-javascript","text":"const promise = new Promise (( resolve , reject ) => { // las funciones resolve/reject controlan el destino de la promesa }); Ejemplo con promesas : // Versi\u00f3n con promesas // Ahora asinc1 y asinc2 se supone que devuelven una promesa (que solo resuelve) function main () { asinc1 ( \"datos iniciales\" ) . then ( function ( r1 ){ return asinc2 ( r1 ); }) . then ( function ( r2 ){ console . log ( \"Resultado final: \" + r2 ); }). catch ( function ( err ){ console . log ( \"Error: \" + err . message ) }); } // Lo anterior puede escribirse m\u00e1s conciso: function main () { asinc1 ( \"datos iniciales\" ) . then ( asinc2 ) . then ( function ( r2 ){ console . log ( \"Resultado final: \" + r2 ); }). catch ( function ( err ){ console . log ( \"Error: \" + err . message ) }); } function asinc1 ( parametros ) { return new Promise (( resolve , reject ) => { resolve ( \"Tardo en calcular r1 a partir de { \" + parametros + \" }\" ); }); } function asinc2 ( resultado1 ) { return new Promise (( resolve , reject ) => { resolve ( \"Tardo en calcular r2 a partir de { \" + resultado1 + \" }\" ); }); } // Si asinc2 devolviera un error function asinc2 ( resultado1 ) { return new Promise (( resolve , reject ) => { reject ( new Error ( \"Ha habido un error en el c\u00e1lculo de r2 a partir de { \" + resultado1 + \" }\" )); }); } // Salida => \"Error: Ha habido un error en el c\u00e1lculo de r2 a partir de { Tardo en calcular r1 a partir de { datos iniciales } }\" // Si asinc1 devolviera un error function asinc1 ( parametros ) { return new Promise (( resolve , reject ) => { reject ( new Error ( \"Ha habido un error en el c\u00e1lculo de r1 a partir de { \" + parametros + \" }\" )); }); } // Salida => \"Error: Ha habido un error en el c\u00e1lculo de r1 a partir de { datos iniciales }\" Soluci\u00f3n al Callback Hell : Las promesas evitan la anidaci\u00f3n y hacen m\u00e1s simple el manejo de errores. La ventaja de las promesas es que se pueden encadenar . Una promesa tiene un m\u00e9todo then() : .then() recibe una funci\u00f3n, que ser\u00e1 ejecutada autom\u00e1ticamente cuando la promesa se resuelva. Esta funci\u00f3n recibir\u00e1 como par\u00e1metro el valor de la promesa (el resultado esperado). .then() devuelve una nueva promesa, que se resolver\u00e1 cuando se ejecute la funci\u00f3n que le hab\u00edamos asociado. Se pueden encadenar varios .then() para simular un c\u00f3digo secuencial, conforme se van resolviendo promesas. Una promesa tiene un m\u00e9todo catch() : Se puede agregar la gesti\u00f3n de errores de cualquier parte de la cadena de llamadas as\u00edncronas con un solo .catch() .catch() devuelve una promesa nueva, creando una cadena de promesas Cualquier error s\u00edncrono generado en un then o un catch hace que la promesa se rechace, y se llame al catch m\u00e1s apropiado","title":"Promesas en Javascript"},{"location":"iiss-evp-2/#sintaxis-asyncawait","text":"El prefijo await hace que se espere a que se llame a la funci\u00f3n as\u00edncrona antes de continuar con la ejecuci\u00f3n del programa. Esto genera un flujo de ejecuci\u00f3n de la l\u00f3gica del programa m\u00e1s f\u00e1cil de leer y de seguir, pausando la ejecuci\u00f3n hasta que se cumpla la promesa. async / await es az\u00facar sint\u00e1ctico para usar promesas con una nueva sintaxis que las oculta y las hace parecer c\u00f3digo s\u00edncrono: await delante de una llamada a una funci\u00f3n entiende que esa funci\u00f3n retorna una promesa. La ejecuci\u00f3n se pausa y s\u00f3lo se reanuda cuando la promesa haya sido resuelta. Entonces await devuelve como resultado el valor de la promesa. Ejemplo con async/await en Javascript async function main () { r1 = await asinc1 ( \"datos iniciales\" ); r2 = await asinc2 ( r1 ); console . log ( \"Resultado final: { \" + r2 + \" }\" ); } Comparar esta versi\u00f3n as\u00edncrona con la versi\u00f3n s\u00edncrona inicial.","title":"Sintaxis async/await"},{"location":"iiss-evp-2/#futuros","text":"","title":"Futuros"},{"location":"iiss-evp-2/#futuros-en-java","text":"En Java hay definida una interfaz expl\u00edcita para los futuros: Desde Java 5: java.util.concurrent.Future Desde Java 8, inspirado por los ListenableFuture de Guava: java.util.concurrent.CompletableFuture Ejemplo: Future en Java import java.util.concurrent.* ; public class Main { // Callable<V> = Interfaz funcional que representa a una operaci\u00f3n sin args // y que devuelve un resultado de tipo V (permite checked exceptions) public static class MyCallable implements Callable < Integer > { @Override public Integer call () throws Exception { Thread . sleep ( 1000 ); return 1 ; } } public static void main ( String [] args ) throws Exception { ExecutorService exec = Executors . newSingleThreadExecutor (); Future < Integer > f = exec . submit ( new MyCallable ()); System . out . println ( f . isDone ()); //False System . out . println ( f . get ()); //Waits until the task is done, then prints 1 } } Ejemplo: CompletableFuture en Java import java.util.concurrent.* ; import java.util.function.* ; public class Main { // Supplier<T> = Interfaz funcional que representa a una operaci\u00f3n sin args // y que devuelve un resultado de tipo T (no permite checked exceptions) public static class MySupplier implements Supplier < Integer > { @Override public Integer get () { try { Thread . sleep ( 1000 ); } catch ( InterruptedException e ) { //Do nothing } return 1 ; } } public static class PlusOne implements Function < Integer , Integer > { @Override public Integer apply ( Integer x ) { return x + 1 ; } } public static void main ( String [] args ) throws Exception { ExecutorService exec = Executors . newSingleThreadExecutor (); CompletableFuture < Integer > f = CompletableFuture . supplyAsync ( new MySupplier (), exec ); System . out . println ( f . isDone ()); // False CompletableFuture < Integer > f2 = f . thenApply ( new PlusOne ()); System . out . println ( f2 . get ()); // Waits until the \"calculation\" is done, then prints 2 } }","title":"Futuros en Java"},{"location":"iiss-evp-3/","text":"EVENTOS AS\u00cdNCRONOS Programaci\u00f3n as\u00edncrona \u00b6 Eventos \u00b6 Las operaciones disparan eventos de diferentes tipos, que son escuchados por los manejadores ( listeners ) de eventos, que los clientes han registrado en un bus de eventos. figura por Javier V\u00e9lez Reyes, Programaci\u00f3n as\u00edncrona en JavaScript Ventajas : Aplicaciones m\u00e1s interactivas Mejor uso de los recursos Estrategias : Estrategias para escribir aplicaciones basadas en eventos: M\u00e1quinas de estados finitos (FSM) Implementaciones del patr\u00f3n Observer Sistemas de Publicaci\u00f3n/suscripci\u00f3n (PubSub) Streams y programaci\u00f3n reactiva M\u00e1quinas de estados \u00b6 Una FSM es una especificaci\u00f3n de c\u00f3mo manejar eventos. Lista de estados + estado actual Para cada estado, transiciones a otros estados significativos Las transiciones vienen definidas por eventos Cada transici\u00f3n delimita una acci\u00f3n con la respuesta a cada evento Patr\u00f3n Observer \u00b6 Observable : fuente de eventos Observadores : lista de clientes interesados en los eventos Los observadores se registran ellos mismos en cada observable \\Rightarrow \\Rightarrow produce acoplamiento. Las acciones de callback son gestionadas por los observables, que suele mantener una lista interna de observadores \\Rightarrow \\Rightarrow produce cuellos de botella. PubSub \u00b6 Los sistemas de PubSub son Observers generalizados. Los publicadores y los suscriptores se conectan por canales Suelen implementarse en bibliotecas aparte de mensajer\u00eda o Message Queues (MQ) Cada canal tiene un nombre, empleado por publicadores y sucriptores para desacoplarse entre s\u00ed La comunicaci\u00f3n puede hacerse as\u00edncrona Ejemplos de bibliotecas de PubSub/MQ: RabbitMQ ZeroMQ NATS Apache ActiveMQ etc. Protocolos de MQ: AMQP MQTT STOMP etc. \u00bfC\u00f3mo crear sistemas que respondan a combinaciones de eventos? Hay que a\u00f1adir la dimensi\u00f3n del tiempo al procesamiento de los eventos Los eventos deben disparar reacciones en el c\u00f3digo, pero no es f\u00e1cil conectar las acciones con los eventos. Para facilitarlo, se usan streams ... Streams y Rx \u00b6 Los datos fluyen por pipelines y se consumen siguiendo modelos push o pull figura por Javier V\u00e9lez Reyes, Programaci\u00f3n as\u00edncrona en JavaScript Un stream trata a los eventos como colleciones de datos, de forma que pueden ser tratados como cualquier otra colecci\u00f3n: manipularlos, combinarlos, filtrarlos, etc. Adem\u00e1s, los streams pueden ser as\u00edncronos. Programaci\u00f3n reactiva (Rx) Es un paradigma, parte de la programaci\u00f3n as\u00edncrona: la disponibilidad de informaci\u00f3n nueva conduce la l\u00f3gica del programa, en vez de dejar que el control de flujo sea dirigido por un hilo de ejecuci\u00f3n. Modelo de Observables : tratar a los streams de eventos as\u00edncronos con las mismas operaciones sencillas de composici\u00f3n que se usan para las colecciones de datos. Bibliotecas de programaci\u00f3n Rx: reactivex.io Principios Observables Los Observables se pueden: Crear: Create , Defer , From , Interval , Just , Range , Repeat , Start , Timer Transformar: Buffer , FlatMap , GroupBy , Map , Scan , Window Filtrar: Debounce , Distinct , ElementAt , Filter , IgnoreElements , Last , Sample , Skip , SkipLast , Take , TakeLast Combinar: And / Then / When , CombineLatest , Join , Merge , StartWith , Switch , Zip Etc... Operadores Rx LECTURA recomendada: The introduction to Reactive Programming you've been missing (by @andrestaltz) \u00bfQu\u00e9 a\u00f1ade un Observable al patr\u00f3n Observer? A\u00f1ade a un Observer as\u00edncrono la sem\u00e1ntica de un Iterable s\u00edncrono: onCompleted() : para que el publicador avise al suscriptor que no hay m\u00e1s datos disponibles en el stream (los Iterables simplemente acaban su iteraci\u00f3n) onError() : para que el productor avise al suscriptor que ha ocurrido un error (en su lugar, los Iterables elevan excepciones) Ejemplos de frameworks de streaming: Apache Kafka NATS Streaming Spark Streaming Amazon Kinesis Apache Pulsar Lectura recomendada Thomas & Hunt. The Pragmatic Programmer, 2 nd edition , 2022. Cap\u00edtulo: Transforming Programming","title":"Eventos"},{"location":"iiss-evp-3/#programacion-asincrona","text":"","title":"Programaci\u00f3n as\u00edncrona"},{"location":"iiss-evp-3/#eventos","text":"Las operaciones disparan eventos de diferentes tipos, que son escuchados por los manejadores ( listeners ) de eventos, que los clientes han registrado en un bus de eventos. figura por Javier V\u00e9lez Reyes, Programaci\u00f3n as\u00edncrona en JavaScript Ventajas : Aplicaciones m\u00e1s interactivas Mejor uso de los recursos Estrategias : Estrategias para escribir aplicaciones basadas en eventos: M\u00e1quinas de estados finitos (FSM) Implementaciones del patr\u00f3n Observer Sistemas de Publicaci\u00f3n/suscripci\u00f3n (PubSub) Streams y programaci\u00f3n reactiva","title":"Eventos"},{"location":"iiss-evp-3/#maquinas-de-estados","text":"Una FSM es una especificaci\u00f3n de c\u00f3mo manejar eventos. Lista de estados + estado actual Para cada estado, transiciones a otros estados significativos Las transiciones vienen definidas por eventos Cada transici\u00f3n delimita una acci\u00f3n con la respuesta a cada evento","title":"M\u00e1quinas de estados"},{"location":"iiss-evp-3/#patron-observer","text":"Observable : fuente de eventos Observadores : lista de clientes interesados en los eventos Los observadores se registran ellos mismos en cada observable \\Rightarrow \\Rightarrow produce acoplamiento. Las acciones de callback son gestionadas por los observables, que suele mantener una lista interna de observadores \\Rightarrow \\Rightarrow produce cuellos de botella.","title":"Patr\u00f3n Observer"},{"location":"iiss-evp-3/#pubsub","text":"Los sistemas de PubSub son Observers generalizados. Los publicadores y los suscriptores se conectan por canales Suelen implementarse en bibliotecas aparte de mensajer\u00eda o Message Queues (MQ) Cada canal tiene un nombre, empleado por publicadores y sucriptores para desacoplarse entre s\u00ed La comunicaci\u00f3n puede hacerse as\u00edncrona Ejemplos de bibliotecas de PubSub/MQ: RabbitMQ ZeroMQ NATS Apache ActiveMQ etc. Protocolos de MQ: AMQP MQTT STOMP etc. \u00bfC\u00f3mo crear sistemas que respondan a combinaciones de eventos? Hay que a\u00f1adir la dimensi\u00f3n del tiempo al procesamiento de los eventos Los eventos deben disparar reacciones en el c\u00f3digo, pero no es f\u00e1cil conectar las acciones con los eventos. Para facilitarlo, se usan streams ...","title":"PubSub"},{"location":"iiss-evp-3/#streams-y-rx","text":"Los datos fluyen por pipelines y se consumen siguiendo modelos push o pull figura por Javier V\u00e9lez Reyes, Programaci\u00f3n as\u00edncrona en JavaScript Un stream trata a los eventos como colleciones de datos, de forma que pueden ser tratados como cualquier otra colecci\u00f3n: manipularlos, combinarlos, filtrarlos, etc. Adem\u00e1s, los streams pueden ser as\u00edncronos. Programaci\u00f3n reactiva (Rx) Es un paradigma, parte de la programaci\u00f3n as\u00edncrona: la disponibilidad de informaci\u00f3n nueva conduce la l\u00f3gica del programa, en vez de dejar que el control de flujo sea dirigido por un hilo de ejecuci\u00f3n. Modelo de Observables : tratar a los streams de eventos as\u00edncronos con las mismas operaciones sencillas de composici\u00f3n que se usan para las colecciones de datos. Bibliotecas de programaci\u00f3n Rx: reactivex.io Principios Observables Los Observables se pueden: Crear: Create , Defer , From , Interval , Just , Range , Repeat , Start , Timer Transformar: Buffer , FlatMap , GroupBy , Map , Scan , Window Filtrar: Debounce , Distinct , ElementAt , Filter , IgnoreElements , Last , Sample , Skip , SkipLast , Take , TakeLast Combinar: And / Then / When , CombineLatest , Join , Merge , StartWith , Switch , Zip Etc... Operadores Rx LECTURA recomendada: The introduction to Reactive Programming you've been missing (by @andrestaltz) \u00bfQu\u00e9 a\u00f1ade un Observable al patr\u00f3n Observer? A\u00f1ade a un Observer as\u00edncrono la sem\u00e1ntica de un Iterable s\u00edncrono: onCompleted() : para que el publicador avise al suscriptor que no hay m\u00e1s datos disponibles en el stream (los Iterables simplemente acaban su iteraci\u00f3n) onError() : para que el productor avise al suscriptor que ha ocurrido un error (en su lugar, los Iterables elevan excepciones) Ejemplos de frameworks de streaming: Apache Kafka NATS Streaming Spark Streaming Amazon Kinesis Apache Pulsar Lectura recomendada Thomas & Hunt. The Pragmatic Programmer, 2 nd edition , 2022. Cap\u00edtulo: Transforming Programming","title":"Streams y Rx"},{"location":"iiss-fp-1/","text":"FUNCIONES Programaci\u00f3n funcional \u00b6 Interfaces funcionales \u00b6 Ejemplo: Comparaci\u00f3n de personas - versi\u00f3n con herencia \u00b6 Ordenaci\u00f3n de una lista de nombres de personas: List < String > nombres = Arrays . asList ( \"Melchor\" , \"Gaspar\" , \"Baltasar\" ); Collections . sort ( nombres ); \u00bfC\u00f3mo anticipar en la implementaci\u00f3n la posible variabilidad del criterio de ordenaci\u00f3n? Definir una clase para las personas Factorizar la funci\u00f3n de comparaci\u00f3n: delegar en compareTo(other) Aprovechamos que el String del nombre ya implementa la interfaz Comparable Delegando hacia las subclases: class Persona implements Comparable { private int idPersona ; private String nombre ; private java . util . Date fechaNacimiento ; public Persona () { } public Persona ( int idPersona , String nombre ) { this . idPersona = idPersona ; this . nombre = nombre ; } public int getIdPersona () { return idPersona ; } public void setIdPersona ( int idPersona ) { this . idPersona = idPersona ; } public String getNombre () { return nombre ; } public void setNombre ( String nombre ) { this . nombre = nombre ; } public java . util . Date getFechaNacimiento () { return fechaNacimiento ; } public void setFechaNacimiento ( java . util . Date fechaNacimiento ) { this . fechaNacimiento = fechaNacimiento ; } @Override public String toString () { return String . format ( \"ID=%1s, Nombre:%2s\" , idPersona , nombre ); } @Override public int compareTo ( Persona otra ) { return nombre . compareTo ( otra . getNombre ()); } } Construir y ordenar una colecci\u00f3n de personas: List < Persona > personas = new ArrayList < Persona > (); personas . add ( new Persona ( 1 , \"Melchor\" )); personas . add ( new Persona ( 2 , \"Gaspar\" )); personas . add ( new Persona ( 3 , \"Baltasar\" )); Collections . sort ( personas ); \u00bfY si deseamos ordenar por fecha? Alternativa 1: definir subclases PersonaPorNombre , PersonaPorFechaNacimiento ... Mucho c\u00f3digo repetido (no cumple DRY) Muchos cambios si se a\u00f1ade un nuevo criterio (no cumple OCP) Alternativa 2: No usar herencia, sino composici\u00f3n (no delegar hacia las subclases) Ejemplo: Comparaci\u00f3n de personas - versi\u00f3n con composici\u00f3n \u00b6 Sin usar herencia: class OrdenarPersonaPorId implements java . util . Comparator < Persona > { public int compare ( Persona o1 , Persona o2 ) { return o1 . getIdPersona () - o2 . getIdPersona (); } } Collections . sort ( personas , new OrdenarPersonaPorId ()); Factorizar la funci\u00f3n de comparaci\u00f3n No delegar hacia las subclases Delegar en objeto de otra clase que implemente la interfaz java.util.Comparator \u00bfVentajas? La funci\u00f3n factorizada (por ejemplo, la implementaci\u00f3n de Comparator ) es sustituible en tiempo de ejecuci\u00f3n mediante inyecci\u00f3n de dependencias Ejemplo: Comparaci\u00f3n de personas - versi\u00f3n con clases an\u00f3nimas \u00b6 Collections . sort ( personas , new java . util . Comparator < Persona > () { public int compare ( Persona o1 , Persona o2 ) { return o1 . getIdPersona () - o2 . getIdPersona (); } } ); Clases locales o internas \u00b6 Clases locales ( inner classes ): declaradas dentro de m\u00e9todos Las clases locales pueden hacer referencia a identificadores declarados en la clase y a variables de solo lectura ( final ) del m\u00e9todo en que se declaran public class EnclosingClass { public class InnerClass { public int incrementAndReturnCounter () { return counter ++ ; } } private int counter ; { counter = 0 ; } public int getCounter () { return counter ; } public static void main ( String [] args ) { EnclosingClass enclosingClassInstance = new EnclosingClass (); EnclosingClass . InnerClass innerClassInstance = enclosingClassInstance . new InnerClass (); for ( int i = enclosingClassInstance . getCounter (); ( i = innerClassInstance . incrementAndReturnCounter ()) < 10 ; ) { System . out . println ( i ); } } } Predicados \u00b6 En Java 8, inspirado por la biblioteca guava , se incluyen predicados como una forma de interfaz funcional. En la biblioteca Guava, los Iterators tienen un m\u00e9todo filter que recibe un objeto de tipo Predicate . Desde Java 8 existe una clase similar Predicate . Ejemplo: partidos de una competici\u00f3n \u00b6 Con clases an\u00f3nimas: final Predicate < Match > condition = new Predicate < Match > () { final Team team1 = new Team ( \"Cadiz CF\" ); final Team team2 = new Team ( \"RC Betis\" ); public boolean apply ( Match match ) { return ( match . getLocalTeam (). equals ( team1 ) && match . getVisitingTeam (). equals ( team2 ) ); } }; Iterator matchesByTeam = Iterators . filter ( matches , condition ); for ( matches : matchesByTeam ) { ... }; Sin clases an\u00f3nimas: class FilterByTeam implements Predicate < Match > { Team localTeam , visitingTeam ; public FilterByTeam ( Team t1 , Team t2 ) { this . localTeam = t1 ; this . visitingTeam = t2 ; } public boolean apply ( Match match ) { return match . getLocalTeam (). equals ( t1 ) || match . getVisitingTeam (). equals ( t2 ); } } Comprobar que, en un cierto grupo de la competici\u00f3n, un mismo partido no est\u00e1 repetido ni se enfrenta un equipo contra s\u00ed mismo: Guava y Java 8 Guava emplea FluentIterable para poder encadenar varios Iterable sin que haya problemas con el retorno de null en la programaci\u00f3n fluent . La biblioteca est\u00e1ndar de Java 8 sustituye la soluci\u00f3n del FluentIterable por los Predicate o por el uso de StreamSupport para resolver dicho problema. Lectura recomendada: From Guava's FluentIterable via StreamSupport to Java 8 Streams private void checkMatchesInGroup ( List < Match > matchesInGroup ) { for ( Match match : matchesInGroup ) { Team t1 = match . getLocalTeam (); Team t2 = match . getVisitingTeam (); assertNotSame ( t1 , t2 ); List < Match > firstLeg = FluentIterable . from ( matchesInGroup ) . filter ( new FilterByTeam ( t1 , t2 )) . toImmutableList (); assertTrue ( firstLeg . size () == 1 ); List < Match > secondLeg = FluentIterable . from ( matchesInGroup ) . filter ( new FilterByTeam ( t2 , t1 )) . toImmutableList (); assertTrue ( secondLeg . size () == 0 ); } } Clases an\u00f3nimas interiores \u00b6 Son clases locales ( inner classes ) declaradas sin nombre; sirven para clases que solo aparecen una vez en la aplicaci\u00f3n Java 7 class CalculationWindow extends JFrame { private volatile int result ; public void calculateInSeparateThread ( final URI uri ) { new Thread ( new Runnable () { void run () { calculate ( uri ); result = result + 10 ; } } ). start (); } } Java 8 class CalculationWindow extends JFrame { private volatile int result ; public void calculateInSeparateThread ( final URI uri ) { // code () -> { /* code */ } is a closure new Thread (() -> { calculate ( uri ); result = result + 10 ; }). start (); } } Retrollamadas ( callbacks ) \u00b6 Un callback o retrollamada es un fragmento de c\u00f3digo ejecutable que se pasa como argumento. Implementaciones en C/C++ \u00b6 Puntero a funci\u00f3n: int ( * f )( void ) Con puntero asociado a datos: void ( * f )( void * data ) functor en C++ clase que define operator() es una clase y por tanto pueden contener un estado Ejemplo de puntero a funci\u00f3n \u00b6 /* The calling function takes a single callback as a parameter. */ void PrintTwoNumbers ( int ( * numberSource )( void )) { printf ( \"%d and %d \\n \" , numberSource (), numberSource ()); } /* Possible callbacks */ int overNineThousand ( void ) { return ( rand () % 1000 ) + 9001 ; } int meaningOfLife ( void ) { return 42 ; } int main ( void ) { PrintTwoNumbers ( & rand ); PrintTwoNumbers ( & overNineThousand ); PrintTwoNumbers ( & meaningOfLife ); return 0 ; } Ejemplo de puntero a datos \u00b6 /* Type of function used for the callback */ typedef void ( * event_cb_t )( const struct event * evt , void * userdata ); /* Define a function to register a callback */ int event_cb_register ( event_cb_t cb , void * userdata ); / * Register the callback */ static void my_event_cb ( const struct event * evt , void * data ) { /* do stuff and things with the event */ } event_cb_register ( my_event_cb , & my_custom_data ); /* struct to store the callback in the event dispatcher */ struct event_cb { event_cb_t cb ; void * data ; }; /* Execute the callback */ struct event_cb * callback ; ... callback -> cb ( event , callback -> data ); Ejemplo de functor \u00b6 // this is a functor struct add_x { add_x ( int x ) : x ( x ) {} int operator ()( int y ) { return x + y ; } private : int x ; }; add_x add42 ( 42 ); // create an instance of the functor class int i = add42 ( 8 ); // and \"call\" it assert ( i == 50 ); // and it added 42 to its argument std :: vector < int > in ; // assume this contains a bunch of values std :: vector < int > out ; // Pass a functor to std::transform, which calls the functor on every element // in the input sequence, and stores the result to the output sequence std :: transform ( in . begin (), in . end (), out . begin (), add_x ( 1 )); assert ( out [ i ] == in [ i ] + 1 ); // for all i Functor vs function pointer \u00b6 //Functor struct add_x { add_x ( int y ) : x ( y ){} int operator ()( int y ) { return x + y ; } private : int x ; }; //Function pointer int ( func )( int x ) { return ++ x ; } std :: vector < int > vec (); //fill vec with 1 2 3 4 5 int ( * f )( int ) = func ; // function pointer initialization std :: transform ( vec . begin (), vec . end (), f ); // pass function pointer std :: transform ( vec . begin (), vec . end (), add_x ( 1 )); // pass functor","title":"Interfaces funcionales"},{"location":"iiss-fp-1/#programacion-funcional","text":"","title":"Programaci\u00f3n funcional"},{"location":"iiss-fp-1/#interfaces-funcionales","text":"","title":"Interfaces funcionales"},{"location":"iiss-fp-1/#ejemplo-comparacion-de-personas-version-con-herencia","text":"Ordenaci\u00f3n de una lista de nombres de personas: List < String > nombres = Arrays . asList ( \"Melchor\" , \"Gaspar\" , \"Baltasar\" ); Collections . sort ( nombres ); \u00bfC\u00f3mo anticipar en la implementaci\u00f3n la posible variabilidad del criterio de ordenaci\u00f3n? Definir una clase para las personas Factorizar la funci\u00f3n de comparaci\u00f3n: delegar en compareTo(other) Aprovechamos que el String del nombre ya implementa la interfaz Comparable Delegando hacia las subclases: class Persona implements Comparable { private int idPersona ; private String nombre ; private java . util . Date fechaNacimiento ; public Persona () { } public Persona ( int idPersona , String nombre ) { this . idPersona = idPersona ; this . nombre = nombre ; } public int getIdPersona () { return idPersona ; } public void setIdPersona ( int idPersona ) { this . idPersona = idPersona ; } public String getNombre () { return nombre ; } public void setNombre ( String nombre ) { this . nombre = nombre ; } public java . util . Date getFechaNacimiento () { return fechaNacimiento ; } public void setFechaNacimiento ( java . util . Date fechaNacimiento ) { this . fechaNacimiento = fechaNacimiento ; } @Override public String toString () { return String . format ( \"ID=%1s, Nombre:%2s\" , idPersona , nombre ); } @Override public int compareTo ( Persona otra ) { return nombre . compareTo ( otra . getNombre ()); } } Construir y ordenar una colecci\u00f3n de personas: List < Persona > personas = new ArrayList < Persona > (); personas . add ( new Persona ( 1 , \"Melchor\" )); personas . add ( new Persona ( 2 , \"Gaspar\" )); personas . add ( new Persona ( 3 , \"Baltasar\" )); Collections . sort ( personas ); \u00bfY si deseamos ordenar por fecha? Alternativa 1: definir subclases PersonaPorNombre , PersonaPorFechaNacimiento ... Mucho c\u00f3digo repetido (no cumple DRY) Muchos cambios si se a\u00f1ade un nuevo criterio (no cumple OCP) Alternativa 2: No usar herencia, sino composici\u00f3n (no delegar hacia las subclases)","title":"Ejemplo: Comparaci\u00f3n de personas - versi\u00f3n con herencia"},{"location":"iiss-fp-1/#ejemplo-comparacion-de-personas-version-con-composicion","text":"Sin usar herencia: class OrdenarPersonaPorId implements java . util . Comparator < Persona > { public int compare ( Persona o1 , Persona o2 ) { return o1 . getIdPersona () - o2 . getIdPersona (); } } Collections . sort ( personas , new OrdenarPersonaPorId ()); Factorizar la funci\u00f3n de comparaci\u00f3n No delegar hacia las subclases Delegar en objeto de otra clase que implemente la interfaz java.util.Comparator \u00bfVentajas? La funci\u00f3n factorizada (por ejemplo, la implementaci\u00f3n de Comparator ) es sustituible en tiempo de ejecuci\u00f3n mediante inyecci\u00f3n de dependencias","title":"Ejemplo: Comparaci\u00f3n de personas - versi\u00f3n con composici\u00f3n"},{"location":"iiss-fp-1/#ejemplo-comparacion-de-personas-version-con-clases-anonimas","text":"Collections . sort ( personas , new java . util . Comparator < Persona > () { public int compare ( Persona o1 , Persona o2 ) { return o1 . getIdPersona () - o2 . getIdPersona (); } } );","title":"Ejemplo: Comparaci\u00f3n de personas - versi\u00f3n con clases an\u00f3nimas"},{"location":"iiss-fp-1/#clases-locales-o-internas","text":"Clases locales ( inner classes ): declaradas dentro de m\u00e9todos Las clases locales pueden hacer referencia a identificadores declarados en la clase y a variables de solo lectura ( final ) del m\u00e9todo en que se declaran public class EnclosingClass { public class InnerClass { public int incrementAndReturnCounter () { return counter ++ ; } } private int counter ; { counter = 0 ; } public int getCounter () { return counter ; } public static void main ( String [] args ) { EnclosingClass enclosingClassInstance = new EnclosingClass (); EnclosingClass . InnerClass innerClassInstance = enclosingClassInstance . new InnerClass (); for ( int i = enclosingClassInstance . getCounter (); ( i = innerClassInstance . incrementAndReturnCounter ()) < 10 ; ) { System . out . println ( i ); } } }","title":"Clases locales o internas"},{"location":"iiss-fp-1/#predicados","text":"En Java 8, inspirado por la biblioteca guava , se incluyen predicados como una forma de interfaz funcional. En la biblioteca Guava, los Iterators tienen un m\u00e9todo filter que recibe un objeto de tipo Predicate . Desde Java 8 existe una clase similar Predicate .","title":"Predicados"},{"location":"iiss-fp-1/#ejemplo-partidos-de-una-competicion","text":"Con clases an\u00f3nimas: final Predicate < Match > condition = new Predicate < Match > () { final Team team1 = new Team ( \"Cadiz CF\" ); final Team team2 = new Team ( \"RC Betis\" ); public boolean apply ( Match match ) { return ( match . getLocalTeam (). equals ( team1 ) && match . getVisitingTeam (). equals ( team2 ) ); } }; Iterator matchesByTeam = Iterators . filter ( matches , condition ); for ( matches : matchesByTeam ) { ... }; Sin clases an\u00f3nimas: class FilterByTeam implements Predicate < Match > { Team localTeam , visitingTeam ; public FilterByTeam ( Team t1 , Team t2 ) { this . localTeam = t1 ; this . visitingTeam = t2 ; } public boolean apply ( Match match ) { return match . getLocalTeam (). equals ( t1 ) || match . getVisitingTeam (). equals ( t2 ); } } Comprobar que, en un cierto grupo de la competici\u00f3n, un mismo partido no est\u00e1 repetido ni se enfrenta un equipo contra s\u00ed mismo: Guava y Java 8 Guava emplea FluentIterable para poder encadenar varios Iterable sin que haya problemas con el retorno de null en la programaci\u00f3n fluent . La biblioteca est\u00e1ndar de Java 8 sustituye la soluci\u00f3n del FluentIterable por los Predicate o por el uso de StreamSupport para resolver dicho problema. Lectura recomendada: From Guava's FluentIterable via StreamSupport to Java 8 Streams private void checkMatchesInGroup ( List < Match > matchesInGroup ) { for ( Match match : matchesInGroup ) { Team t1 = match . getLocalTeam (); Team t2 = match . getVisitingTeam (); assertNotSame ( t1 , t2 ); List < Match > firstLeg = FluentIterable . from ( matchesInGroup ) . filter ( new FilterByTeam ( t1 , t2 )) . toImmutableList (); assertTrue ( firstLeg . size () == 1 ); List < Match > secondLeg = FluentIterable . from ( matchesInGroup ) . filter ( new FilterByTeam ( t2 , t1 )) . toImmutableList (); assertTrue ( secondLeg . size () == 0 ); } }","title":"Ejemplo: partidos de una competici\u00f3n"},{"location":"iiss-fp-1/#clases-anonimas-interiores","text":"Son clases locales ( inner classes ) declaradas sin nombre; sirven para clases que solo aparecen una vez en la aplicaci\u00f3n Java 7 class CalculationWindow extends JFrame { private volatile int result ; public void calculateInSeparateThread ( final URI uri ) { new Thread ( new Runnable () { void run () { calculate ( uri ); result = result + 10 ; } } ). start (); } } Java 8 class CalculationWindow extends JFrame { private volatile int result ; public void calculateInSeparateThread ( final URI uri ) { // code () -> { /* code */ } is a closure new Thread (() -> { calculate ( uri ); result = result + 10 ; }). start (); } }","title":"Clases an\u00f3nimas interiores"},{"location":"iiss-fp-1/#retrollamadas-callbacks","text":"Un callback o retrollamada es un fragmento de c\u00f3digo ejecutable que se pasa como argumento.","title":"Retrollamadas (callbacks)"},{"location":"iiss-fp-1/#implementaciones-en-cc","text":"Puntero a funci\u00f3n: int ( * f )( void ) Con puntero asociado a datos: void ( * f )( void * data ) functor en C++ clase que define operator() es una clase y por tanto pueden contener un estado","title":"Implementaciones en C/C++"},{"location":"iiss-fp-1/#ejemplo-de-puntero-a-funcion","text":"/* The calling function takes a single callback as a parameter. */ void PrintTwoNumbers ( int ( * numberSource )( void )) { printf ( \"%d and %d \\n \" , numberSource (), numberSource ()); } /* Possible callbacks */ int overNineThousand ( void ) { return ( rand () % 1000 ) + 9001 ; } int meaningOfLife ( void ) { return 42 ; } int main ( void ) { PrintTwoNumbers ( & rand ); PrintTwoNumbers ( & overNineThousand ); PrintTwoNumbers ( & meaningOfLife ); return 0 ; }","title":"Ejemplo de puntero a funci\u00f3n"},{"location":"iiss-fp-1/#ejemplo-de-puntero-a-datos","text":"/* Type of function used for the callback */ typedef void ( * event_cb_t )( const struct event * evt , void * userdata ); /* Define a function to register a callback */ int event_cb_register ( event_cb_t cb , void * userdata ); / * Register the callback */ static void my_event_cb ( const struct event * evt , void * data ) { /* do stuff and things with the event */ } event_cb_register ( my_event_cb , & my_custom_data ); /* struct to store the callback in the event dispatcher */ struct event_cb { event_cb_t cb ; void * data ; }; /* Execute the callback */ struct event_cb * callback ; ... callback -> cb ( event , callback -> data );","title":"Ejemplo de puntero a datos"},{"location":"iiss-fp-1/#ejemplo-de-functor","text":"// this is a functor struct add_x { add_x ( int x ) : x ( x ) {} int operator ()( int y ) { return x + y ; } private : int x ; }; add_x add42 ( 42 ); // create an instance of the functor class int i = add42 ( 8 ); // and \"call\" it assert ( i == 50 ); // and it added 42 to its argument std :: vector < int > in ; // assume this contains a bunch of values std :: vector < int > out ; // Pass a functor to std::transform, which calls the functor on every element // in the input sequence, and stores the result to the output sequence std :: transform ( in . begin (), in . end (), out . begin (), add_x ( 1 )); assert ( out [ i ] == in [ i ] + 1 ); // for all i","title":"Ejemplo de functor"},{"location":"iiss-fp-1/#functor-vs-function-pointer","text":"//Functor struct add_x { add_x ( int y ) : x ( y ){} int operator ()( int y ) { return x + y ; } private : int x ; }; //Function pointer int ( func )( int x ) { return ++ x ; } std :: vector < int > vec (); //fill vec with 1 2 3 4 5 int ( * f )( int ) = func ; // function pointer initialization std :: transform ( vec . begin (), vec . end (), f ); // pass function pointer std :: transform ( vec . begin (), vec . end (), add_x ( 1 )); // pass functor","title":"Functor vs function pointer"},{"location":"iiss-fp-2/","text":"FUNCIONES Programaci\u00f3n funcional \u00b6 Funciones an\u00f3nimas \u00b6 Funci\u00f3nes an\u00f3nimas o lambdas \u00b6 Funci\u00f3n o subrutina definida y (posiblemente) llamada sin necesidad de asociarla a un identificador o nombre Se suelen pasar como argumento a funciones de orden superior Son funciones anidadas que permiten acceder a variables definidas en el \u00e1mbito de la contenedora (variables no locales a la funci\u00f3n an\u00f3nima) Muchos lenguajes las introducen a trav\u00e9s de la palabra reservada lambda Expresi\u00f3n lambda Una expresi\u00f3n lambda es una funci\u00f3n an\u00f3nima (con o sin par\u00e1metros) que es llamada sin necesidad de asociarle un nombre expl\u00edcito. Sirven para pasarlas como argumento a funciones de orden superior, momento en el cual los par\u00e1metros de la funci\u00f3n an\u00f3nima toman un valor en el contexto de ejecuci\u00f3n de la funci\u00f3n contenedora que la recibe y ejecuta. Por tanto, las funciones an\u00f3nimas permiten acceder a variables (no locales) definidas en el \u00e1mbito de la contenedora. Lambdas en los lenguajes \u00b6 Mecanismos de los lenguajes para implementar funciones an\u00f3nimas: En C++: funciones an\u00f3nimas, objetos funci\u00f3n ( functors ) o funciones lambda (desde C++11) En Java 8: expresiones lambda En Ruby: blocks, procs y lambdas En C#: delegates (m\u00e9todos an\u00f3nimos y expresiones lambda) En Python: generators, comprehensions, lambda expressions Java \u00b6 Sintaxis ( argumentos ) -> expresi\u00f3n Ejemplos ( int x , int y ) -> x + y () -> 42 ( String s ) -> { System . out . println ( s ); } Ruby \u00b6 Blocks { | argumentos | expresi\u00f3n } Lambdas -> ( argumentos ) { expresi\u00f3n } Ejemplos [ 1 , 2 , 3 ]. each { | num | puts num * 2 } # 2 4 6 times_two = -> ( x ) { x * 2 } times_two . call ( 10 ) # 20 C++ \u00b6 Sintaxis [ capture ]( parameters ) -> return_type { function_body } Entorno de referencia Capture Descripci\u00f3n [] Sin variables externas definidas. Intentar utilizar cualquier variable externa es un error [x, &y] x se captura por valor, y por referencia [&] Todas las variables externas que sean utilizadas son capturadas impl\u00edcitamente por referencia [=] Todas las variable externas que sean utilizadas son capturadas impl\u00edcitamente por valor [&, x] x se captura expl\u00edcitamente por valor; el resto, por referencia [=, &z] z se captura expl\u00edcitamente por referencia; el resto, por valor Cierres de funciones o closures \u00b6 Cierre : Funci\u00f3n o referencia a funci\u00f3n junto con un entorno de referencia La diferencia entre una funci\u00f3n normal y un cierre es que un cierre depende de una o varias variables libres . Un cierre permite acceder a las variables libres incluso cuando se invoca desde fuera de su \u00e1mbito l\u00e9xico Entorno de referencia : tabla que guarda una referencia a cada una de las variables no locales ( libres ) de la funci\u00f3n Variable libre ( free ): notaci\u00f3n l\u00f3gica matem\u00e1tica que especifica los lugares de una expresi\u00f3n donde tiene lugar una sustituci\u00f3n Variable asignada ( bound ): variable que era libre previamente pero a la que le ha sido asignado un valor o conjunto de valores Closures en Scala Seguir el tutorial sobre Closures Lambdas y cierres en C++ \u00b6 std :: vector < int > some_list ; // assume that contains something int total = 0 ; for ( int i = 0 ; i < 5 ; ++ i ) some_list . push_back ( i ); std :: for_each ( begin ( some_list ), end ( some_list ), [ & total ]( int x ) { total += x ; } ); // Computes the total of all elements in the list. /* Variable total is stored as a part of the lambda function's closure. Since it is a reference to the stack variable total, it can change its value. */ Un cierre en C++ se expresa mediante la parte [ capture ] El entorno de referencia se expresa por el conjunto de variables externas indicadas dentro del cierre Las variables del entorno de referencia en C++ pueden ser capturadas por valor ( [=] ) o por referencia ( [&] ) Las variables externas capturadas son inmutables por defecto; si no, usar mutable despu\u00e9s de los ( parameters ) Lectura: Lambdas en C++ Lecturas recomendadas Lambda Functions in C++11 - the Definitive Guide La historia de las lambdas en C++: Parte 1 y Parte 2 Funciones an\u00f3nimas en Java \u00b6 Clases an\u00f3nimas (Java 7) public class ComparatorTest { public static void main ( String [] args ) { List < Person > personList = Person . createShortList (); Collections . sort ( personList , new Comparator < Person > (){ public int compare ( Person p1 , Person p2 ){ return p1 . getLastname (). compareTo ( p2 . getLastname ()); } }); System . out . println ( \"=== Sorted Asc Lastname ===\" ); for ( Person p : personList ){ p . printName (); } Collections . sort ( personList , new Comparator < Person > (){ public int compare ( Person p1 , Person p2 ){ return p2 . getLastname (). compareTo ( p1 . getLastname ()); } }); System . out . println ( \"=== Sorted Desc Lastname ===\" ); for ( Person p : personList ){ p . printName (); } } } Lambdas (Java 8) public class ComparatorTest { public static void main ( String [] args ) { List < Person > personList = Person . createShortList (); // Print Asc System . out . println ( \"=== Sorted Asc Lastname ===\" ); Collections . sort ( personList , ( Person p1 , Person p2 ) -> p1 . getLastname (). compareTo ( p2 . getLastname ())); for ( Person p : personList ){ p . printName (); } // Print Desc System . out . println ( \"=== Sorted Desc Lastname ===\" ); Collections . sort ( personList , ( p1 , p2 ) -> p2 . getLastname (). compareTo ( p1 . getLastname ())); for ( Person p : personList ){ p . printName (); } } } Ejercicio Mejorando c\u00f3digo con expresiones lambda Captura de variables en lambdas \u00b6 Una expresi\u00f3n lambda en Java puede capturar (o no) variables de instancia no locales (atributos de la clase contenedora) y variables locales (declaradas o no final , pero cuyo valor no es modificado) del \u00e1mbito contenedor. Ejemplo: Lambda que captura variables locales final : final BigDecimal bd = new BigDecimal ( 1 ); final BigDecimal x = new BigDecimal ( 2 ); Function < BigDecimal , BigDecimal > func = ( a ) -> bd . multiply ( a ). add ( x ); for ( int j = 0 ; j < 999999999 ; j ++ ) { func . apply ( new BigDecimal ( j )); } Ejemplo: Lambda que captura variables locales no declaradas final pero cuyo valor no es modificado: BigDecimal bd = new BigDecimal ( 1 ); BigDecimal x = new BigDecimal ( 2 ); // Se puede consultar x pero no se podr\u00eda cambiar el valor de x: Function < BigDecimal , BigDecimal > func = ( a ) -> { bd . multiply ( a ). add ( x ); /* x = new BigDecimal(0); */ }; for ( int j = 0 ; j < 999999999 ; j ++ ) { func . apply ( new BigDecimal ( j )); } Ejemplo: Lambda que captura variables de instancia de la clase contenedora: public class LambdaInstanceCapturing implements Runnable { private BigDecimal bd = new BigDecimal ( 1 ); @Override public void run () { Function < BigDecimal , BigDecimal > func = ( a ) -> bd . multiply ( a ); for ( int j = 0 ; j < 999999999 ; j ++ ) { func . apply ( new BigDecimal ( j )); } } } Lambdas y clases an\u00f3nimas internas \u00b6 En Java, una expresi\u00f3n lambda y una clase an\u00f3nima interna ( inner class ) tienen un prop\u00f3sito similar, pero son diferentes en un aspecto: el \u00e1mbito ( scope ) de la definici\u00f3n de las variables locales. Cuando se usa una inner class, se crea un nuevo \u00e1mbito para dicha clase. Se pueden ocultar las variables locales para el \u00e1mbito contenedor instanciando nuevas variables con el mismo nombre. Tambi\u00e9n se puede usar la palabra reservada this dentro de una clase an\u00f3nima para hacer referencia a su instancia. Sin embargo, las expresiones lambda trabajan con el \u00e1mbito contenedor. No se pueden ocultar las variables del \u00e1mbito contenedor dentro del cuerpo de la expresi\u00f3n lambda. En tal caso, la palabra reservada this hace referencia a una instancia de la clase contenedora. En el ejemplo siguiente, \u00bfqu\u00e9 valor devuelve scopeExperiment() ?: @FunctionalInterface public interface ClaseFuncional { String method ( String string ); } private String variable = \"Valor de la contenedora\" ; //... public String scopeExperiment () { ClaseFuncional unaInnerClass = new ClaseFuncional () { String variable = \"Valor de la inner class\" ; @Override public String method ( String string ) { return this . variable ; /* Con o sin this, no hay lambdas ni variables libres */ } }; String resultadoInnerClass = unaInnerClass . method ( \"\" ); ClaseFuncional unaLambda = parametro -> { String variable = \"Valor de la lambda\" ; return this . variable ; /* Con this, el cierre de la variable libre se produce con el valor de ClaseFuncional::variable */ }; String resultadoLambda = unaLambda . method ( \"\" ); return \"resultadoInnerClass = \" + resultadoInnerClass + \",\\nresultadoLambda = \" + resultadoLambda ; } El valor ser\u00e1: resultadoInnerClass = Valor de la inner class, resultadoLambda = Valor de la contenedora Funciones an\u00f3nimas en Ruby \u00b6 Bloques ( blocks ) \u00b6 Sintaxis `do` ... `end` some_list = [ 10 , 20 , 30 ] some_list . map do | i | i += 1 end Sintaxis `{` ... `}` some_list = [ 10 , 20 , 30 ] some_list . map { | i | i += 1 } El m\u00e9todo map itera y aplica un bloque repetitivamente a cada elemento de una colecci\u00f3n (representado por el par\u00e1metro i ) Ejemplo: b\u00fasqueda en una lista \u00b6 Sin bloques: class SongList def with_title ( title ) for i in 0 ... @songs . length return @songs [ i ] if title == @songs [ i ]. name end return nil end end Con bloques (sintaxis `do` ... `end`): class SongList def with_title ( title ) @songs . find do | song | title == song . name end end end Con bloques (sintaxis `{` ... `}`): class SongList def with_title ( title ) @songs . find { | song | title == song . name } end end El m\u00e9todo find itera y aplica el test del bloque a cada elemento song de la colecci\u00f3n. Ejecuci\u00f3n de bloques \u00b6 El bloque debe aparecer al lado de una llamada a m\u00e9todo No se ejecuta el bloque, sino que se recuerda el contexto (variables locales, objeto actual, etc.) en que aparece Cuando se ejecuta el m\u00e9todo, el bloque es invocado donde aparezca yield El control vuelve al m\u00e9todo despu\u00e9s del yield Al bloque se le pueden pasar par\u00e1metros Ejemplo: fibonacci def fib_up_to ( max ) i1 , i2 = 1 , 1 while i1 <= max yield i1 i1 , i2 = i2 , i1 + i2 end end fib_up_to ( 1000 ) { | f | print f , \" \" } #Salida => 1 1 2 3 5 8 13 21 34 55 89 144 233 377 610 987 Ejemplo de yield : def three_times yield yield yield end three_times { puts \"Hello\" } Ejemplo: implementaci\u00f3n de Array.find class Array def find for i in 0 ... size value = self [ i ] return value if yield ( value ) end return nil end end Ejemplos: iterar con bloques Iterar sobre un array con each Array#each : recibe un array y aplica el bloque a cada item, sin modificar el array ni crear un nuevo objeto; devuelve el mismo array. [ 1 , 3 , 5 , 7 , 9 ]. each { | i | printf i , \" \" } #Salida => 1 3 5 7 9 Array a = [ 1 , 2 , 3 , 4 ] a . each { | i | puts i * 2 } #Salida => 2 4 6 8 #Devuelve => [1, 2, 3, 4] a #Devuelve => [1, 2, 3, 4] Iterar sobre un fichero con each File#each : recibe el contenido de un fichero de texto y aplica el bloque a cada l\u00ednea. f = File . open ( \"testfile\" ) f . each do | line | puts line end f . close f = File . open ( \"testfile\" ) f . each { | line | puts line } f . close Iterar sobre un array con collect Array#collect : aplica el bloque a todos los items y devuelve el nuevo array modificado; hace lo mismo que Array#map [ \"H\" , \"A\" , \"L\" ]. collect { | x | x . succ } # Salida => [''I'', ''B'', ''M''] Array a = [ 1 , 2 , 3 , 4 ] a . collect { | i | puts i * 2 } #Salida => 2 4 6 8 #Devuelve => [nil, nil, nil, nil] a . collect { | i | i . succ } #Devuelve => [2, 3, 4, 5] a #Devuelve => [1, 2, 3, 4] Procs y lambdas \u00b6 En Ruby, una funci\u00f3n an\u00f3nima o lambda es simplemente un tipo especial de objeto Proc Definici\u00f3n de procs/lambdas: # sin argumentos: say_something = -> { puts \"This is a lambda\" } say_something = lambda { puts \"This is a lambda\" } say_otherwise = Proc . new { puts \"This is a proc\" } # con argumentos: times_two = -> ( x ) { x * 2 } Varias formas de llamar a la lambda (es preferible call ) say_something = -> { puts \"This is a lambda\" } say_something . call say_something . () say_something [] say_otherwise = Proc . new { puts \"This is a proc\" } say_otherwise . call times_two = -> ( x ) { x * 2 } times_two . call ( 10 ) Los proc no se preocupan de los argumentos: t = Proc . new { | x , y | puts \"I don't care about args!\" } t . call #Salida: I don't care about args! t . call ( 10 ) #Salida: I don't care about args! t . call ( 10 , 10 ) #Salida: I don't care about args! t . call ( 10 , 10 ) #Salida: I don't care about args! s = -> ( x , y ) { puts \"I care about args\" } s . call # ArgumentError: wrong number of arguments (given 0, expected 2) s . call ( 10 ) # ArgumentError: wrong number of arguments (given 1, expected 2) s . call ( 10 , 10 ) # Salida: I care about args Los proc retornan del m\u00e9todo actual; los lambda retornan de la funci\u00f3n an\u00f3nima: # funciona: my_lambda = -> { return 1 } puts \"Lambda result: #{ my_lambda . call } \" # eleva una exceci\u00f3n: my_proc = Proc . new { return 1 } puts \"Proc result: #{ my_proc . call } \" Si el proc est\u00e1 dentro de un m\u00e9todo, la llamada a return es equivalente a retornar de ese m\u00e9todo: def call_proc puts \"Before proc\" my_proc = Proc . new { return 2 } my_proc . call puts \"After proc\" end puts call_proc # Prints \"Before proc\" but not \"After proc\" def call_lambda puts \"Before lambda\" my_lambda = lambda { return 2 } my_lambda . call puts \"After lambda\" end puts call_lambda # Prints \"Before lambda\" and \"After lambda\" Diferencias entre Proc y lambda : Las lambdas se definen con -> {} y los procs con Proc.new {} Los Proc retornan del m\u00e9todo actual, las lambdas retornan de la propia funci\u00f3n lambda Los Proc no se preocupan del n\u00famero correcto de argumentos, las lambdas elevan una excepci\u00f3n Paso de bloques como par\u00e1metros \u00b6 Simplemente, se a\u00f1ade al final de la llamada a un m\u00e9todo \u00bfD\u00f3nde se llama al bloque? Donde el m\u00e9todo indique con yield El bloque (realmente un objeto Proc ) se pasa como una especie de par\u00e1metro no declarado Ejemplos de paso de bloques: Llamada a un bloque sin par\u00e1metros def run_it puts ( \"Before the yield\" ) yield puts ( \"After the yield\" ) end run_it do puts ( 'Hello' ) puts ( 'Coming to you from inside the block' ) end # Salida => # Before the yield # Hello # Coming to you from inside the block # After the yield Cualquier m\u00e9todo puede recibir un bloque como par\u00e1metro impl\u00edcito, pero no lo ejecuta si no hace yield : def run_it end run_it do puts ( 'Hello' ) end # => No genera salida Con yield : def run_it yield if block_given? end run_it do puts ( 'Hello' ) end # Salida => # Hello Llamada a un bloque con par\u00e1metros: def run_it_with_parameter puts ( 'Before the yield' ) yield ( 24 ) puts ( 'After the yield' ) end run_it_with_parameter do | x | puts ( 'Hello from inside the proc' ) puts ( \"The value of x is #{ x } \" ) end # Salida => # Before the yield # Hello from inside the proc # The value of x is 24 # After the yield Hacer expl\u00edcito el bloque pasado como par\u00e1metro usando ampersand : explicitamos que se espera que el m\u00e9todo reciba un par\u00e1metro de tipo bloque def run_it_with_parameter ( & block ) puts ( 'Before the call' ) block . call ( 24 ) puts ( 'After the call' ) end Convertir un Proc o un lambda en un bloque pasado como par\u00e1metro: my_proc = Proc . new { | x | puts ( \"The value of x is #{ x } \" )} run_it_with_parameter ( & my_proc ) my_lambda = lambda { | x | puts ( \"The value of x is #{ x } \" )} run_it_with_parameter ( & my_lambda ) # Salida (en ambos casos) => # Before the call # The value of x is 24 # After the call Lecturas recomendadas M. Williams: Java SE 8: Lambda Quick Start , Oracle Learning Library, 2013. D. Thomas & A. Hunt: Programming Ruby. The Pragmatic Programmer's Guide , Addison-Wesley, 2005. Ejemplo de interfaces funcionales: Formateo de informes \u00b6 Versi\u00f3n en ruby class Report attr_reader :title , :text attr_accessor :formatter def initialize ( formatter ) @title = 'Informe mensual' @text = [ 'Todo marcha' , 'muy bien.' ] @formatter = formatter end def output_report () @formatter . output_report ( self ) end end class HTMLFormatter def output_report ( context ) puts ( '<html>' ) puts ( ' <head>' ) # Output The rest of the report ... puts ( \" <title> #{ context . title } </title>\" ) puts ( ' </head>' ) puts ( ' <body>' ) context . text . each do | line | puts ( \" <p> #{ line } </p>\" ) end puts ( ' </body>' ) puts ( '</html>' ) end end class PlainTextFormatter def output_report ( context ) puts ( \"***** #{ context . title } *****\" ) context . text . each do | line | Versi\u00f3n con interfaces funcionales (Ruby procs + blocks) class Report attr_reader :title , :text attr_accessor :formatter def initialize ( & formatter ) @title = 'Monthly Report' @text = [ 'Things are going' , 'really, really well.' ] @formatter = formatter end def output_report @formatter . call ( self ) end end Formateo HTML HTML_FORMATTER = lambda do | context | puts ( '<html>' ) puts ( ' <head>' ) puts ( \" <title> #{ context . title } </title>\" ) puts ( ' </head>' ) puts ( ' <body>' ) context . text . each do | line | puts ( \" <p> #{ line } </p>\" ) end puts ( ' </body>' ) puts report = Report . new & HTML_FORMATTER report . output_report Formateo de texto report = Report . new do | context | puts ( \"***** #{ context . title } *****\" ) context . text . each do | line | puts ( line ) end end","title":"Lambdas"},{"location":"iiss-fp-2/#programacion-funcional","text":"","title":"Programaci\u00f3n funcional"},{"location":"iiss-fp-2/#funciones-anonimas","text":"","title":"Funciones an\u00f3nimas"},{"location":"iiss-fp-2/#funciones-anonimas-o-lambdas","text":"Funci\u00f3n o subrutina definida y (posiblemente) llamada sin necesidad de asociarla a un identificador o nombre Se suelen pasar como argumento a funciones de orden superior Son funciones anidadas que permiten acceder a variables definidas en el \u00e1mbito de la contenedora (variables no locales a la funci\u00f3n an\u00f3nima) Muchos lenguajes las introducen a trav\u00e9s de la palabra reservada lambda Expresi\u00f3n lambda Una expresi\u00f3n lambda es una funci\u00f3n an\u00f3nima (con o sin par\u00e1metros) que es llamada sin necesidad de asociarle un nombre expl\u00edcito. Sirven para pasarlas como argumento a funciones de orden superior, momento en el cual los par\u00e1metros de la funci\u00f3n an\u00f3nima toman un valor en el contexto de ejecuci\u00f3n de la funci\u00f3n contenedora que la recibe y ejecuta. Por tanto, las funciones an\u00f3nimas permiten acceder a variables (no locales) definidas en el \u00e1mbito de la contenedora.","title":"Funci\u00f3nes an\u00f3nimas o lambdas"},{"location":"iiss-fp-2/#lambdas-en-los-lenguajes","text":"Mecanismos de los lenguajes para implementar funciones an\u00f3nimas: En C++: funciones an\u00f3nimas, objetos funci\u00f3n ( functors ) o funciones lambda (desde C++11) En Java 8: expresiones lambda En Ruby: blocks, procs y lambdas En C#: delegates (m\u00e9todos an\u00f3nimos y expresiones lambda) En Python: generators, comprehensions, lambda expressions","title":"Lambdas en los lenguajes"},{"location":"iiss-fp-2/#java","text":"Sintaxis ( argumentos ) -> expresi\u00f3n Ejemplos ( int x , int y ) -> x + y () -> 42 ( String s ) -> { System . out . println ( s ); }","title":"Java"},{"location":"iiss-fp-2/#ruby","text":"Blocks { | argumentos | expresi\u00f3n } Lambdas -> ( argumentos ) { expresi\u00f3n } Ejemplos [ 1 , 2 , 3 ]. each { | num | puts num * 2 } # 2 4 6 times_two = -> ( x ) { x * 2 } times_two . call ( 10 ) # 20","title":"Ruby"},{"location":"iiss-fp-2/#c","text":"Sintaxis [ capture ]( parameters ) -> return_type { function_body } Entorno de referencia Capture Descripci\u00f3n [] Sin variables externas definidas. Intentar utilizar cualquier variable externa es un error [x, &y] x se captura por valor, y por referencia [&] Todas las variables externas que sean utilizadas son capturadas impl\u00edcitamente por referencia [=] Todas las variable externas que sean utilizadas son capturadas impl\u00edcitamente por valor [&, x] x se captura expl\u00edcitamente por valor; el resto, por referencia [=, &z] z se captura expl\u00edcitamente por referencia; el resto, por valor","title":"C++"},{"location":"iiss-fp-2/#cierres-de-funciones-o-closures","text":"Cierre : Funci\u00f3n o referencia a funci\u00f3n junto con un entorno de referencia La diferencia entre una funci\u00f3n normal y un cierre es que un cierre depende de una o varias variables libres . Un cierre permite acceder a las variables libres incluso cuando se invoca desde fuera de su \u00e1mbito l\u00e9xico Entorno de referencia : tabla que guarda una referencia a cada una de las variables no locales ( libres ) de la funci\u00f3n Variable libre ( free ): notaci\u00f3n l\u00f3gica matem\u00e1tica que especifica los lugares de una expresi\u00f3n donde tiene lugar una sustituci\u00f3n Variable asignada ( bound ): variable que era libre previamente pero a la que le ha sido asignado un valor o conjunto de valores Closures en Scala Seguir el tutorial sobre Closures","title":"Cierres de funciones o closures"},{"location":"iiss-fp-2/#lambdas-y-cierres-en-c","text":"std :: vector < int > some_list ; // assume that contains something int total = 0 ; for ( int i = 0 ; i < 5 ; ++ i ) some_list . push_back ( i ); std :: for_each ( begin ( some_list ), end ( some_list ), [ & total ]( int x ) { total += x ; } ); // Computes the total of all elements in the list. /* Variable total is stored as a part of the lambda function's closure. Since it is a reference to the stack variable total, it can change its value. */ Un cierre en C++ se expresa mediante la parte [ capture ] El entorno de referencia se expresa por el conjunto de variables externas indicadas dentro del cierre Las variables del entorno de referencia en C++ pueden ser capturadas por valor ( [=] ) o por referencia ( [&] ) Las variables externas capturadas son inmutables por defecto; si no, usar mutable despu\u00e9s de los ( parameters ) Lectura: Lambdas en C++ Lecturas recomendadas Lambda Functions in C++11 - the Definitive Guide La historia de las lambdas en C++: Parte 1 y Parte 2","title":"Lambdas y cierres en C++"},{"location":"iiss-fp-2/#funciones-anonimas-en-java","text":"Clases an\u00f3nimas (Java 7) public class ComparatorTest { public static void main ( String [] args ) { List < Person > personList = Person . createShortList (); Collections . sort ( personList , new Comparator < Person > (){ public int compare ( Person p1 , Person p2 ){ return p1 . getLastname (). compareTo ( p2 . getLastname ()); } }); System . out . println ( \"=== Sorted Asc Lastname ===\" ); for ( Person p : personList ){ p . printName (); } Collections . sort ( personList , new Comparator < Person > (){ public int compare ( Person p1 , Person p2 ){ return p2 . getLastname (). compareTo ( p1 . getLastname ()); } }); System . out . println ( \"=== Sorted Desc Lastname ===\" ); for ( Person p : personList ){ p . printName (); } } } Lambdas (Java 8) public class ComparatorTest { public static void main ( String [] args ) { List < Person > personList = Person . createShortList (); // Print Asc System . out . println ( \"=== Sorted Asc Lastname ===\" ); Collections . sort ( personList , ( Person p1 , Person p2 ) -> p1 . getLastname (). compareTo ( p2 . getLastname ())); for ( Person p : personList ){ p . printName (); } // Print Desc System . out . println ( \"=== Sorted Desc Lastname ===\" ); Collections . sort ( personList , ( p1 , p2 ) -> p2 . getLastname (). compareTo ( p1 . getLastname ())); for ( Person p : personList ){ p . printName (); } } } Ejercicio Mejorando c\u00f3digo con expresiones lambda","title":"Funciones an\u00f3nimas en Java"},{"location":"iiss-fp-2/#captura-de-variables-en-lambdas","text":"Una expresi\u00f3n lambda en Java puede capturar (o no) variables de instancia no locales (atributos de la clase contenedora) y variables locales (declaradas o no final , pero cuyo valor no es modificado) del \u00e1mbito contenedor. Ejemplo: Lambda que captura variables locales final : final BigDecimal bd = new BigDecimal ( 1 ); final BigDecimal x = new BigDecimal ( 2 ); Function < BigDecimal , BigDecimal > func = ( a ) -> bd . multiply ( a ). add ( x ); for ( int j = 0 ; j < 999999999 ; j ++ ) { func . apply ( new BigDecimal ( j )); } Ejemplo: Lambda que captura variables locales no declaradas final pero cuyo valor no es modificado: BigDecimal bd = new BigDecimal ( 1 ); BigDecimal x = new BigDecimal ( 2 ); // Se puede consultar x pero no se podr\u00eda cambiar el valor de x: Function < BigDecimal , BigDecimal > func = ( a ) -> { bd . multiply ( a ). add ( x ); /* x = new BigDecimal(0); */ }; for ( int j = 0 ; j < 999999999 ; j ++ ) { func . apply ( new BigDecimal ( j )); } Ejemplo: Lambda que captura variables de instancia de la clase contenedora: public class LambdaInstanceCapturing implements Runnable { private BigDecimal bd = new BigDecimal ( 1 ); @Override public void run () { Function < BigDecimal , BigDecimal > func = ( a ) -> bd . multiply ( a ); for ( int j = 0 ; j < 999999999 ; j ++ ) { func . apply ( new BigDecimal ( j )); } } }","title":"Captura de variables en lambdas"},{"location":"iiss-fp-2/#lambdas-y-clases-anonimas-internas","text":"En Java, una expresi\u00f3n lambda y una clase an\u00f3nima interna ( inner class ) tienen un prop\u00f3sito similar, pero son diferentes en un aspecto: el \u00e1mbito ( scope ) de la definici\u00f3n de las variables locales. Cuando se usa una inner class, se crea un nuevo \u00e1mbito para dicha clase. Se pueden ocultar las variables locales para el \u00e1mbito contenedor instanciando nuevas variables con el mismo nombre. Tambi\u00e9n se puede usar la palabra reservada this dentro de una clase an\u00f3nima para hacer referencia a su instancia. Sin embargo, las expresiones lambda trabajan con el \u00e1mbito contenedor. No se pueden ocultar las variables del \u00e1mbito contenedor dentro del cuerpo de la expresi\u00f3n lambda. En tal caso, la palabra reservada this hace referencia a una instancia de la clase contenedora. En el ejemplo siguiente, \u00bfqu\u00e9 valor devuelve scopeExperiment() ?: @FunctionalInterface public interface ClaseFuncional { String method ( String string ); } private String variable = \"Valor de la contenedora\" ; //... public String scopeExperiment () { ClaseFuncional unaInnerClass = new ClaseFuncional () { String variable = \"Valor de la inner class\" ; @Override public String method ( String string ) { return this . variable ; /* Con o sin this, no hay lambdas ni variables libres */ } }; String resultadoInnerClass = unaInnerClass . method ( \"\" ); ClaseFuncional unaLambda = parametro -> { String variable = \"Valor de la lambda\" ; return this . variable ; /* Con this, el cierre de la variable libre se produce con el valor de ClaseFuncional::variable */ }; String resultadoLambda = unaLambda . method ( \"\" ); return \"resultadoInnerClass = \" + resultadoInnerClass + \",\\nresultadoLambda = \" + resultadoLambda ; } El valor ser\u00e1: resultadoInnerClass = Valor de la inner class, resultadoLambda = Valor de la contenedora","title":"Lambdas y clases an\u00f3nimas internas"},{"location":"iiss-fp-2/#funciones-anonimas-en-ruby","text":"","title":"Funciones an\u00f3nimas en Ruby"},{"location":"iiss-fp-2/#bloques-blocks","text":"Sintaxis `do` ... `end` some_list = [ 10 , 20 , 30 ] some_list . map do | i | i += 1 end Sintaxis `{` ... `}` some_list = [ 10 , 20 , 30 ] some_list . map { | i | i += 1 } El m\u00e9todo map itera y aplica un bloque repetitivamente a cada elemento de una colecci\u00f3n (representado por el par\u00e1metro i )","title":"Bloques (blocks)"},{"location":"iiss-fp-2/#ejemplo-busqueda-en-una-lista","text":"Sin bloques: class SongList def with_title ( title ) for i in 0 ... @songs . length return @songs [ i ] if title == @songs [ i ]. name end return nil end end Con bloques (sintaxis `do` ... `end`): class SongList def with_title ( title ) @songs . find do | song | title == song . name end end end Con bloques (sintaxis `{` ... `}`): class SongList def with_title ( title ) @songs . find { | song | title == song . name } end end El m\u00e9todo find itera y aplica el test del bloque a cada elemento song de la colecci\u00f3n.","title":"Ejemplo: b\u00fasqueda en una lista"},{"location":"iiss-fp-2/#ejecucion-de-bloques","text":"El bloque debe aparecer al lado de una llamada a m\u00e9todo No se ejecuta el bloque, sino que se recuerda el contexto (variables locales, objeto actual, etc.) en que aparece Cuando se ejecuta el m\u00e9todo, el bloque es invocado donde aparezca yield El control vuelve al m\u00e9todo despu\u00e9s del yield Al bloque se le pueden pasar par\u00e1metros Ejemplo: fibonacci def fib_up_to ( max ) i1 , i2 = 1 , 1 while i1 <= max yield i1 i1 , i2 = i2 , i1 + i2 end end fib_up_to ( 1000 ) { | f | print f , \" \" } #Salida => 1 1 2 3 5 8 13 21 34 55 89 144 233 377 610 987 Ejemplo de yield : def three_times yield yield yield end three_times { puts \"Hello\" } Ejemplo: implementaci\u00f3n de Array.find class Array def find for i in 0 ... size value = self [ i ] return value if yield ( value ) end return nil end end Ejemplos: iterar con bloques Iterar sobre un array con each Array#each : recibe un array y aplica el bloque a cada item, sin modificar el array ni crear un nuevo objeto; devuelve el mismo array. [ 1 , 3 , 5 , 7 , 9 ]. each { | i | printf i , \" \" } #Salida => 1 3 5 7 9 Array a = [ 1 , 2 , 3 , 4 ] a . each { | i | puts i * 2 } #Salida => 2 4 6 8 #Devuelve => [1, 2, 3, 4] a #Devuelve => [1, 2, 3, 4] Iterar sobre un fichero con each File#each : recibe el contenido de un fichero de texto y aplica el bloque a cada l\u00ednea. f = File . open ( \"testfile\" ) f . each do | line | puts line end f . close f = File . open ( \"testfile\" ) f . each { | line | puts line } f . close Iterar sobre un array con collect Array#collect : aplica el bloque a todos los items y devuelve el nuevo array modificado; hace lo mismo que Array#map [ \"H\" , \"A\" , \"L\" ]. collect { | x | x . succ } # Salida => [''I'', ''B'', ''M''] Array a = [ 1 , 2 , 3 , 4 ] a . collect { | i | puts i * 2 } #Salida => 2 4 6 8 #Devuelve => [nil, nil, nil, nil] a . collect { | i | i . succ } #Devuelve => [2, 3, 4, 5] a #Devuelve => [1, 2, 3, 4]","title":"Ejecuci\u00f3n de bloques"},{"location":"iiss-fp-2/#procs-y-lambdas","text":"En Ruby, una funci\u00f3n an\u00f3nima o lambda es simplemente un tipo especial de objeto Proc Definici\u00f3n de procs/lambdas: # sin argumentos: say_something = -> { puts \"This is a lambda\" } say_something = lambda { puts \"This is a lambda\" } say_otherwise = Proc . new { puts \"This is a proc\" } # con argumentos: times_two = -> ( x ) { x * 2 } Varias formas de llamar a la lambda (es preferible call ) say_something = -> { puts \"This is a lambda\" } say_something . call say_something . () say_something [] say_otherwise = Proc . new { puts \"This is a proc\" } say_otherwise . call times_two = -> ( x ) { x * 2 } times_two . call ( 10 ) Los proc no se preocupan de los argumentos: t = Proc . new { | x , y | puts \"I don't care about args!\" } t . call #Salida: I don't care about args! t . call ( 10 ) #Salida: I don't care about args! t . call ( 10 , 10 ) #Salida: I don't care about args! t . call ( 10 , 10 ) #Salida: I don't care about args! s = -> ( x , y ) { puts \"I care about args\" } s . call # ArgumentError: wrong number of arguments (given 0, expected 2) s . call ( 10 ) # ArgumentError: wrong number of arguments (given 1, expected 2) s . call ( 10 , 10 ) # Salida: I care about args Los proc retornan del m\u00e9todo actual; los lambda retornan de la funci\u00f3n an\u00f3nima: # funciona: my_lambda = -> { return 1 } puts \"Lambda result: #{ my_lambda . call } \" # eleva una exceci\u00f3n: my_proc = Proc . new { return 1 } puts \"Proc result: #{ my_proc . call } \" Si el proc est\u00e1 dentro de un m\u00e9todo, la llamada a return es equivalente a retornar de ese m\u00e9todo: def call_proc puts \"Before proc\" my_proc = Proc . new { return 2 } my_proc . call puts \"After proc\" end puts call_proc # Prints \"Before proc\" but not \"After proc\" def call_lambda puts \"Before lambda\" my_lambda = lambda { return 2 } my_lambda . call puts \"After lambda\" end puts call_lambda # Prints \"Before lambda\" and \"After lambda\" Diferencias entre Proc y lambda : Las lambdas se definen con -> {} y los procs con Proc.new {} Los Proc retornan del m\u00e9todo actual, las lambdas retornan de la propia funci\u00f3n lambda Los Proc no se preocupan del n\u00famero correcto de argumentos, las lambdas elevan una excepci\u00f3n","title":"Procs y lambdas"},{"location":"iiss-fp-2/#paso-de-bloques-como-parametros","text":"Simplemente, se a\u00f1ade al final de la llamada a un m\u00e9todo \u00bfD\u00f3nde se llama al bloque? Donde el m\u00e9todo indique con yield El bloque (realmente un objeto Proc ) se pasa como una especie de par\u00e1metro no declarado Ejemplos de paso de bloques: Llamada a un bloque sin par\u00e1metros def run_it puts ( \"Before the yield\" ) yield puts ( \"After the yield\" ) end run_it do puts ( 'Hello' ) puts ( 'Coming to you from inside the block' ) end # Salida => # Before the yield # Hello # Coming to you from inside the block # After the yield Cualquier m\u00e9todo puede recibir un bloque como par\u00e1metro impl\u00edcito, pero no lo ejecuta si no hace yield : def run_it end run_it do puts ( 'Hello' ) end # => No genera salida Con yield : def run_it yield if block_given? end run_it do puts ( 'Hello' ) end # Salida => # Hello Llamada a un bloque con par\u00e1metros: def run_it_with_parameter puts ( 'Before the yield' ) yield ( 24 ) puts ( 'After the yield' ) end run_it_with_parameter do | x | puts ( 'Hello from inside the proc' ) puts ( \"The value of x is #{ x } \" ) end # Salida => # Before the yield # Hello from inside the proc # The value of x is 24 # After the yield Hacer expl\u00edcito el bloque pasado como par\u00e1metro usando ampersand : explicitamos que se espera que el m\u00e9todo reciba un par\u00e1metro de tipo bloque def run_it_with_parameter ( & block ) puts ( 'Before the call' ) block . call ( 24 ) puts ( 'After the call' ) end Convertir un Proc o un lambda en un bloque pasado como par\u00e1metro: my_proc = Proc . new { | x | puts ( \"The value of x is #{ x } \" )} run_it_with_parameter ( & my_proc ) my_lambda = lambda { | x | puts ( \"The value of x is #{ x } \" )} run_it_with_parameter ( & my_lambda ) # Salida (en ambos casos) => # Before the call # The value of x is 24 # After the call Lecturas recomendadas M. Williams: Java SE 8: Lambda Quick Start , Oracle Learning Library, 2013. D. Thomas & A. Hunt: Programming Ruby. The Pragmatic Programmer's Guide , Addison-Wesley, 2005.","title":"Paso de bloques como par\u00e1metros"},{"location":"iiss-fp-2/#ejemplo-de-interfaces-funcionales-formateo-de-informes","text":"Versi\u00f3n en ruby class Report attr_reader :title , :text attr_accessor :formatter def initialize ( formatter ) @title = 'Informe mensual' @text = [ 'Todo marcha' , 'muy bien.' ] @formatter = formatter end def output_report () @formatter . output_report ( self ) end end class HTMLFormatter def output_report ( context ) puts ( '<html>' ) puts ( ' <head>' ) # Output The rest of the report ... puts ( \" <title> #{ context . title } </title>\" ) puts ( ' </head>' ) puts ( ' <body>' ) context . text . each do | line | puts ( \" <p> #{ line } </p>\" ) end puts ( ' </body>' ) puts ( '</html>' ) end end class PlainTextFormatter def output_report ( context ) puts ( \"***** #{ context . title } *****\" ) context . text . each do | line | Versi\u00f3n con interfaces funcionales (Ruby procs + blocks) class Report attr_reader :title , :text attr_accessor :formatter def initialize ( & formatter ) @title = 'Monthly Report' @text = [ 'Things are going' , 'really, really well.' ] @formatter = formatter end def output_report @formatter . call ( self ) end end Formateo HTML HTML_FORMATTER = lambda do | context | puts ( '<html>' ) puts ( ' <head>' ) puts ( \" <title> #{ context . title } </title>\" ) puts ( ' </head>' ) puts ( ' <body>' ) context . text . each do | line | puts ( \" <p> #{ line } </p>\" ) end puts ( ' </body>' ) puts report = Report . new & HTML_FORMATTER report . output_report Formateo de texto report = Report . new do | context | puts ( \"***** #{ context . title } *****\" ) context . text . each do | line | puts ( line ) end end","title":"Ejemplo de interfaces funcionales: Formateo de informes"},{"location":"iiss-fp-3/","text":"FUNCIONES Programaci\u00f3n funcional \u00b6 Mixins \u00b6 En POO, un mixin es una clase con m\u00e9todos disponibles para otras clases sin tener que ser madre de estas otras (es decir, sin usar la herencia) Es una alternativa a la herencia m\u00faltiple Incluye una interfaz con m\u00e9todos ya implementados No se heredan sino que se incluyen Un mixin es una (sub)clase, luego define un comportamiento y un estado Es una forma de implementar el principio de inversi\u00f3n de dependencias (DIP) Ruby modules \u00b6 En Ruby los mixins se implementan mediante m\u00f3dulos ( module ). Un m\u00f3dulo no puede tener instancias (porque no es una clase) Un m\u00f3dulo puede incluirse ( include ) dentro de la definici\u00f3n de una clase Ejemplo: herencia vs mixins \u00b6 module Debug def whoAmI? \" #{ self . class . name } ( \\# #{ self . object_id } ): #{ self . to_s } \" end end class MusicWork def initialize ( title ) @title = title end def to_s @title end end class Phonograph < MusicWork include Debug end class EightTrack < MusicWork include Debug end ph = Phonograph . new ( \"West End Blues\" ) et = EightTrack . new ( \"Surrealistic Pillow\" ) ph . whoAmI? # => \"Phonograph (#70315984363660): West End Blues\" et . whoAmI? # => \"EightTrack (#70315996611260): Surrealistic Pillow\" Ejemplo: Comparable en scala \u00b6 En Scala se puede implementar el equivalente a la interfaz Comparable de Java mediante traits: trait Ord { def < ( that : Any ) : Boolean def <=( that : Any ) : Boolean = ( this < that ) || ( this == that ) def > ( that : Any ) : Boolean = !( this <= that ) def >=( that : Any ) : Boolean = !( this < that ) } class Fecha ( d : Int , m : Int , a : Int ) extends Ord { def anno = a def mes = m def dia = d override def toString () : String = s\" $dia - $mes - $anno \" override def equals ( that : Any ) : Boolean = that . isInstanceOf [ Fecha ] && { val o = that . asInstanceOf [ Fecha ] o . dia == dia && o . mes == mes && o . anno == anno } def <( that : Any ) : Boolean = { if (! that . isInstanceOf [ Fecha ]) sys . error ( \"no se puede comparar\" + that + \" y una fecha\" ) val o = that . asInstanceOf [ Fecha ] ( anno < o . anno ) || ( anno == o . anno && ( mes < o . mes || ( mes == o . mes && dia < o . dia ))) } } object MiApp { def main ( args : Array [ String ]) : Unit = { val f1 = new Fecha ( 12 , 4 , 2009 ) val f2 = new Fecha ( 12 , 4 , 2019 ) println ( s\" $f1 es posterior a $f2 ? ${ f1 >= f2 } \" ) } } Ejemplo: Comparable en ruby \u00b6 Una manera de implementar un Comparable en ruby mediante el m\u00f3dulo Comparable : class Student include Comparable # The class Student 'inherits' Comparable module using include keyword attr_accessor :name , :score def initialize ( name , score ) @name = name @score = score end # Including the Comparison module, requires the implementing class to define the <=> comparison operator # Here's the comparison operator. We compare 2 student instances based on their scores. def <=> ( other ) @score <=> other . score end # Here's the good bit - I get access to <, <=, >,>= and other methods of the Comparable Interface for free. end s1 = Student . new ( \"Peter\" , 100 ) s2 = Student . new ( \"Jason\" , 90 ) s3 = Student . new ( \"Maria\" , 95 ) s1 > s2 #true s1 <= s2 #false s3 . between? ( s1 , s2 ) #true La clase que incluye el m\u00f3dulo Comparable tiene que implementar: el m\u00e9todo <=> : es un m\u00e9todo que incluye los siguientes operadores/m\u00e9todos: <, <=, ==, >, >=, between? el atributo-criterio de comparaci\u00f3n En x <=> y , x es el receptor del mensaje/m\u00e9todo e y es el argumento Ejemplo: Adaptador de interfaz en Ruby \u00b6 Interfaz americana class Renderer def render ( text_object ) text = text_object . text size = text_object . size_inches color = text_object . color # render the text ... end end class TextObject attr_reader :text , :size_inches , :color def initialize ( text , size_inches , color ) @text = text @size_inches = size_inches @color = color end end Interfaz brit\u00e1nica ## british_text_object.rb class BritishTextObject attr_reader :string , :size_mm , :colour # ... end Adaptador de interfaz: versi\u00f3n cl\u00e1sica class BritishTextObjectAdapter < TextObject def initialize ( bto ) @bto = bto end def text return @bto . string end def size_inches return @bto . size_mm / 25 . 4 end def color return @bto . colour end end Adaptador de interfaz: versi\u00f3n con m\u00f3dulos \u00b6 ## Make sure the original class is loaded require 'british_text_object' ## Now add some methods to the original class class BritishTextObject def color return colour end def text return string end def size_inches return size_mm / 25 . 4 end end require carga la clase original la reescritura de m\u00e9todos modifica la clase, no la declara de nuevo se puede hacer incluso con las clases built-in de la biblioteca de Ruby Adaptador de interfaz: instancia \u00fanica \u00b6 bto = BritishTextObject . new ( 'hello' , 50 . 8 , :blue ) class << bto def color colour end def text string end def size_inches return size_mm / 25 . 4 end end o bien: def bto . color colour end def bto . text string end ## ... Modifica el comportamiento solo de 1 instancia Ruby llama a esto singleton methods y singleton class (no es exactamente lo mismo que el patr\u00f3n singleton del GoF) Ruby primero busca los m\u00e9todos definidos en una clase singleton y luego en la clase regular que ha sido redefinida Tutoriales y ejercicios recomendados: Ruby Ruby from other languages Tutorial: Ruby modules Scala Traits \u00b6 Un trait es una forma de separar las dos principales responsabilidades de una clase: definir el estado de sus instancias y definir su comportamiento . Las clases y los objetos en Scala pueden extender un trait Los trait de Scala son similares a las interface de Java. Java default methods Desde Java 8, las interfaces pueden incorporar m\u00e9todos por defecto que hacen que las interfaces de Java se comporten m\u00e1s como un trait. Sirven para implementar herencia m\u00faltiple Los trait no pueden instanciarse Los m\u00e9todos definidos en una clase tienen precedencia sobre los de un trait Los trait no tienen estado propio, sino el del objeto o la instancia de la clase a la que se aplica Ejemplo: Iterador como un trait \u00b6 trait Iterator [ A ] { def hasNext : Boolean def next () : A } class IntIterator ( to : Int ) extends Iterator [ Int ] { private var current = 0 override def hasNext : Boolean = current < to override def next () : Int = { if ( hasNext ) { val t = current current += 1 t } else 0 } } val iterator = new IntIterator ( 10 ) println ( iterator . next ()) // prints 0 println ( iterator . next ()) // prints 1 Ejemplo: Subtipos \u00b6 Implementaci\u00f3n del polimorfismo de inclusi\u00f3n o herencia simple con traits: import scala.collection.mutable.ArrayBuffer trait Pet { val name : String } class Cat ( val name : String ) extends Pet class Dog ( val name : String ) extends Pet val dog = new Dog ( \"Harry\" ) val cat = new Cat ( \"Sally\" ) val animals = ArrayBuffer . empty [ Pet ] animals . append ( dog ) animals . append ( cat ) animals . foreach ( pet => println ( pet . name )) // Prints Harry Sally Ejemplo: Similarity \u00b6 trait Similarity { def isSimilar ( x : Any ) : Boolean def isNotSimilar ( x : Any ) : Boolean = ! isSimilar ( x ) } class Point ( xc : Int , yc : Int ) extends Similarity { var x : Int = xc var y : Int = yc def isSimilar ( obj : Any ) = obj . isInstanceOf [ Point ] && obj . asInstanceOf [ Point ]. x == x } object TraitsTest extends App { val p1 = new Point ( 2 , 3 ) val p2 = new Point ( 2 , 4 ) val p3 = new Point ( 3 , 3 ) println ( p1 . isNotSimilar ( p2 )) //false println ( p1 . isNotSimilar ( p3 )) //true println ( p1 . isNotSimilar ( 2 )) //true } El polimorfismo (de inclusi\u00f3n) usa la herencia (simple) Los mixin son un mecanismo de reutilizaci\u00f3n de c\u00f3digo sin herencia \u00bfUsar traits con comportamiento va contra el principio general de que la herencia de comportamiento es una mala idea? Odersky llama mixin traits a los traits con comportamiento Para ser un mixin genuino, deber\u00eda mezclar comportamiento y no interfaces heredadas Lectura recomendada: Scala mixins Leer Scala Mixins: The right way Ejemplo: Iterator \u00b6 C\u00f3mo reutilizar comportamiento de varios tipos de iteradores a trav\u00e9s de un mixin: abstract class AbsIterator { type T def hasNext : Boolean def next : T } trait RichIterator extends AbsIterator { def foreach ( f : T => Unit ) { while ( hasNext ) f ( next ) } } class IntIterator ( to : Int ) extends AbsIterator { type T = Int private var n = 0 def hasNext = n < to def next = { val t = n ; n += 1 ; t } } class StringIterator ( s : String ) extends AbsIterator { type T = Char private var i = 0 def hasNext = i < s . length () def next = { val ch = s charAt i ; i += 1 ; ch } } object StringIteratorTest { class Iter extends StringIterator ( \"HOLA\" ) with RichIterator val iter = new Iter iter foreach println } object IntIteratorTest { class Iter extends IntIterator ( 10 ) with RichIterator val iter = new Iter iter foreach println } La implementaci\u00f3n anterior usa polimorfismo param\u00e9trico ( type T ). Unit en scala: subtipo de AnyVal ; solo hay un valor () que es de tipo Unit . Un m\u00e9todo que devuelve Unit es an\u00e1logo a un m\u00e9todo Java que devuelve void Diferencia con clase abstracta \u00b6 Scala traits vs abstract classes Los constructores de un trait no pueden tener par\u00e1metros (de momento) Reglas \u00b6 To trait or not to trait Si no se va a reutilizar el comportamiento \u2192 clase concreta Si se va a reutilizar en varias clases no relacionadas entre s\u00ed \u2192 trait (mixin) Si hace falta heredarlo en c\u00f3digo Java \u2192 clase abstracta Si se va a distribuir compilado y se va a heredar \u2192 clase abstracta Si importa mucho la eficiencia \u2192 clase (los traits se compilan a interfaces y son algo m\u00e1s lentas de llamar) Si no se sabe \u2192 empezar por un trait y cambiarlo cuando se sepa Tutoriales y ejercicios recomendados: Scala Scala traits Ejemplo: Traits exercise Ejemplo: Stackable Traits pattern Herencia vs. composici\u00f3n con Scala mixins Scala tour Scala exercises","title":"Mixins"},{"location":"iiss-fp-3/#programacion-funcional","text":"","title":"Programaci\u00f3n funcional"},{"location":"iiss-fp-3/#mixins","text":"En POO, un mixin es una clase con m\u00e9todos disponibles para otras clases sin tener que ser madre de estas otras (es decir, sin usar la herencia) Es una alternativa a la herencia m\u00faltiple Incluye una interfaz con m\u00e9todos ya implementados No se heredan sino que se incluyen Un mixin es una (sub)clase, luego define un comportamiento y un estado Es una forma de implementar el principio de inversi\u00f3n de dependencias (DIP)","title":"Mixins"},{"location":"iiss-fp-3/#ruby-modules","text":"En Ruby los mixins se implementan mediante m\u00f3dulos ( module ). Un m\u00f3dulo no puede tener instancias (porque no es una clase) Un m\u00f3dulo puede incluirse ( include ) dentro de la definici\u00f3n de una clase","title":"Ruby modules"},{"location":"iiss-fp-3/#ejemplo-herencia-vs-mixins","text":"module Debug def whoAmI? \" #{ self . class . name } ( \\# #{ self . object_id } ): #{ self . to_s } \" end end class MusicWork def initialize ( title ) @title = title end def to_s @title end end class Phonograph < MusicWork include Debug end class EightTrack < MusicWork include Debug end ph = Phonograph . new ( \"West End Blues\" ) et = EightTrack . new ( \"Surrealistic Pillow\" ) ph . whoAmI? # => \"Phonograph (#70315984363660): West End Blues\" et . whoAmI? # => \"EightTrack (#70315996611260): Surrealistic Pillow\"","title":"Ejemplo: herencia vs mixins"},{"location":"iiss-fp-3/#ejemplo-comparable-en-scala","text":"En Scala se puede implementar el equivalente a la interfaz Comparable de Java mediante traits: trait Ord { def < ( that : Any ) : Boolean def <=( that : Any ) : Boolean = ( this < that ) || ( this == that ) def > ( that : Any ) : Boolean = !( this <= that ) def >=( that : Any ) : Boolean = !( this < that ) } class Fecha ( d : Int , m : Int , a : Int ) extends Ord { def anno = a def mes = m def dia = d override def toString () : String = s\" $dia - $mes - $anno \" override def equals ( that : Any ) : Boolean = that . isInstanceOf [ Fecha ] && { val o = that . asInstanceOf [ Fecha ] o . dia == dia && o . mes == mes && o . anno == anno } def <( that : Any ) : Boolean = { if (! that . isInstanceOf [ Fecha ]) sys . error ( \"no se puede comparar\" + that + \" y una fecha\" ) val o = that . asInstanceOf [ Fecha ] ( anno < o . anno ) || ( anno == o . anno && ( mes < o . mes || ( mes == o . mes && dia < o . dia ))) } } object MiApp { def main ( args : Array [ String ]) : Unit = { val f1 = new Fecha ( 12 , 4 , 2009 ) val f2 = new Fecha ( 12 , 4 , 2019 ) println ( s\" $f1 es posterior a $f2 ? ${ f1 >= f2 } \" ) } }","title":"Ejemplo: Comparable en scala"},{"location":"iiss-fp-3/#ejemplo-comparable-en-ruby","text":"Una manera de implementar un Comparable en ruby mediante el m\u00f3dulo Comparable : class Student include Comparable # The class Student 'inherits' Comparable module using include keyword attr_accessor :name , :score def initialize ( name , score ) @name = name @score = score end # Including the Comparison module, requires the implementing class to define the <=> comparison operator # Here's the comparison operator. We compare 2 student instances based on their scores. def <=> ( other ) @score <=> other . score end # Here's the good bit - I get access to <, <=, >,>= and other methods of the Comparable Interface for free. end s1 = Student . new ( \"Peter\" , 100 ) s2 = Student . new ( \"Jason\" , 90 ) s3 = Student . new ( \"Maria\" , 95 ) s1 > s2 #true s1 <= s2 #false s3 . between? ( s1 , s2 ) #true La clase que incluye el m\u00f3dulo Comparable tiene que implementar: el m\u00e9todo <=> : es un m\u00e9todo que incluye los siguientes operadores/m\u00e9todos: <, <=, ==, >, >=, between? el atributo-criterio de comparaci\u00f3n En x <=> y , x es el receptor del mensaje/m\u00e9todo e y es el argumento","title":"Ejemplo: Comparable en ruby"},{"location":"iiss-fp-3/#ejemplo-adaptador-de-interfaz-en-ruby","text":"Interfaz americana class Renderer def render ( text_object ) text = text_object . text size = text_object . size_inches color = text_object . color # render the text ... end end class TextObject attr_reader :text , :size_inches , :color def initialize ( text , size_inches , color ) @text = text @size_inches = size_inches @color = color end end Interfaz brit\u00e1nica ## british_text_object.rb class BritishTextObject attr_reader :string , :size_mm , :colour # ... end Adaptador de interfaz: versi\u00f3n cl\u00e1sica class BritishTextObjectAdapter < TextObject def initialize ( bto ) @bto = bto end def text return @bto . string end def size_inches return @bto . size_mm / 25 . 4 end def color return @bto . colour end end","title":"Ejemplo: Adaptador de interfaz en Ruby"},{"location":"iiss-fp-3/#adaptador-de-interfaz-version-con-modulos","text":"## Make sure the original class is loaded require 'british_text_object' ## Now add some methods to the original class class BritishTextObject def color return colour end def text return string end def size_inches return size_mm / 25 . 4 end end require carga la clase original la reescritura de m\u00e9todos modifica la clase, no la declara de nuevo se puede hacer incluso con las clases built-in de la biblioteca de Ruby","title":"Adaptador de interfaz: versi\u00f3n con m\u00f3dulos"},{"location":"iiss-fp-3/#adaptador-de-interfaz-instancia-unica","text":"bto = BritishTextObject . new ( 'hello' , 50 . 8 , :blue ) class << bto def color colour end def text string end def size_inches return size_mm / 25 . 4 end end o bien: def bto . color colour end def bto . text string end ## ... Modifica el comportamiento solo de 1 instancia Ruby llama a esto singleton methods y singleton class (no es exactamente lo mismo que el patr\u00f3n singleton del GoF) Ruby primero busca los m\u00e9todos definidos en una clase singleton y luego en la clase regular que ha sido redefinida Tutoriales y ejercicios recomendados: Ruby Ruby from other languages Tutorial: Ruby modules","title":"Adaptador de interfaz: instancia \u00fanica"},{"location":"iiss-fp-3/#scala-traits","text":"Un trait es una forma de separar las dos principales responsabilidades de una clase: definir el estado de sus instancias y definir su comportamiento . Las clases y los objetos en Scala pueden extender un trait Los trait de Scala son similares a las interface de Java. Java default methods Desde Java 8, las interfaces pueden incorporar m\u00e9todos por defecto que hacen que las interfaces de Java se comporten m\u00e1s como un trait. Sirven para implementar herencia m\u00faltiple Los trait no pueden instanciarse Los m\u00e9todos definidos en una clase tienen precedencia sobre los de un trait Los trait no tienen estado propio, sino el del objeto o la instancia de la clase a la que se aplica","title":"Scala Traits"},{"location":"iiss-fp-3/#ejemplo-iterador-como-un-trait","text":"trait Iterator [ A ] { def hasNext : Boolean def next () : A } class IntIterator ( to : Int ) extends Iterator [ Int ] { private var current = 0 override def hasNext : Boolean = current < to override def next () : Int = { if ( hasNext ) { val t = current current += 1 t } else 0 } } val iterator = new IntIterator ( 10 ) println ( iterator . next ()) // prints 0 println ( iterator . next ()) // prints 1","title":"Ejemplo: Iterador como un trait"},{"location":"iiss-fp-3/#ejemplo-subtipos","text":"Implementaci\u00f3n del polimorfismo de inclusi\u00f3n o herencia simple con traits: import scala.collection.mutable.ArrayBuffer trait Pet { val name : String } class Cat ( val name : String ) extends Pet class Dog ( val name : String ) extends Pet val dog = new Dog ( \"Harry\" ) val cat = new Cat ( \"Sally\" ) val animals = ArrayBuffer . empty [ Pet ] animals . append ( dog ) animals . append ( cat ) animals . foreach ( pet => println ( pet . name )) // Prints Harry Sally","title":"Ejemplo: Subtipos"},{"location":"iiss-fp-3/#ejemplo-similarity","text":"trait Similarity { def isSimilar ( x : Any ) : Boolean def isNotSimilar ( x : Any ) : Boolean = ! isSimilar ( x ) } class Point ( xc : Int , yc : Int ) extends Similarity { var x : Int = xc var y : Int = yc def isSimilar ( obj : Any ) = obj . isInstanceOf [ Point ] && obj . asInstanceOf [ Point ]. x == x } object TraitsTest extends App { val p1 = new Point ( 2 , 3 ) val p2 = new Point ( 2 , 4 ) val p3 = new Point ( 3 , 3 ) println ( p1 . isNotSimilar ( p2 )) //false println ( p1 . isNotSimilar ( p3 )) //true println ( p1 . isNotSimilar ( 2 )) //true } El polimorfismo (de inclusi\u00f3n) usa la herencia (simple) Los mixin son un mecanismo de reutilizaci\u00f3n de c\u00f3digo sin herencia \u00bfUsar traits con comportamiento va contra el principio general de que la herencia de comportamiento es una mala idea? Odersky llama mixin traits a los traits con comportamiento Para ser un mixin genuino, deber\u00eda mezclar comportamiento y no interfaces heredadas Lectura recomendada: Scala mixins Leer Scala Mixins: The right way","title":"Ejemplo: Similarity"},{"location":"iiss-fp-3/#ejemplo-iterator","text":"C\u00f3mo reutilizar comportamiento de varios tipos de iteradores a trav\u00e9s de un mixin: abstract class AbsIterator { type T def hasNext : Boolean def next : T } trait RichIterator extends AbsIterator { def foreach ( f : T => Unit ) { while ( hasNext ) f ( next ) } } class IntIterator ( to : Int ) extends AbsIterator { type T = Int private var n = 0 def hasNext = n < to def next = { val t = n ; n += 1 ; t } } class StringIterator ( s : String ) extends AbsIterator { type T = Char private var i = 0 def hasNext = i < s . length () def next = { val ch = s charAt i ; i += 1 ; ch } } object StringIteratorTest { class Iter extends StringIterator ( \"HOLA\" ) with RichIterator val iter = new Iter iter foreach println } object IntIteratorTest { class Iter extends IntIterator ( 10 ) with RichIterator val iter = new Iter iter foreach println } La implementaci\u00f3n anterior usa polimorfismo param\u00e9trico ( type T ). Unit en scala: subtipo de AnyVal ; solo hay un valor () que es de tipo Unit . Un m\u00e9todo que devuelve Unit es an\u00e1logo a un m\u00e9todo Java que devuelve void","title":"Ejemplo: Iterator"},{"location":"iiss-fp-3/#diferencia-con-clase-abstracta","text":"Scala traits vs abstract classes Los constructores de un trait no pueden tener par\u00e1metros (de momento)","title":"Diferencia con clase abstracta"},{"location":"iiss-fp-3/#reglas","text":"To trait or not to trait Si no se va a reutilizar el comportamiento \u2192 clase concreta Si se va a reutilizar en varias clases no relacionadas entre s\u00ed \u2192 trait (mixin) Si hace falta heredarlo en c\u00f3digo Java \u2192 clase abstracta Si se va a distribuir compilado y se va a heredar \u2192 clase abstracta Si importa mucho la eficiencia \u2192 clase (los traits se compilan a interfaces y son algo m\u00e1s lentas de llamar) Si no se sabe \u2192 empezar por un trait y cambiarlo cuando se sepa Tutoriales y ejercicios recomendados: Scala Scala traits Ejemplo: Traits exercise Ejemplo: Stackable Traits pattern Herencia vs. composici\u00f3n con Scala mixins Scala tour Scala exercises","title":"Reglas"},{"location":"iiss-oop-1/","text":"OBJETOS - Principios Caso 1 - Recorrido de listas \u00b6 Ocultaci\u00f3n de la implementaci\u00f3n \u00b6 Versi\u00f3n inicial: Lista v0.1 \u00b6 Abstracci\u00f3n : La clase abstracta List<T> diferencia entre el qu\u00e9 y el c\u00f3mo : Qu\u00e9 hace la lista vs. c\u00f3mo se almacenan los elementos Criticar la implementaci\u00f3n siguiente: public abstract class List < T > { public void addFirst ( T value ) { ... }; public void removeFirst () { ... }; public void addLast ( T value ) { ... }; public void removeLast () { ... }; public T first () { ... }; public T last () { ... }; public boolean isEmpty () { ... }; public int length () { ... }; public List < T > clone () { ... }; public boolean isEqualTo ( List < T > ) { ... }; public abstract void traverse (); // etc... } Cohesi\u00f3n \u00b6 Cohesion refers to the degree to which the elements inside a module belong together -- E. Yourdon & L. Constantine Cr\u00edticas a Lista v0.1 \u00b6 List<T> aglutina m\u00e1s de una responsabilidad: almacenar y recorrer. Implementaci\u00f3n no cohesionada \u00bfQu\u00e9 hace traverse() ? Proporciona una interfaz a los m\u00e9todos que implementen el recorrido de la lista \u00bfpara hacer qu\u00e9? \u00bfY si hay distintas implementaciones de traverse() ? Si implementamos varias versiones de la lista, introducimos m\u00e1s dependencias (acoplamiento) Problem\u00e1ticas de Lista v0.1 \u00b6 Baja cohesi\u00f3n Alta variabilidad no bien tratada \u2192 poca flexibilidad Implementaci\u00f3n alternativa: Lista v0.2 \u00b6 Hay que crear nuevos tipos de recorrido. Ampliamos la interfaz... public interface List < T > { public void addFirst ( T value ); public void removeFirst (); public void addLast ( T value ); public void removeLast (); public T first (); public T last (); public boolean isEmpty (); public int length (); public List < T > clone (); public boolean isEqualTo ( List < T > ); public void traverseForward (); public void traverseBackWard (); public void traverseEvens (); //pares public void traverseOdds (); //impares // etc... } Cr\u00edticas a Lista v0.2 \u00b6 Si hay que cambiar la operaci\u00f3n b\u00e1sica que hace traverse() con cada elemento (imprimir, sumar, etc.), \u00bfcu\u00e1ntos m\u00e9todos hay que cambiar? Hay muchas dependencias Cuanto m\u00e1s variedad de recorridos (la interfaz es mayor), menos flexibilidad para los cambios. Implementaci\u00f3n poco flexible Problem\u00e1ticas de Lista v0.2 \u00b6 Muchas dependencias (provocadas por el exceso de herencia) \u2192 excesivo acoplamiento Poca flexibilidad Implementaci\u00f3n alternativa: Lista v0.3 \u00b6 Delegar funcionalidad hacia las subclases (v\u00eda herencia ). Criticar la implementaci\u00f3n: class ListForward < T > extends List < T > { //... public void traverse () { // recorrer hacia adelante }; } class ListBackward < T > extends List < T > { //... public void traverse () { // recorrer hacia atras}; } Cr\u00edticas a Lista v0.3 \u00b6 \u00bfHay que especializar de nuevo para cada tipo de operaci\u00f3n que hace traverse() con cada elemento individual (imprimir, sumar, etc.)? \u00bfY si hay que especializar de nuevo el recorrido: s\u00f3lo los pares, s\u00f3lo los impares, etc.? Problem\u00e1ticas de Lista v0.3 \u00b6 Elevada complejidad . Si hay que crear nuevos tipos de recorrido, se abusar\u00e1 de la herencia como estructura La variabilidad no est\u00e1 bien tratada \u2192 poca flexibilidad , mala reutilizaci\u00f3n Implementaci\u00f3n alternativa: Lista v0.4 \u00b6 Delegar hacia otra clase public interface List < T > { void addFirst ( T value ); void removeFirst (); void addLast ( T value ); void removeLast (); T first (); T last (); boolean isEmpty (); int length (); List < T > clone (); boolean isEqualTo ( List < T > ); Iterator < T > iterator (); } public interface Iterator < E > { boolean hasNext (); E next (); void remove (); } Ventajas \u00b6 Mayor cohesi\u00f3n : Las responsabilidades est\u00e1n ahora separadas: List almacena, Iterator recorre. List est\u00e1 m\u00e1s cohesionada Para hacer List m\u00e1s cohesionada, se ha tenido que introducir una dependencia (acoplamiento) Uso de delegaci\u00f3n (o composici\u00f3n ) en lugar de la herencia: la responsabilidad de recorrer se ha delegado hacia otro sitio Ocultar la implementaci\u00f3n \u00b6 Los principios aplicados han sido: Abstracci\u00f3n : diferenciar el qu\u00e9 y el c\u00f3mo Cohesi\u00f3n (maximizar): m\u00f3dulos auto-contenidos, independientes y con un \u00fanico prop\u00f3sito Acoplamiento (minimizar): dependencias entre m\u00f3dulos Modularidad : clases, interfaces y componentes/m\u00f3dulos Alta cohesi\u00f3n, bajo acoplamiento \u00b6 Cuando los componentes est\u00e1n aislados, puedes cambiar uno sin preocuparte por el resto. Mientras no cambies las interfaces externas, no habr\u00e1 problemas en el resto del sistema -- Eric Yourdon Modularidad \u00b6 Reducir el acoplamiento usando m\u00f3dulos o componentes con distintas responsabilidades, agrupados en bibliotecas T\u00e9cnicas de ocultaci\u00f3n \u00b6 Hay diversas t\u00e9cnicas para ocultar la implementaci\u00f3n... Encapsular : agrupar en m\u00f3dulos y clases Visibilidad : public , private , protected , etc. Delegaci\u00f3n : incrementar la cohesi\u00f3n extrayendo funcionalidad pensada para otros prop\u00f3sitos fuera de un m\u00f3dulo Herencia : delegar en vertical Polimorfismo : ocultar la implementaci\u00f3n de un m\u00e9todo, manteniendo la misma interfaz de la clase base Interfaces : usar interfaces bien documentadas Herencia: generalizaci\u00f3n y especializaci\u00f3n \u00b6 Reutilizar la interfaz Clase base y derivada son del mismo tipo Todas las operaciones de la clase base est\u00e1n tambi\u00e9n disponibles en la derivada Redefinir vs. reutilizar el comportamiento Overriding (redefinici\u00f3n o sobreescritura): cambio de comportamiento Overloading (sobrecarga): cambio de interfaz Herencia pura vs. extensi\u00f3n Herencia pura: mantiene la interfaz tal cual (relaci\u00f3n es-un ) Extensi\u00f3n: ampl\u00eda la interfaz con nuevas funcionalidades(relaci\u00f3n es-como-un ). Puede causar problemas de casting . When you inherit, you take an existing class and make a special version of it. In general, this means that you\u2019re taking a general-purpose class and specializing it for a particular need. [...] it would make no sense to compose a car using a vehicle object \u2014a car doesn\u2019t contain a vehicle, it is a vehicle. The is-a relationship is expressed with inheritance, and the has-a relationship is expressed with composition. -- Bruce Eckel Polimorfismo \u00b6 Fen\u00f3meno por el que, cuando se llama a una operaci\u00f3n de un objeto del que no se sabe su tipo espec\u00edfico, se ejecuta el m\u00e9todo adecuado de acuerdo con su tipo. El polimorfismo se basa en: Enlace din\u00e1mico ( dynamic binding ): se elige el m\u00e9todo a ejecutar en tiempo de ejecuci\u00f3n, en funci\u00f3n de la clase de objeto; es la implementaci\u00f3n del polimorfismo Moldes ( casting ) Upcasting : Interpretar un objeto de una clase derivada como del mismo tipo que la clase base Downcasting : Interpretar un objeto de una clase base como del mismo tipo que una clase derivada suya Overriding \u00b6 En general, en un lenguaje OO es posible sobreescribir o redefinir ( override ) los m\u00e9todos heredados de una superclase. En algunos lenguajes es obligatorio (en otros es recomendado) especificar expl\u00edcitamente cu\u00e1ndo un m\u00e9todo es redefinido. Ejemplo en Scala \u00b6 class Complejo ( real : Double , imaginaria : Double ) { def re = real def im = imaginaria override def toString () = \"\" + re + ( if ( im < 0 ) \"\" else \"+\" ) + im + \"i\" } Ejemplo en Java \u00b6 \u00bfQu\u00e9 sucede si no ponemos @Override a los m\u00e9todos redefinidos? Disclaimer Este ejemplo en Java es realmente la implementaci\u00f3n de un dise\u00f1o incorrecto, pues hay una doble dependencia entre las clases Real y Complejo . La frontera entre Dise\u00f1o e Implementaci\u00f3n queda aqu\u00ed un poco difusa. class Real { double re ; public Real ( double real ) { re = real ; } public double getRe () { return re ; } /* Probar a comentar el siguiente m\u00e9todo y mantener el Override de Complejo::sum(Real other) */ public Real sum ( Real other ) { return new Real ( re + other . getRe ()); } /* Probar a comentar el siguiente m\u00e9todo y mantener el Override de Complejo::sum(Complejo other) */ public Complejo sum ( Complejo other ) { return new Complejo ( re + other . getRe (), other . getIm () ); } public String toString () { return String . format ( \"%.1f\" , re ); } } class Complejo extends Real { double im ; public Complejo ( double real , double imaginaria ) { super ( real ); im = imaginaria ; } @Override public Complejo sum ( Real other ) { return new Complejo ( re + other . getRe (), im ); } @Override public Complejo sum ( Complejo other ) { return new Complejo ( re + other . getRe (), im + other . getIm () ); } public Double getIm () { return im ; } public String toString () { return String . format ( \"%.1f\" , re ) + (( im < 0 ) ? \"\" : \"+\" ) + String . format ( \"%.1f\" , im ) + \"i\" ; } } public class MyClass { public static void main ( String args [] ) { Real r = new Real ( 7.6 ); Complejo c = new Complejo ( 1.2 , 3.4 ); System . out . println ( \"N\u00famero real: \" + r ); System . out . println ( \"N\u00famero complejo: \" + c ); System . out . println ( \"N\u00famero complejo: \" + c . sum ( r ) ); System . out . println ( \"N\u00famero complejo: \" + r . sum ( c ) ); } } Si no se a\u00f1ade @Override , podemos llegar a confundirnos y hacer sobrecarga cuando quer\u00edamos haber hecho sobreescritura. Casting \u00b6 Ejemplo: Aventura v0.1 \u00b6 public class PersonajeDeAccion { public void luchar () {} } public class Heroe extends PersonajeDeAccion { public void luchar () {} public void volar () {} } public class Creador { PersonajeDeAccion [] personajes () { PersonajeDeAccion [] x = { new PersonajeDeAccion (), new PersonajeDeAccion (), new Heroe (), new PersonajeDeAccion () }; return x ; } } public class Aventura { public static void main ( String [] args ) { PersonajeDeAccion [] cuatroFantasticos = new Creador (). personajes (); cuatroFantasticos [ 1 ] . luchar (); cuatroFantasticos [ 2 ] . luchar (); // Upcast // En tiempo de compilacion: metodo no encontrado: //! cuatroFantasticos[2].volar(); (( Heroe ) cuatroFantasticos [ 2 ] ). volar (); // Downcast (( Heroe ) cuatroFantasticos [ 1 ] ). volar (); // ClassCastException for ( PersonajeDeAccion p : cuatroFantasticos ) p . luchar ; // Sin problema for ( PersonajeDeAccion p : cuatroFantasticos ) p . volar ; // El 0, 1 y 3 van a lanzar ClassCastException } } Cr\u00edticas a Aventura v0.1 \u00b6 \u00bfDe qu\u00e9 tipos van a ser los personales de acci\u00f3n? \u2192 problema de downcasting Hay que redise\u00f1ar la soluci\u00f3n por ser insegura interface SabeLuchar { void luchar (); } interface SabeNadar { void nadar (); } interface SabeVolar { void volar (); } class PersonajeDeAccion { public void luchar () {} } class Heroe extends PersonajeDeAccion implements SabeLuchar , SabeNadar , SabeVolar { public void nadar () {} public void volar () {} } public class Aventura { static void t ( SabeLuchar x ) { x . luchar (); } static void u ( SabeNadar x ) { x . nadar (); } static void v ( SabeVolar x ) { x . volar (); } static void w ( PersonajeDeAccion x ) { x . luchar (); } public static void main ( String [] args ) { Heroe i = new Heroe (); t ( i ); // Tratar como un SabeLuchar u ( i ); // Tratar como un SabeNadar v ( i ); // Tratar como un SabeVolar w ( i ); // Tratar como un PersonajeDeAccion } } Uso correcto de la herencia \u00b6 Hay dos formas de contemplar la herencia: Como tipo : Las clases son tipos y las subclases son subtipos Las clases satisfacen el principio de sustituci\u00f3n de Liskov (LSP, Liskov Substitution Principle ): toda operaci\u00f3n que funciona para un objeto de la clase C tambi\u00e9n debe funcionar para un objeto de una subclase de C Como estructura : La herencia se usa como una forma de estructurar programas Esta visi\u00f3n es err\u00f3nea , pues provoca que no se satisfaga la propiedad LSP Ejemplo: herencia como estructura \u00b6 class Account { float balance ; float getBalance () { return balance ; } void transferIn ( float amount ) { balance -= amount ; } } class VerboseAccount extends Account { void verboseTransferIn ( float amount ) { super . transferIn ( amount ); System . out . println ( \"Balance: \" + balance ); }; } class AccountWithFee extends VerboseAccount { float fee = 1 ; void transferIn ( float amount ) { super . verboseTransferIn ( amount - fee ); } } Todos los objetos a a de la clase Account deben cumplir que si b=a.getBalance() b=a.getBalance() antes de ejecutar a.transferIn(s) a.transferIn(s) y b\u00b4=a.getBalance() b\u00b4=a.getBalance() despu\u00e9s de ejecutar a.transferIn(s) a.transferIn(s) , entonces b+s=b\u00b4 b+s=b\u00b4 . Sin embargo, con la estructura AccountWithFee < VerboseAccount < Account , un objeto de tipo AccountWithFee no funciona bien cuando se contempla como un objeto Account . Consid\u00e9rese la siguiente secuencia: void f ( Account a ) { float before = a . getBalance (); a . transferIn ( 10 ); float after = a . getBalance (); // Suppose a is of type AccountWithFee: // before + 10 != after !! // before + 10-1 = after }","title":"Principios"},{"location":"iiss-oop-1/#caso-1-recorrido-de-listas","text":"","title":"Caso 1 - Recorrido de listas"},{"location":"iiss-oop-1/#ocultacion-de-la-implementacion","text":"","title":"Ocultaci\u00f3n de la implementaci\u00f3n"},{"location":"iiss-oop-1/#version-inicial-lista-v01","text":"Abstracci\u00f3n : La clase abstracta List<T> diferencia entre el qu\u00e9 y el c\u00f3mo : Qu\u00e9 hace la lista vs. c\u00f3mo se almacenan los elementos Criticar la implementaci\u00f3n siguiente: public abstract class List < T > { public void addFirst ( T value ) { ... }; public void removeFirst () { ... }; public void addLast ( T value ) { ... }; public void removeLast () { ... }; public T first () { ... }; public T last () { ... }; public boolean isEmpty () { ... }; public int length () { ... }; public List < T > clone () { ... }; public boolean isEqualTo ( List < T > ) { ... }; public abstract void traverse (); // etc... }","title":"Versi\u00f3n inicial: Lista v0.1"},{"location":"iiss-oop-1/#cohesion","text":"Cohesion refers to the degree to which the elements inside a module belong together -- E. Yourdon & L. Constantine","title":"Cohesi\u00f3n"},{"location":"iiss-oop-1/#criticas-a-lista-v01","text":"List<T> aglutina m\u00e1s de una responsabilidad: almacenar y recorrer. Implementaci\u00f3n no cohesionada \u00bfQu\u00e9 hace traverse() ? Proporciona una interfaz a los m\u00e9todos que implementen el recorrido de la lista \u00bfpara hacer qu\u00e9? \u00bfY si hay distintas implementaciones de traverse() ? Si implementamos varias versiones de la lista, introducimos m\u00e1s dependencias (acoplamiento)","title":"Cr\u00edticas a Lista v0.1"},{"location":"iiss-oop-1/#problematicas-de-lista-v01","text":"Baja cohesi\u00f3n Alta variabilidad no bien tratada \u2192 poca flexibilidad","title":"Problem\u00e1ticas de Lista v0.1"},{"location":"iiss-oop-1/#implementacion-alternativa-lista-v02","text":"Hay que crear nuevos tipos de recorrido. Ampliamos la interfaz... public interface List < T > { public void addFirst ( T value ); public void removeFirst (); public void addLast ( T value ); public void removeLast (); public T first (); public T last (); public boolean isEmpty (); public int length (); public List < T > clone (); public boolean isEqualTo ( List < T > ); public void traverseForward (); public void traverseBackWard (); public void traverseEvens (); //pares public void traverseOdds (); //impares // etc... }","title":"Implementaci\u00f3n alternativa: Lista v0.2"},{"location":"iiss-oop-1/#criticas-a-lista-v02","text":"Si hay que cambiar la operaci\u00f3n b\u00e1sica que hace traverse() con cada elemento (imprimir, sumar, etc.), \u00bfcu\u00e1ntos m\u00e9todos hay que cambiar? Hay muchas dependencias Cuanto m\u00e1s variedad de recorridos (la interfaz es mayor), menos flexibilidad para los cambios. Implementaci\u00f3n poco flexible","title":"Cr\u00edticas a Lista v0.2"},{"location":"iiss-oop-1/#problematicas-de-lista-v02","text":"Muchas dependencias (provocadas por el exceso de herencia) \u2192 excesivo acoplamiento Poca flexibilidad","title":"Problem\u00e1ticas de Lista v0.2"},{"location":"iiss-oop-1/#implementacion-alternativa-lista-v03","text":"Delegar funcionalidad hacia las subclases (v\u00eda herencia ). Criticar la implementaci\u00f3n: class ListForward < T > extends List < T > { //... public void traverse () { // recorrer hacia adelante }; } class ListBackward < T > extends List < T > { //... public void traverse () { // recorrer hacia atras}; }","title":"Implementaci\u00f3n alternativa: Lista v0.3"},{"location":"iiss-oop-1/#criticas-a-lista-v03","text":"\u00bfHay que especializar de nuevo para cada tipo de operaci\u00f3n que hace traverse() con cada elemento individual (imprimir, sumar, etc.)? \u00bfY si hay que especializar de nuevo el recorrido: s\u00f3lo los pares, s\u00f3lo los impares, etc.?","title":"Cr\u00edticas a Lista v0.3"},{"location":"iiss-oop-1/#problematicas-de-lista-v03","text":"Elevada complejidad . Si hay que crear nuevos tipos de recorrido, se abusar\u00e1 de la herencia como estructura La variabilidad no est\u00e1 bien tratada \u2192 poca flexibilidad , mala reutilizaci\u00f3n","title":"Problem\u00e1ticas de Lista v0.3"},{"location":"iiss-oop-1/#implementacion-alternativa-lista-v04","text":"Delegar hacia otra clase public interface List < T > { void addFirst ( T value ); void removeFirst (); void addLast ( T value ); void removeLast (); T first (); T last (); boolean isEmpty (); int length (); List < T > clone (); boolean isEqualTo ( List < T > ); Iterator < T > iterator (); } public interface Iterator < E > { boolean hasNext (); E next (); void remove (); }","title":"Implementaci\u00f3n alternativa: Lista v0.4"},{"location":"iiss-oop-1/#ventajas","text":"Mayor cohesi\u00f3n : Las responsabilidades est\u00e1n ahora separadas: List almacena, Iterator recorre. List est\u00e1 m\u00e1s cohesionada Para hacer List m\u00e1s cohesionada, se ha tenido que introducir una dependencia (acoplamiento) Uso de delegaci\u00f3n (o composici\u00f3n ) en lugar de la herencia: la responsabilidad de recorrer se ha delegado hacia otro sitio","title":"Ventajas"},{"location":"iiss-oop-1/#ocultar-la-implementacion","text":"Los principios aplicados han sido: Abstracci\u00f3n : diferenciar el qu\u00e9 y el c\u00f3mo Cohesi\u00f3n (maximizar): m\u00f3dulos auto-contenidos, independientes y con un \u00fanico prop\u00f3sito Acoplamiento (minimizar): dependencias entre m\u00f3dulos Modularidad : clases, interfaces y componentes/m\u00f3dulos","title":"Ocultar la implementaci\u00f3n"},{"location":"iiss-oop-1/#alta-cohesion-bajo-acoplamiento","text":"Cuando los componentes est\u00e1n aislados, puedes cambiar uno sin preocuparte por el resto. Mientras no cambies las interfaces externas, no habr\u00e1 problemas en el resto del sistema -- Eric Yourdon","title":"Alta cohesi\u00f3n, bajo acoplamiento"},{"location":"iiss-oop-1/#modularidad","text":"Reducir el acoplamiento usando m\u00f3dulos o componentes con distintas responsabilidades, agrupados en bibliotecas","title":"Modularidad"},{"location":"iiss-oop-1/#tecnicas-de-ocultacion","text":"Hay diversas t\u00e9cnicas para ocultar la implementaci\u00f3n... Encapsular : agrupar en m\u00f3dulos y clases Visibilidad : public , private , protected , etc. Delegaci\u00f3n : incrementar la cohesi\u00f3n extrayendo funcionalidad pensada para otros prop\u00f3sitos fuera de un m\u00f3dulo Herencia : delegar en vertical Polimorfismo : ocultar la implementaci\u00f3n de un m\u00e9todo, manteniendo la misma interfaz de la clase base Interfaces : usar interfaces bien documentadas","title":"T\u00e9cnicas de ocultaci\u00f3n"},{"location":"iiss-oop-1/#herencia-generalizacion-y-especializacion","text":"Reutilizar la interfaz Clase base y derivada son del mismo tipo Todas las operaciones de la clase base est\u00e1n tambi\u00e9n disponibles en la derivada Redefinir vs. reutilizar el comportamiento Overriding (redefinici\u00f3n o sobreescritura): cambio de comportamiento Overloading (sobrecarga): cambio de interfaz Herencia pura vs. extensi\u00f3n Herencia pura: mantiene la interfaz tal cual (relaci\u00f3n es-un ) Extensi\u00f3n: ampl\u00eda la interfaz con nuevas funcionalidades(relaci\u00f3n es-como-un ). Puede causar problemas de casting . When you inherit, you take an existing class and make a special version of it. In general, this means that you\u2019re taking a general-purpose class and specializing it for a particular need. [...] it would make no sense to compose a car using a vehicle object \u2014a car doesn\u2019t contain a vehicle, it is a vehicle. The is-a relationship is expressed with inheritance, and the has-a relationship is expressed with composition. -- Bruce Eckel","title":"Herencia: generalizaci\u00f3n y especializaci\u00f3n"},{"location":"iiss-oop-1/#polimorfismo","text":"Fen\u00f3meno por el que, cuando se llama a una operaci\u00f3n de un objeto del que no se sabe su tipo espec\u00edfico, se ejecuta el m\u00e9todo adecuado de acuerdo con su tipo. El polimorfismo se basa en: Enlace din\u00e1mico ( dynamic binding ): se elige el m\u00e9todo a ejecutar en tiempo de ejecuci\u00f3n, en funci\u00f3n de la clase de objeto; es la implementaci\u00f3n del polimorfismo Moldes ( casting ) Upcasting : Interpretar un objeto de una clase derivada como del mismo tipo que la clase base Downcasting : Interpretar un objeto de una clase base como del mismo tipo que una clase derivada suya","title":"Polimorfismo"},{"location":"iiss-oop-1/#overriding","text":"En general, en un lenguaje OO es posible sobreescribir o redefinir ( override ) los m\u00e9todos heredados de una superclase. En algunos lenguajes es obligatorio (en otros es recomendado) especificar expl\u00edcitamente cu\u00e1ndo un m\u00e9todo es redefinido.","title":"Overriding"},{"location":"iiss-oop-1/#ejemplo-en-scala","text":"class Complejo ( real : Double , imaginaria : Double ) { def re = real def im = imaginaria override def toString () = \"\" + re + ( if ( im < 0 ) \"\" else \"+\" ) + im + \"i\" }","title":"Ejemplo en Scala"},{"location":"iiss-oop-1/#ejemplo-en-java","text":"\u00bfQu\u00e9 sucede si no ponemos @Override a los m\u00e9todos redefinidos? Disclaimer Este ejemplo en Java es realmente la implementaci\u00f3n de un dise\u00f1o incorrecto, pues hay una doble dependencia entre las clases Real y Complejo . La frontera entre Dise\u00f1o e Implementaci\u00f3n queda aqu\u00ed un poco difusa. class Real { double re ; public Real ( double real ) { re = real ; } public double getRe () { return re ; } /* Probar a comentar el siguiente m\u00e9todo y mantener el Override de Complejo::sum(Real other) */ public Real sum ( Real other ) { return new Real ( re + other . getRe ()); } /* Probar a comentar el siguiente m\u00e9todo y mantener el Override de Complejo::sum(Complejo other) */ public Complejo sum ( Complejo other ) { return new Complejo ( re + other . getRe (), other . getIm () ); } public String toString () { return String . format ( \"%.1f\" , re ); } } class Complejo extends Real { double im ; public Complejo ( double real , double imaginaria ) { super ( real ); im = imaginaria ; } @Override public Complejo sum ( Real other ) { return new Complejo ( re + other . getRe (), im ); } @Override public Complejo sum ( Complejo other ) { return new Complejo ( re + other . getRe (), im + other . getIm () ); } public Double getIm () { return im ; } public String toString () { return String . format ( \"%.1f\" , re ) + (( im < 0 ) ? \"\" : \"+\" ) + String . format ( \"%.1f\" , im ) + \"i\" ; } } public class MyClass { public static void main ( String args [] ) { Real r = new Real ( 7.6 ); Complejo c = new Complejo ( 1.2 , 3.4 ); System . out . println ( \"N\u00famero real: \" + r ); System . out . println ( \"N\u00famero complejo: \" + c ); System . out . println ( \"N\u00famero complejo: \" + c . sum ( r ) ); System . out . println ( \"N\u00famero complejo: \" + r . sum ( c ) ); } } Si no se a\u00f1ade @Override , podemos llegar a confundirnos y hacer sobrecarga cuando quer\u00edamos haber hecho sobreescritura.","title":"Ejemplo en Java"},{"location":"iiss-oop-1/#casting","text":"","title":"Casting"},{"location":"iiss-oop-1/#ejemplo-aventura-v01","text":"public class PersonajeDeAccion { public void luchar () {} } public class Heroe extends PersonajeDeAccion { public void luchar () {} public void volar () {} } public class Creador { PersonajeDeAccion [] personajes () { PersonajeDeAccion [] x = { new PersonajeDeAccion (), new PersonajeDeAccion (), new Heroe (), new PersonajeDeAccion () }; return x ; } } public class Aventura { public static void main ( String [] args ) { PersonajeDeAccion [] cuatroFantasticos = new Creador (). personajes (); cuatroFantasticos [ 1 ] . luchar (); cuatroFantasticos [ 2 ] . luchar (); // Upcast // En tiempo de compilacion: metodo no encontrado: //! cuatroFantasticos[2].volar(); (( Heroe ) cuatroFantasticos [ 2 ] ). volar (); // Downcast (( Heroe ) cuatroFantasticos [ 1 ] ). volar (); // ClassCastException for ( PersonajeDeAccion p : cuatroFantasticos ) p . luchar ; // Sin problema for ( PersonajeDeAccion p : cuatroFantasticos ) p . volar ; // El 0, 1 y 3 van a lanzar ClassCastException } }","title":"Ejemplo: Aventura v0.1"},{"location":"iiss-oop-1/#criticas-a-aventura-v01","text":"\u00bfDe qu\u00e9 tipos van a ser los personales de acci\u00f3n? \u2192 problema de downcasting Hay que redise\u00f1ar la soluci\u00f3n por ser insegura interface SabeLuchar { void luchar (); } interface SabeNadar { void nadar (); } interface SabeVolar { void volar (); } class PersonajeDeAccion { public void luchar () {} } class Heroe extends PersonajeDeAccion implements SabeLuchar , SabeNadar , SabeVolar { public void nadar () {} public void volar () {} } public class Aventura { static void t ( SabeLuchar x ) { x . luchar (); } static void u ( SabeNadar x ) { x . nadar (); } static void v ( SabeVolar x ) { x . volar (); } static void w ( PersonajeDeAccion x ) { x . luchar (); } public static void main ( String [] args ) { Heroe i = new Heroe (); t ( i ); // Tratar como un SabeLuchar u ( i ); // Tratar como un SabeNadar v ( i ); // Tratar como un SabeVolar w ( i ); // Tratar como un PersonajeDeAccion } }","title":"Cr\u00edticas a Aventura v0.1"},{"location":"iiss-oop-1/#uso-correcto-de-la-herencia","text":"Hay dos formas de contemplar la herencia: Como tipo : Las clases son tipos y las subclases son subtipos Las clases satisfacen el principio de sustituci\u00f3n de Liskov (LSP, Liskov Substitution Principle ): toda operaci\u00f3n que funciona para un objeto de la clase C tambi\u00e9n debe funcionar para un objeto de una subclase de C Como estructura : La herencia se usa como una forma de estructurar programas Esta visi\u00f3n es err\u00f3nea , pues provoca que no se satisfaga la propiedad LSP","title":"Uso correcto de la herencia"},{"location":"iiss-oop-1/#ejemplo-herencia-como-estructura","text":"class Account { float balance ; float getBalance () { return balance ; } void transferIn ( float amount ) { balance -= amount ; } } class VerboseAccount extends Account { void verboseTransferIn ( float amount ) { super . transferIn ( amount ); System . out . println ( \"Balance: \" + balance ); }; } class AccountWithFee extends VerboseAccount { float fee = 1 ; void transferIn ( float amount ) { super . verboseTransferIn ( amount - fee ); } } Todos los objetos a a de la clase Account deben cumplir que si b=a.getBalance() b=a.getBalance() antes de ejecutar a.transferIn(s) a.transferIn(s) y b\u00b4=a.getBalance() b\u00b4=a.getBalance() despu\u00e9s de ejecutar a.transferIn(s) a.transferIn(s) , entonces b+s=b\u00b4 b+s=b\u00b4 . Sin embargo, con la estructura AccountWithFee < VerboseAccount < Account , un objeto de tipo AccountWithFee no funciona bien cuando se contempla como un objeto Account . Consid\u00e9rese la siguiente secuencia: void f ( Account a ) { float before = a . getBalance (); a . transferIn ( 10 ); float after = a . getBalance (); // Suppose a is of type AccountWithFee: // before + 10 != after !! // before + 10-1 = after }","title":"Ejemplo: herencia como estructura"},{"location":"iiss-oop-2/","text":"OBJETOS - Delegaci\u00f3n Caso 2 - Implementaci\u00f3n de una orquesta \u00b6 Delegaci\u00f3n \u00b6 Versi\u00f3n inicial: Orquesta v0.1 \u00b6 Criticar la soluci\u00f3n siguiente (parte 1): abstract class Instrumento { public void tocar () { } public static void afinarInstrumento ( Instrumento i ) { // Afinar en funcion del tipo de i if ( i instanceof Viento ) afinarViento ( i ); else if ( i instanceof Cuerda ) afinarCuerda ( i ); // Probar que esta afinado i . tocar (); } public static void afinarViento ( Viento i ) { System . out . println ( \"afinal soplido\" ); } public static void afinarCuerda ( Cuerda i ) { System . out . println ( \"afinar rasgado\" ); } } class Viento extends Instrumento { public void tocar () { soplar (); } public void afinar () { System . out . println ( \"afinar soplido\" ); } public void soplar () { System . out . println ( \"soplar\" ); } } class Cuerda extends Instrumento { public void tocar () { rasgar (); } public void afinar () { System . out . println ( \"afinar rasgado\" ); } public void rasgar () { System . out . println ( \"rasgar\" ); } } public class Orquesta { ArrayList < Instrumento > instrumentos ; public Orquesta () { instrumentos = new ArrayList < Instrumento > ( 3 ); } public void tocar () { for ( int i = 0 ; i < instrumentos . size (); i ++ ) instrumentos . get ( i ). tocar (); } public static void main ( String [] args ) { instrumentos . add ( new Viento ()); instrumentos . add ( new Cuerda ()); for ( int i = 0 ; i < instrumentos . size (); i ++ ) Instrumento . afinarInstrumento ( instrumentos . get ( i )); tocar (); } } Cr\u00edticas a la Orquesta v0.1 \u00b6 Acoplamiento : m\u00e9todo static Cohesi\u00f3n : ubicaci\u00f3n de main Implementaci\u00f3n alternativa: Orquesta v0.2 \u00b6 Usar polimorfismo. Seguir criticando la implementaci\u00f3n... class Orquesta { ArrayList < Instrumento > instrumentos ; public Orquesta () { instrumentos = new ArrayList < Instrumento > ( 3 ); } public void tocar () { for ( int i = 0 ; i < instrumentos . size (); i ++ ) instrumentos . get ( i ). tocar (); } public void afinar ( Instrumento i ) { i . afinar (); // Metodo polimorfico i . tocar (); // Prueba de que esta afinado } } public class PruebaOrquesta { public static void main ( String [] args ) { Orquesta orquesta = new Orquesta (); orquesta . instrumentos . add ( new Viento ()); orquesta . instrumentos . add ( new Cuerda ()); orquesta . instrumentos . add ( new Percusion ()); for ( int i = 0 ; i < instrumentos . size (); i ++ ) orquesta . afinar ( orquesta . instrumentos . get ( i )); orquesta . tocar (); } } abstract class Instrumento { public void tocar () { }; public void afinar () { }; } class Viento extends Instrumento { public void tocar () { soplar (); } public void afinar () { System . out . println ( \"afinar soplido\" ); } public void soplar () { System . out . println ( \"soplar\" ); } } class Cuerda extends Instrumento { public void tocar () { rasgar (); } public void afinar () { System . out . println ( \"afinar rasgado\" ); } public void rasgar () { System . out . println ( \"rasgar\" ); } } class Percusion extends Instrumento { public void tocar () { golpear (); } public void afinar () { System . out . println ( \"afinar golpeado\" ); } public void golpear () { System . out . println ( \"golpear\" ); } } Cr\u00edticas a la Orquesta v0.2 \u00b6 Encapsulaci\u00f3n : m\u00e9todo add Encapsulaci\u00f3n : visibilidad de Orquesta::instrumentos (en C++ ser\u00eda friend ) Flexibilidad : la implementaci\u00f3n Orquesta::instrumentos puede variar, pero no hay colecci\u00f3n (agregado) en quien conf\u00ede Orquesta por delegaci\u00f3n. Implementaci\u00f3n alternativa: Orquesta v0.3 \u00b6 Delegar las altas/bajas de Instrumento en la colecci\u00f3n (agregado) de Orquesta : class Orquesta { protected ArrayList < Instrumento > instrumentos ; public Orquesta () { instrumentos = new ArrayList < Instrumento > ( 3 ); } public boolean addInstrumento ( Instrumento i ) { return instrumentos . add ( i ); } public boolean removeInstrumento ( Instrumento i ) { return instrumentos . remove ( i ); } public void tocar () { for ( int i = 0 ; i < instrumentos . size (); i ++ ) instrumentos . get ( i ). tocar (); } public void afinar ( Instrumento i ) { i . afinar (); i . tocar (); // Prueba de que esta afinado } } public class PruebaOrquesta { public static void main ( String [] args ) { Orquesta orquesta = new Orquesta (); orquesta . addInstrumento ( new Viento ()); orquesta . addInstrumento ( new Cuerda ()); orquesta . addInstrumento ( new Percusion ()); for ( int i = 0 ; i < orquesta . instrumentos . size (); i ++ ) orquesta . afinar ( orquesta . instrumentos . get ( i )); orquesta . tocar (); } } Cr\u00edticas a la Orquesta v0.3: \u00b6 Acoplamiento : PruebaOrquesta conoce la implementaci\u00f3n basada en un ArrayList de la colecci\u00f3n de instrumentos de la orquesta. Variabilidad : \u00bfLa colecci\u00f3n de instrumentos ser\u00e1 siempre lineal? Implementaci\u00f3n alternativa: Orquesta v0.4 \u00b6 Definir una interfaz para iterar en la colecci\u00f3n de instrumentos: class Orquesta { protected List < Instrumento > instrumentos ; public Orquesta () { instrumentos = new ArrayList < Instrumento > ( 3 ); } public boolean addInstrumento ( Instrumento i ) { return instrumentos . add ( i ); } public boolean removeInstrumento ( Instrumento i ) { return instrumentos . remove ( i ); } public void tocar () { for ( Iterator < Instrumento > i = instrumentos . iterator (); i . hasNext (); ) i . next (). tocar (); } public void afinar ( Instrumento i ) { i . afinar (); i . tocar (); // Prueba de que esta afinado } } public class PruebaOrquesta { public static void main ( String [] args ) { Orquesta orquesta = new Orquesta (); orquesta . addInstrumento ( new Viento ()); orquesta . addInstrumento ( new Cuerda ()); orquesta . addInstrumento ( new Percusion ()); for ( Iterator < Instrumento > i = orquesta . instrumentos . iterator (); i . hasNext (); ) orquesta . afinar ( i . next ()); orquesta . tocar (); } } Cr\u00edticas a la Orquesta v0.4 \u00b6 Ocultaci\u00f3n : el atributo instrumentos sigue sin ser privado. Rehacemos la implementaci\u00f3n, aprovechando que aparece una nueva versi\u00f3n del lenguaje (Java JDK 1.5) que permite iterar haciendo un for each sobre una colecci\u00f3n que implemente la interfaz Iterable . Implementaci\u00f3n alternativa: Orquesta v0.5 \u00b6 Usando delegaci\u00f3n + interfaces y el for each de Java 1.5: Criticar... class Orquesta { private List < Instrumento > instrumentos ; public Orquesta () { instrumentos = new ArrayList < Instrumento > ( 3 ); } public boolean addInstrumento ( Instrumento i ) { return instrumentos . add ( i ); } public boolean removeInstrumento ( Instrumento i ) { return instrumentos . remove ( i ); } public List < Instrumento > instrumentos () { return instrumentos ; } public void tocar () { for ( Instrumento i : instrumentos ) i . tocar (); } public void afinar ( Instrumento i ) { i . afinar (); i . tocar (); // Prueba de que esta afinado } } public class PruebaOrquesta { public static void main ( String [] args ) { Orquesta orquesta = new Orquesta (); orquesta . addInstrumento ( new Viento ()); orquesta . addInstrumento ( new Cuerda ()); orquesta . addInstrumento ( new Percusion ()); for ( Instrumento i : orquesta . instrumentos ()) orquesta . afinar ( i ); orquesta . tocar (); } } Cr\u00edticas a la Orquesta v0.5: \u00b6 Ocultaci\u00f3n : la interfaz del m\u00e9todo instrumentos() sigue expuesta: el cliente sabe que devuelve una List . Hemos ocultado un poco la implementaci\u00f3n de instrumentos (que es una List ), pero \u00bfconviene saber que es una List ? Quiz\u00e1 no hemos ocultado lo suficiente. Implementaci\u00f3n alternativa: Orquesta v0.6 \u00b6 Nos quedamos s\u00f3lo con lo que nos interesa de la Orquesta: que es una colecci\u00f3n iterable. Eliminamos lo que no nos interesa: el resto de elementos de la interfaz List que explican la forma lineal de almacenar los instrumentos. class Orquesta implements Iterable < Instrumento > { private List < Instrumento > instrumentos ; public Orquesta () { instrumentos = new ArrayList < Instrumento > ( 3 ); } public boolean addInstrumento ( Instrumento i ) { return instrumentos . add ( i ); } public boolean removeInstrumento ( Instrumento i ) { return instrumentos . remove ( i ); } public Iterator < Instrumento > iterator () { return instrumentos . iterator (); } public void tocar () { for ( Instrumento i : this ) i . tocar (); } public void afinar ( Instrumento i ) { i . afinar (); i . tocar (); // Prueba de que esta afinado } } public class PruebaOrquesta { public static void main ( String [] args ) { Orquesta orquesta = new Orquesta (); orquesta . addInstrumento ( new Viento ()); orquesta . addInstrumento ( new Cuerda ()); orquesta . addInstrumento ( new Percusion ()); for ( Instrumento i : orquesta ) orquesta . afinar ( i ); orquesta . tocar (); } } Implementaci\u00f3n alternativa: Orquesta v0.7 \u00b6 Supongamos que queremos sustituir la implementaci\u00f3n basada en una List por otra (quiz\u00e1 m\u00e1s eficiente) basada en un Map . Nota : La interfaz java.util.Map declara los m\u00e9todos siguientes: clear() void \u2013 Map containsKey(Object key) boolean \u2013 Map containsValue(Object value) boolean \u2013 Map entrySet() Set \u2013 Map equals(Object o) boolean \u2013 Map get(Object key) Object \u2013 Map getClass() Class<? extends Object> \u2013 Object hashCode() int \u2013 Map isEmpty() boolean \u2013 Map keySet() Set \u2013 Map notify() void \u2013 Object notifyAll() void \u2013 Object put(Object key, Object value) Object \u2013 Map putAll(Map t) void \u2013 Map remove(Object key) Object \u2013 Map size() int \u2013 Map toString() String \u2013 Object values() Collection \u2013 Map wait() void \u2013 Object wait(long timeout) void \u2013 Object wait(long timeout, int nanos) void \u2013 Object Pero \u00a1 Map no implementa Iterable ! Existe una cierta tensi\u00f3n proveedor-cliente en la frontera de la interfaz Los proveedores de packages y frameworks quieren ampliar aplicabilidad Los clientes quieren una interfaz centrada en sus necesidades particulares Construimos un Map y lo pasamos. Primera opci\u00f3n: Ninguno de los receptores deber\u00e1 poder borrar algo del map. Pero \u00a1hay un clear() en el Map ! Segunda opci\u00f3n: solo algunos tipos de objetos deben poderse guardar. Pero \u00a1los tipos de objeto a guardar no est\u00e1n restringidos en un Map ! \u00bfLa interfaz Map es siempre satisfactoria? \u00bfseguro que no va a cambiar? JDK < 5.0: Map sensors = new HashMap (); ... Sensor s = ( Sensor ) sensors . get ( sensorId ); JDK >= 5.0: Map < Sensor > sensors = new HashMap < Sensor > (); ... Sensor s = sensors . get ( sensorId ); Conclusi\u00f3n : Map<Sensor> ofrece m\u00e1s de lo que necesitamos public class Sensors { private Map sensors = new HashMap (); public Sensor getById ( String id ) { return ( Sensor ) sensors . get ( id ); } //... } La interfaz Map queda oculta Filtramos los m\u00e9todos que no nos sirven M\u00e1s f\u00e1cil de hacer evolucionar sin impacto en el resto de la aplicaci\u00f3n El casting queda confinado en la clase Sensors, que es m\u00e1s seguro Interfaces de frontera : No todo uso de Map o interfaz de frontera debe quedar encapsulado. S\u00f3lo es un consejo para no pasar la interfaz con m\u00e9todos que no vamos a necesitar. As\u00ed que proponemos esta implementaci\u00f3n de la Orquesta: class Orquesta implements Iterable < Instrumento > { private Instrumentos instrumentos ; public Orquesta () { instrumentos = new Instrumentos ( 3 ); } public boolean addInstrumento ( Instrumento i ) { return instrumentos . add ( i ); } public boolean removeInstrumento ( Instrumento i ) { return instrumentos . remove ( i ); } public Iterator < Instrumento > iterator () { return instrumentos . iterator (); } public void tocar () { for ( Instrumento i : instrumentos ) i . tocar (); } public void afinar ( Instrumento i ) { i . afinar (); i . tocar (); // Prueba de que esta afinado } } public class Instrumentos implements Iterable < Instrumento > { private List instrumentos ; public Instrumentos ( int numero ) { instrumentos = new ArrayList < numero > (); } public Iterator < Instrumento > iterator () { return instrumentos . iterator (); } public Instrumento addInstrumento ( Instrumento i ) { return instrumentos . add ( i ); } public Instrumento removeInstrumento ( Instrumento i ) { return instrumentos . remove ( i ); } } public class PruebaOrquesta { public static void main ( String [] args ) { Orquesta orquesta = new Orquesta (); orquesta . addInstrumento ( new Viento ()); orquesta . addInstrumento ( new Cuerda ()); orquesta . addInstrumento ( new Percusion ()); for ( Instrumento i : orquesta ) orquesta . afinar ( i ); orquesta . tocar (); } } Esta implementaci\u00f3n s\u00ed que podemos adaptarla m\u00e1s f\u00e1cilmente para cambiar el List por un Map , pues la responsabilidad de ser iterable ha quedado confinada en Instrumentos , que desacopla Orquesta y la implementaci\u00f3n elegida ( List , Map , etc.) para la colecci\u00f3n de instrumentos. Implementaci\u00f3n final: Orquesta v0.8 \u00b6 Los new de PruebaOrquesta siguen introduciendo dependencias de PruebaOrquesta con respecto a los tipos concretos de Instrumento . Ver antes el apartado inyecci\u00f3n de dependencias Construcci\u00f3n con spring \u00b6 A trav\u00e9s de un fichero de configuraci\u00f3n orquesta.xml le indicamos los valores inyectables: <?xml version=\"1.0\" encoding=\"UTF-8\"?> <!DOCTYPE beans PUBLIC \"-//SPRING//DTD BEAN//EN\" \"http://www.springframework.org/dtd/spring-beans.dtd\"> <beans> <bean id= \"trompeta\" class= \"Viento\" /> <bean id= \"violin\" class= \"Cuerda\" /> <bean id= \"tambor\" class= \"Percusion\" /> <bean id= \"viola\" class= \"Cuerda\" /> <bean id= \"cuarteto\" class= \"Orquesta\" > <property name= \"instrumento1\" > <ref bean= \"trompeta\" /> </property> <property name= \"instrumento2\" > <ref bean= \"violin\" /> </property> <property name= \"instrumento3\" > <ref bean= \"viola\" /> </property> <property name= \"instrumento4\" > <ref bean= \"tambor\" /> </property> </bean> </beans> La inyecci\u00f3n de la dependencia concreta la hace el contenedor ( spring en este ejemplo): import org.springframework.beans.factory.BeanFactory ; import org.springframework.beans.factory.xml.XmlBeanFactory ; public class PruebaOrquesta { public static void main ( String [] args ) throws Exception { BeanFactory factory = new XmlBeanFactory ( new FileInputStream ( \"orquesta.xml\" )); Orquesta orquesta = ( Orquesta ) factory . getBean ( \"cuarteto\" ); for ( Instrumento i : orquesta ) orquesta . afinar ( i ); orquesta . tocar (); } } Un bean es una clase/componente reutilizable en Java que tiene una interfaz bien definida, seg\u00fan una especificaci\u00f3n est\u00e1ndar de Java, que permite a un contenedor gestionar su ciclo de vida (crearlos, cambiarles valores de sus propiedades, destruirlos, etc.) Los beans son usados por muchos frameworks, entre otros Spring: Spring Bean Spring FactoryBean Composici\u00f3n y dependencias \u00b6 Delegaci\u00f3n en horizontal hacia otras clases cuya interfaz es bien conocida Los objetos miembro delegados son cambiables en tiempo de ejecuci\u00f3n sin afectar al c\u00f3digo cliente ya existente Alternativa m\u00e1s flexible que la herencia. Ejemplo: Cola extends ArrayList implica que una cola va a implementarse como un ArrayList para toda la vida, sin posibilidad de cambio en ejecuci\u00f3n Composici\u00f3n vs. Herencia \u00b6 Composici\u00f3n (delegaci\u00f3n en horizontal ) Sirve cuando hacen falta las caracter\u00edsticas de una clase existente dentro de una nueva, pero no su interfaz. Los objetos miembro privados pueden cambiarse en tiempo de ejecuci\u00f3n. Los cambios en el objeto miembro no afectan al c\u00f3digo del cliente. Herencia (delegaci\u00f3n en vertical ) Sirve para hacer una versi\u00f3n especial de una clase existente, reutilizando su interfaz. La relaci\u00f3n de herencia en los lenguajes de programaci\u00f3n suele ser est\u00e1tica (definida en tiempo de compilaci\u00f3n) y no din\u00e1mica (que pueda cambiarse en tiempo de ejecuci\u00f3n). Permite re-interpretar el tipo de un objeto en tiempo de ejecuci\u00f3n. Ejemplo: implementaci\u00f3n de identificadores \u00b6 Handler en Java \u00b6 interface Handler { String toString (); int compareTo ( Handler otro ); } class IdentificadorNumerico implements Handler { private int id ; IdentificadorNumerico ( String id ) throws NumberFormatException { this . id = new Integer ( id ). intValue (); } public String toString () { return new Integer ( id ). toString (); } public int compareTo ( Handler otro ) { return toString (). compareTo ( otro . toString ()); } } Implementaci\u00f3n por herencia \u00b6 java.lang.Comparable es una interfaz implementada por String , File , Date , etc. y todas las llamadas clases de envoltura del JDK (i.e. Integer , Long , etc.) M\u00e9todos de la interfaz \u00b6 JDK 1.4: public interface Comparable { public int compareTo ( Object o ); //throws ClassCastException } JDK 1.5: public interface Comparable < T > { public int compareTo ( T o ); //throws ClassCastException } Invariantes \u00b6 Anticonmutativa: sgn(x.compareTo(y)) = -sgn(y.compareTo(x)) Transitividad: (x.compareTo(y)>0 and y.compareTo(z)>0) \u2192 x.compareTo(z)>0 x.compareTo(y)=0 \u2192 sgn(x.compareTo(z))=sgn(y.compareTo(z)) \\forall \\forall z Consistencia con equals (no obligatoria): (x.compareTo(y)=0) \u2190 (x.equals(y)) Identificador de BankAccount: Implementaci\u00f3n en Java \u2265 1.5 \u00b6 Utilizando templates ( polimorfismo param\u00e9trico ) Delegar en compareTo y equals del tipo de id envuelto (e.g. String ) import java.util.* ; import java.io.* ; public final class BankAccount implements Comparable < BankAccount > { private final String id ; public BankAccount ( String number ) { this . id = number ; } public String getId () { return id ; } @Override public int compareTo ( BankAccount other ) { if ( this == other ) return 0 ; assert this . equals ( other ) : \"compareTo inconsistent with equals.\" ; return this . id . compareTo ( other . getId ()); } @Override public boolean equals ( Object other ) { if ( this == other ) return true ; if ( ! ( other instanceof BankAccount )) return false ; BankAccount that = ( BankAccount ) other ; return this . id . equals ( that . getId ()); } @Override public String toString () { return id . toString (); } } Identificador de BankAccount: Implementaci\u00f3n en Java \u2264 1.4 \u00b6 No hay plantillas (polimorfismo param\u00e9trico). La genericidad se consigue con Object . Hay que hacer casting. Cuidado con Boolean que no implementa Comparable en JDK 1.4 import java.util.* ; import java.io.* ; public final class BankAccount implements Comparable { private final String id ; public BankAccount ( String number ) { this . id = number ; } public String getId () { return id ; } public int compareTo ( Object other ) { if ( this == other ) return 0 ; assert ( other instanceof BankAccount ) : \"compareTo comparing objects of different type\" ; BankAccount that = ( BankAccount ) other ; assert this . equals ( that ) : \"compareTo inconsistent with equals.\" ; return this . id . compareTo ( that . getId ()); } public boolean equals ( Object other ) { if ( this == other ) return true ; if ( ! ( other instanceof BankAccount )) return false ; BankAccount that = ( BankAccount ) other ; return this . id . equals ( that . getId ()); } public String toString () { return id . toString (); } } Implementaci\u00f3n por composici\u00f3n/delegaci\u00f3n \u00b6 Cuando una clase hereda de una clase concreta que implementa Comparable y le a\u00f1ade un campo significativo para la comparaci\u00f3n, no se puede construir una implementaci\u00f3n correcta de compareTo . La \u00fanica alternativa entonces es la composici\u00f3n en lugar de la herencia. Una alternativa (no excluyente) a implementar Comparable es pasar un Comparator como par\u00e1metro (se prefiere composici\u00f3n frente a herencia ): Si BankAccount implementa Comparable : class BankAccountComparator implements java . util . Comparator < BankAccount > { public int compare ( BankAccount o1 , BankAccount o2 ) { return o1 . compareTo ( o2 ); } } Si BankAccount no implementa Comparable : class BankAccountComparator implements java . util . Comparator < BankAccount > { public int compare ( BankAccount o1 , BankAccount o2 ) { return compare ( o1 . getId (), o2 . getId ()); } } \u00bfQu\u00e9 ventajas tiene la opci\u00f3n que usa Composici\u00f3n frente a la que usa Herencia (est\u00e1tica) ? La respuesta est\u00e1 en la inyecci\u00f3n de dependencias ...","title":"Delegaci\u00f3n"},{"location":"iiss-oop-2/#caso-2-implementacion-de-una-orquesta","text":"","title":"Caso 2 - Implementaci\u00f3n de una orquesta"},{"location":"iiss-oop-2/#delegacion","text":"","title":"Delegaci\u00f3n"},{"location":"iiss-oop-2/#version-inicial-orquesta-v01","text":"Criticar la soluci\u00f3n siguiente (parte 1): abstract class Instrumento { public void tocar () { } public static void afinarInstrumento ( Instrumento i ) { // Afinar en funcion del tipo de i if ( i instanceof Viento ) afinarViento ( i ); else if ( i instanceof Cuerda ) afinarCuerda ( i ); // Probar que esta afinado i . tocar (); } public static void afinarViento ( Viento i ) { System . out . println ( \"afinal soplido\" ); } public static void afinarCuerda ( Cuerda i ) { System . out . println ( \"afinar rasgado\" ); } } class Viento extends Instrumento { public void tocar () { soplar (); } public void afinar () { System . out . println ( \"afinar soplido\" ); } public void soplar () { System . out . println ( \"soplar\" ); } } class Cuerda extends Instrumento { public void tocar () { rasgar (); } public void afinar () { System . out . println ( \"afinar rasgado\" ); } public void rasgar () { System . out . println ( \"rasgar\" ); } } public class Orquesta { ArrayList < Instrumento > instrumentos ; public Orquesta () { instrumentos = new ArrayList < Instrumento > ( 3 ); } public void tocar () { for ( int i = 0 ; i < instrumentos . size (); i ++ ) instrumentos . get ( i ). tocar (); } public static void main ( String [] args ) { instrumentos . add ( new Viento ()); instrumentos . add ( new Cuerda ()); for ( int i = 0 ; i < instrumentos . size (); i ++ ) Instrumento . afinarInstrumento ( instrumentos . get ( i )); tocar (); } }","title":"Versi\u00f3n inicial: Orquesta v0.1"},{"location":"iiss-oop-2/#criticas-a-la-orquesta-v01","text":"Acoplamiento : m\u00e9todo static Cohesi\u00f3n : ubicaci\u00f3n de main","title":"Cr\u00edticas a la Orquesta v0.1"},{"location":"iiss-oop-2/#implementacion-alternativa-orquesta-v02","text":"Usar polimorfismo. Seguir criticando la implementaci\u00f3n... class Orquesta { ArrayList < Instrumento > instrumentos ; public Orquesta () { instrumentos = new ArrayList < Instrumento > ( 3 ); } public void tocar () { for ( int i = 0 ; i < instrumentos . size (); i ++ ) instrumentos . get ( i ). tocar (); } public void afinar ( Instrumento i ) { i . afinar (); // Metodo polimorfico i . tocar (); // Prueba de que esta afinado } } public class PruebaOrquesta { public static void main ( String [] args ) { Orquesta orquesta = new Orquesta (); orquesta . instrumentos . add ( new Viento ()); orquesta . instrumentos . add ( new Cuerda ()); orquesta . instrumentos . add ( new Percusion ()); for ( int i = 0 ; i < instrumentos . size (); i ++ ) orquesta . afinar ( orquesta . instrumentos . get ( i )); orquesta . tocar (); } } abstract class Instrumento { public void tocar () { }; public void afinar () { }; } class Viento extends Instrumento { public void tocar () { soplar (); } public void afinar () { System . out . println ( \"afinar soplido\" ); } public void soplar () { System . out . println ( \"soplar\" ); } } class Cuerda extends Instrumento { public void tocar () { rasgar (); } public void afinar () { System . out . println ( \"afinar rasgado\" ); } public void rasgar () { System . out . println ( \"rasgar\" ); } } class Percusion extends Instrumento { public void tocar () { golpear (); } public void afinar () { System . out . println ( \"afinar golpeado\" ); } public void golpear () { System . out . println ( \"golpear\" ); } }","title":"Implementaci\u00f3n alternativa: Orquesta v0.2"},{"location":"iiss-oop-2/#criticas-a-la-orquesta-v02","text":"Encapsulaci\u00f3n : m\u00e9todo add Encapsulaci\u00f3n : visibilidad de Orquesta::instrumentos (en C++ ser\u00eda friend ) Flexibilidad : la implementaci\u00f3n Orquesta::instrumentos puede variar, pero no hay colecci\u00f3n (agregado) en quien conf\u00ede Orquesta por delegaci\u00f3n.","title":"Cr\u00edticas a la Orquesta v0.2"},{"location":"iiss-oop-2/#implementacion-alternativa-orquesta-v03","text":"Delegar las altas/bajas de Instrumento en la colecci\u00f3n (agregado) de Orquesta : class Orquesta { protected ArrayList < Instrumento > instrumentos ; public Orquesta () { instrumentos = new ArrayList < Instrumento > ( 3 ); } public boolean addInstrumento ( Instrumento i ) { return instrumentos . add ( i ); } public boolean removeInstrumento ( Instrumento i ) { return instrumentos . remove ( i ); } public void tocar () { for ( int i = 0 ; i < instrumentos . size (); i ++ ) instrumentos . get ( i ). tocar (); } public void afinar ( Instrumento i ) { i . afinar (); i . tocar (); // Prueba de que esta afinado } } public class PruebaOrquesta { public static void main ( String [] args ) { Orquesta orquesta = new Orquesta (); orquesta . addInstrumento ( new Viento ()); orquesta . addInstrumento ( new Cuerda ()); orquesta . addInstrumento ( new Percusion ()); for ( int i = 0 ; i < orquesta . instrumentos . size (); i ++ ) orquesta . afinar ( orquesta . instrumentos . get ( i )); orquesta . tocar (); } }","title":"Implementaci\u00f3n alternativa: Orquesta v0.3"},{"location":"iiss-oop-2/#criticas-a-la-orquesta-v03","text":"Acoplamiento : PruebaOrquesta conoce la implementaci\u00f3n basada en un ArrayList de la colecci\u00f3n de instrumentos de la orquesta. Variabilidad : \u00bfLa colecci\u00f3n de instrumentos ser\u00e1 siempre lineal?","title":"Cr\u00edticas a la Orquesta v0.3:"},{"location":"iiss-oop-2/#implementacion-alternativa-orquesta-v04","text":"Definir una interfaz para iterar en la colecci\u00f3n de instrumentos: class Orquesta { protected List < Instrumento > instrumentos ; public Orquesta () { instrumentos = new ArrayList < Instrumento > ( 3 ); } public boolean addInstrumento ( Instrumento i ) { return instrumentos . add ( i ); } public boolean removeInstrumento ( Instrumento i ) { return instrumentos . remove ( i ); } public void tocar () { for ( Iterator < Instrumento > i = instrumentos . iterator (); i . hasNext (); ) i . next (). tocar (); } public void afinar ( Instrumento i ) { i . afinar (); i . tocar (); // Prueba de que esta afinado } } public class PruebaOrquesta { public static void main ( String [] args ) { Orquesta orquesta = new Orquesta (); orquesta . addInstrumento ( new Viento ()); orquesta . addInstrumento ( new Cuerda ()); orquesta . addInstrumento ( new Percusion ()); for ( Iterator < Instrumento > i = orquesta . instrumentos . iterator (); i . hasNext (); ) orquesta . afinar ( i . next ()); orquesta . tocar (); } }","title":"Implementaci\u00f3n alternativa: Orquesta v0.4"},{"location":"iiss-oop-2/#criticas-a-la-orquesta-v04","text":"Ocultaci\u00f3n : el atributo instrumentos sigue sin ser privado. Rehacemos la implementaci\u00f3n, aprovechando que aparece una nueva versi\u00f3n del lenguaje (Java JDK 1.5) que permite iterar haciendo un for each sobre una colecci\u00f3n que implemente la interfaz Iterable .","title":"Cr\u00edticas a la Orquesta v0.4"},{"location":"iiss-oop-2/#implementacion-alternativa-orquesta-v05","text":"Usando delegaci\u00f3n + interfaces y el for each de Java 1.5: Criticar... class Orquesta { private List < Instrumento > instrumentos ; public Orquesta () { instrumentos = new ArrayList < Instrumento > ( 3 ); } public boolean addInstrumento ( Instrumento i ) { return instrumentos . add ( i ); } public boolean removeInstrumento ( Instrumento i ) { return instrumentos . remove ( i ); } public List < Instrumento > instrumentos () { return instrumentos ; } public void tocar () { for ( Instrumento i : instrumentos ) i . tocar (); } public void afinar ( Instrumento i ) { i . afinar (); i . tocar (); // Prueba de que esta afinado } } public class PruebaOrquesta { public static void main ( String [] args ) { Orquesta orquesta = new Orquesta (); orquesta . addInstrumento ( new Viento ()); orquesta . addInstrumento ( new Cuerda ()); orquesta . addInstrumento ( new Percusion ()); for ( Instrumento i : orquesta . instrumentos ()) orquesta . afinar ( i ); orquesta . tocar (); } }","title":"Implementaci\u00f3n alternativa: Orquesta v0.5"},{"location":"iiss-oop-2/#criticas-a-la-orquesta-v05","text":"Ocultaci\u00f3n : la interfaz del m\u00e9todo instrumentos() sigue expuesta: el cliente sabe que devuelve una List . Hemos ocultado un poco la implementaci\u00f3n de instrumentos (que es una List ), pero \u00bfconviene saber que es una List ? Quiz\u00e1 no hemos ocultado lo suficiente.","title":"Cr\u00edticas a la Orquesta v0.5:"},{"location":"iiss-oop-2/#implementacion-alternativa-orquesta-v06","text":"Nos quedamos s\u00f3lo con lo que nos interesa de la Orquesta: que es una colecci\u00f3n iterable. Eliminamos lo que no nos interesa: el resto de elementos de la interfaz List que explican la forma lineal de almacenar los instrumentos. class Orquesta implements Iterable < Instrumento > { private List < Instrumento > instrumentos ; public Orquesta () { instrumentos = new ArrayList < Instrumento > ( 3 ); } public boolean addInstrumento ( Instrumento i ) { return instrumentos . add ( i ); } public boolean removeInstrumento ( Instrumento i ) { return instrumentos . remove ( i ); } public Iterator < Instrumento > iterator () { return instrumentos . iterator (); } public void tocar () { for ( Instrumento i : this ) i . tocar (); } public void afinar ( Instrumento i ) { i . afinar (); i . tocar (); // Prueba de que esta afinado } } public class PruebaOrquesta { public static void main ( String [] args ) { Orquesta orquesta = new Orquesta (); orquesta . addInstrumento ( new Viento ()); orquesta . addInstrumento ( new Cuerda ()); orquesta . addInstrumento ( new Percusion ()); for ( Instrumento i : orquesta ) orquesta . afinar ( i ); orquesta . tocar (); } }","title":"Implementaci\u00f3n alternativa: Orquesta v0.6"},{"location":"iiss-oop-2/#implementacion-alternativa-orquesta-v07","text":"Supongamos que queremos sustituir la implementaci\u00f3n basada en una List por otra (quiz\u00e1 m\u00e1s eficiente) basada en un Map . Nota : La interfaz java.util.Map declara los m\u00e9todos siguientes: clear() void \u2013 Map containsKey(Object key) boolean \u2013 Map containsValue(Object value) boolean \u2013 Map entrySet() Set \u2013 Map equals(Object o) boolean \u2013 Map get(Object key) Object \u2013 Map getClass() Class<? extends Object> \u2013 Object hashCode() int \u2013 Map isEmpty() boolean \u2013 Map keySet() Set \u2013 Map notify() void \u2013 Object notifyAll() void \u2013 Object put(Object key, Object value) Object \u2013 Map putAll(Map t) void \u2013 Map remove(Object key) Object \u2013 Map size() int \u2013 Map toString() String \u2013 Object values() Collection \u2013 Map wait() void \u2013 Object wait(long timeout) void \u2013 Object wait(long timeout, int nanos) void \u2013 Object Pero \u00a1 Map no implementa Iterable ! Existe una cierta tensi\u00f3n proveedor-cliente en la frontera de la interfaz Los proveedores de packages y frameworks quieren ampliar aplicabilidad Los clientes quieren una interfaz centrada en sus necesidades particulares Construimos un Map y lo pasamos. Primera opci\u00f3n: Ninguno de los receptores deber\u00e1 poder borrar algo del map. Pero \u00a1hay un clear() en el Map ! Segunda opci\u00f3n: solo algunos tipos de objetos deben poderse guardar. Pero \u00a1los tipos de objeto a guardar no est\u00e1n restringidos en un Map ! \u00bfLa interfaz Map es siempre satisfactoria? \u00bfseguro que no va a cambiar? JDK < 5.0: Map sensors = new HashMap (); ... Sensor s = ( Sensor ) sensors . get ( sensorId ); JDK >= 5.0: Map < Sensor > sensors = new HashMap < Sensor > (); ... Sensor s = sensors . get ( sensorId ); Conclusi\u00f3n : Map<Sensor> ofrece m\u00e1s de lo que necesitamos public class Sensors { private Map sensors = new HashMap (); public Sensor getById ( String id ) { return ( Sensor ) sensors . get ( id ); } //... } La interfaz Map queda oculta Filtramos los m\u00e9todos que no nos sirven M\u00e1s f\u00e1cil de hacer evolucionar sin impacto en el resto de la aplicaci\u00f3n El casting queda confinado en la clase Sensors, que es m\u00e1s seguro Interfaces de frontera : No todo uso de Map o interfaz de frontera debe quedar encapsulado. S\u00f3lo es un consejo para no pasar la interfaz con m\u00e9todos que no vamos a necesitar. As\u00ed que proponemos esta implementaci\u00f3n de la Orquesta: class Orquesta implements Iterable < Instrumento > { private Instrumentos instrumentos ; public Orquesta () { instrumentos = new Instrumentos ( 3 ); } public boolean addInstrumento ( Instrumento i ) { return instrumentos . add ( i ); } public boolean removeInstrumento ( Instrumento i ) { return instrumentos . remove ( i ); } public Iterator < Instrumento > iterator () { return instrumentos . iterator (); } public void tocar () { for ( Instrumento i : instrumentos ) i . tocar (); } public void afinar ( Instrumento i ) { i . afinar (); i . tocar (); // Prueba de que esta afinado } } public class Instrumentos implements Iterable < Instrumento > { private List instrumentos ; public Instrumentos ( int numero ) { instrumentos = new ArrayList < numero > (); } public Iterator < Instrumento > iterator () { return instrumentos . iterator (); } public Instrumento addInstrumento ( Instrumento i ) { return instrumentos . add ( i ); } public Instrumento removeInstrumento ( Instrumento i ) { return instrumentos . remove ( i ); } } public class PruebaOrquesta { public static void main ( String [] args ) { Orquesta orquesta = new Orquesta (); orquesta . addInstrumento ( new Viento ()); orquesta . addInstrumento ( new Cuerda ()); orquesta . addInstrumento ( new Percusion ()); for ( Instrumento i : orquesta ) orquesta . afinar ( i ); orquesta . tocar (); } } Esta implementaci\u00f3n s\u00ed que podemos adaptarla m\u00e1s f\u00e1cilmente para cambiar el List por un Map , pues la responsabilidad de ser iterable ha quedado confinada en Instrumentos , que desacopla Orquesta y la implementaci\u00f3n elegida ( List , Map , etc.) para la colecci\u00f3n de instrumentos.","title":"Implementaci\u00f3n alternativa: Orquesta v0.7"},{"location":"iiss-oop-2/#implementacion-final-orquesta-v08","text":"Los new de PruebaOrquesta siguen introduciendo dependencias de PruebaOrquesta con respecto a los tipos concretos de Instrumento . Ver antes el apartado inyecci\u00f3n de dependencias","title":"Implementaci\u00f3n final: Orquesta v0.8"},{"location":"iiss-oop-2/#construccion-con-spring","text":"A trav\u00e9s de un fichero de configuraci\u00f3n orquesta.xml le indicamos los valores inyectables: <?xml version=\"1.0\" encoding=\"UTF-8\"?> <!DOCTYPE beans PUBLIC \"-//SPRING//DTD BEAN//EN\" \"http://www.springframework.org/dtd/spring-beans.dtd\"> <beans> <bean id= \"trompeta\" class= \"Viento\" /> <bean id= \"violin\" class= \"Cuerda\" /> <bean id= \"tambor\" class= \"Percusion\" /> <bean id= \"viola\" class= \"Cuerda\" /> <bean id= \"cuarteto\" class= \"Orquesta\" > <property name= \"instrumento1\" > <ref bean= \"trompeta\" /> </property> <property name= \"instrumento2\" > <ref bean= \"violin\" /> </property> <property name= \"instrumento3\" > <ref bean= \"viola\" /> </property> <property name= \"instrumento4\" > <ref bean= \"tambor\" /> </property> </bean> </beans> La inyecci\u00f3n de la dependencia concreta la hace el contenedor ( spring en este ejemplo): import org.springframework.beans.factory.BeanFactory ; import org.springframework.beans.factory.xml.XmlBeanFactory ; public class PruebaOrquesta { public static void main ( String [] args ) throws Exception { BeanFactory factory = new XmlBeanFactory ( new FileInputStream ( \"orquesta.xml\" )); Orquesta orquesta = ( Orquesta ) factory . getBean ( \"cuarteto\" ); for ( Instrumento i : orquesta ) orquesta . afinar ( i ); orquesta . tocar (); } } Un bean es una clase/componente reutilizable en Java que tiene una interfaz bien definida, seg\u00fan una especificaci\u00f3n est\u00e1ndar de Java, que permite a un contenedor gestionar su ciclo de vida (crearlos, cambiarles valores de sus propiedades, destruirlos, etc.) Los beans son usados por muchos frameworks, entre otros Spring: Spring Bean Spring FactoryBean","title":"Construcci\u00f3n con spring"},{"location":"iiss-oop-2/#composicion-y-dependencias","text":"Delegaci\u00f3n en horizontal hacia otras clases cuya interfaz es bien conocida Los objetos miembro delegados son cambiables en tiempo de ejecuci\u00f3n sin afectar al c\u00f3digo cliente ya existente Alternativa m\u00e1s flexible que la herencia. Ejemplo: Cola extends ArrayList implica que una cola va a implementarse como un ArrayList para toda la vida, sin posibilidad de cambio en ejecuci\u00f3n","title":"Composici\u00f3n y dependencias"},{"location":"iiss-oop-2/#composicion-vs-herencia","text":"Composici\u00f3n (delegaci\u00f3n en horizontal ) Sirve cuando hacen falta las caracter\u00edsticas de una clase existente dentro de una nueva, pero no su interfaz. Los objetos miembro privados pueden cambiarse en tiempo de ejecuci\u00f3n. Los cambios en el objeto miembro no afectan al c\u00f3digo del cliente. Herencia (delegaci\u00f3n en vertical ) Sirve para hacer una versi\u00f3n especial de una clase existente, reutilizando su interfaz. La relaci\u00f3n de herencia en los lenguajes de programaci\u00f3n suele ser est\u00e1tica (definida en tiempo de compilaci\u00f3n) y no din\u00e1mica (que pueda cambiarse en tiempo de ejecuci\u00f3n). Permite re-interpretar el tipo de un objeto en tiempo de ejecuci\u00f3n.","title":"Composici\u00f3n vs. Herencia"},{"location":"iiss-oop-2/#ejemplo-implementacion-de-identificadores","text":"","title":"Ejemplo: implementaci\u00f3n de identificadores"},{"location":"iiss-oop-2/#handler-en-java","text":"interface Handler { String toString (); int compareTo ( Handler otro ); } class IdentificadorNumerico implements Handler { private int id ; IdentificadorNumerico ( String id ) throws NumberFormatException { this . id = new Integer ( id ). intValue (); } public String toString () { return new Integer ( id ). toString (); } public int compareTo ( Handler otro ) { return toString (). compareTo ( otro . toString ()); } }","title":"Handler en Java"},{"location":"iiss-oop-2/#implementacion-por-herencia","text":"java.lang.Comparable es una interfaz implementada por String , File , Date , etc. y todas las llamadas clases de envoltura del JDK (i.e. Integer , Long , etc.)","title":"Implementaci\u00f3n por herencia"},{"location":"iiss-oop-2/#metodos-de-la-interfaz","text":"JDK 1.4: public interface Comparable { public int compareTo ( Object o ); //throws ClassCastException } JDK 1.5: public interface Comparable < T > { public int compareTo ( T o ); //throws ClassCastException }","title":"M\u00e9todos de la interfaz"},{"location":"iiss-oop-2/#invariantes","text":"Anticonmutativa: sgn(x.compareTo(y)) = -sgn(y.compareTo(x)) Transitividad: (x.compareTo(y)>0 and y.compareTo(z)>0) \u2192 x.compareTo(z)>0 x.compareTo(y)=0 \u2192 sgn(x.compareTo(z))=sgn(y.compareTo(z)) \\forall \\forall z Consistencia con equals (no obligatoria): (x.compareTo(y)=0) \u2190 (x.equals(y))","title":"Invariantes"},{"location":"iiss-oop-2/#identificador-de-bankaccount-implementacion-en-java-15","text":"Utilizando templates ( polimorfismo param\u00e9trico ) Delegar en compareTo y equals del tipo de id envuelto (e.g. String ) import java.util.* ; import java.io.* ; public final class BankAccount implements Comparable < BankAccount > { private final String id ; public BankAccount ( String number ) { this . id = number ; } public String getId () { return id ; } @Override public int compareTo ( BankAccount other ) { if ( this == other ) return 0 ; assert this . equals ( other ) : \"compareTo inconsistent with equals.\" ; return this . id . compareTo ( other . getId ()); } @Override public boolean equals ( Object other ) { if ( this == other ) return true ; if ( ! ( other instanceof BankAccount )) return false ; BankAccount that = ( BankAccount ) other ; return this . id . equals ( that . getId ()); } @Override public String toString () { return id . toString (); } }","title":"Identificador de BankAccount: Implementaci\u00f3n en Java \u2265 1.5"},{"location":"iiss-oop-2/#identificador-de-bankaccount-implementacion-en-java-14","text":"No hay plantillas (polimorfismo param\u00e9trico). La genericidad se consigue con Object . Hay que hacer casting. Cuidado con Boolean que no implementa Comparable en JDK 1.4 import java.util.* ; import java.io.* ; public final class BankAccount implements Comparable { private final String id ; public BankAccount ( String number ) { this . id = number ; } public String getId () { return id ; } public int compareTo ( Object other ) { if ( this == other ) return 0 ; assert ( other instanceof BankAccount ) : \"compareTo comparing objects of different type\" ; BankAccount that = ( BankAccount ) other ; assert this . equals ( that ) : \"compareTo inconsistent with equals.\" ; return this . id . compareTo ( that . getId ()); } public boolean equals ( Object other ) { if ( this == other ) return true ; if ( ! ( other instanceof BankAccount )) return false ; BankAccount that = ( BankAccount ) other ; return this . id . equals ( that . getId ()); } public String toString () { return id . toString (); } }","title":"Identificador de BankAccount: Implementaci\u00f3n en Java \u2264 1.4"},{"location":"iiss-oop-2/#implementacion-por-composiciondelegacion","text":"Cuando una clase hereda de una clase concreta que implementa Comparable y le a\u00f1ade un campo significativo para la comparaci\u00f3n, no se puede construir una implementaci\u00f3n correcta de compareTo . La \u00fanica alternativa entonces es la composici\u00f3n en lugar de la herencia. Una alternativa (no excluyente) a implementar Comparable es pasar un Comparator como par\u00e1metro (se prefiere composici\u00f3n frente a herencia ): Si BankAccount implementa Comparable : class BankAccountComparator implements java . util . Comparator < BankAccount > { public int compare ( BankAccount o1 , BankAccount o2 ) { return o1 . compareTo ( o2 ); } } Si BankAccount no implementa Comparable : class BankAccountComparator implements java . util . Comparator < BankAccount > { public int compare ( BankAccount o1 , BankAccount o2 ) { return compare ( o1 . getId (), o2 . getId ()); } } \u00bfQu\u00e9 ventajas tiene la opci\u00f3n que usa Composici\u00f3n frente a la que usa Herencia (est\u00e1tica) ? La respuesta est\u00e1 en la inyecci\u00f3n de dependencias ...","title":"Implementaci\u00f3n por composici\u00f3n/delegaci\u00f3n"},{"location":"iiss-oop-3/","text":"OBJETOS - Inyecci\u00f3n de dependencias Caso 3 - Inyecci\u00f3n de dependencias \u00b6 Caballeros de la mesa redonda \u00b6 Tomado de Spring in Action \u00b6 A\u00f1adir pruebas unitarias a la soluci\u00f3n siguiente: public class KnightOfTheRoundTable { private String name ; private HolyGrailQuest quest ; public KnightOfTheRoundTable ( String name ) { this . name = name ; quest = new HolyGrailQuest (); } public HolyGrail embarkOnQuest () throws GrailNotFoundException { return quest . embark (); } } public class HolyGrailQuest { public HolyGrailQuest () {} public HolyGrail embark () throws GrailNotFoundException { HolyGrail grail = null ; // Look for grail ... return grail ; } } Construir pruebas con jUnit 3 \u00b6 \u00bfD\u00f3nde est\u00e1 el acoplamiento? import junit.framework.TestCase ; public class KnightOfTheRoundTableTest extends TestCase { public void testEmbarkOnQuest () throws GrailNotFoundException { KnightOfTheRoundTable knight = new KnightOfTheRoundTable ( \"CruzadoMagico\" ); HolyGrail grail = knight . embarkOnQuest (); assertNotNull ( grail ); assertTrue ( grail . isHoly ()); } } Instanciaci\u00f3n de HolyGrail Cada vez que se prueba KnightOfTheRoundTable , tambi\u00e9n se prueba HolyGrailQuest . No se puede pedir a HolyGrailQuest que se comporte de otra forma (v.g. devolver null o elevar una excepci\u00f3n) Ocultar la implementaci\u00f3n detr\u00e1s de una interfaz \u00b6 public interface Knight { Object embarkOnQuest () throws QuestFailedException ; } public class KnightOfTheRoundTable implements Knight { private String name ; private Quest quest ; public KnightOfTheRoundTable ( String name ) { this . name = name ; quest = new HolyGrailQuest (); } public Object embarkOnQuest () throws QuestFailedException { return quest . embark (); } } public interface Quest { abstract Object embark () throws QuestFailedException ; } public class HolyGrailQuest implements Quest { public HolyGrailQuest () {} public Object embark () throws QuestFailedException { // Do whatever it means to embark on a quest return new HolyGrail (); } } El Knight a\u00fan recibe un tipo espec\u00edfico de Quest \u00bfDebe ser el caballero responsable de obtener un desaf\u00edo? Inyectar dependencias \u00b6 public class KnightOfTheRoundTable implements Knight { private String name ; private Quest quest ; public KnightOfTheRoundTable ( String name ) { this . name = name ; } public Object embarkOnQuest () throws QuestFailedException { return quest . embark (); } public void setQuest ( Quest quest ) { this . quest = quest ; } } El caballero no es el responsable de averiguar su misi\u00f3n. El caballero s\u00f3lo sabe de su misi\u00f3n a trav\u00e9s de la interfaz Quest . El caballero recibe la misi\u00f3n (se le inyecta) a trav\u00e9s de setQuest() Puede asign\u00e1rsele cualquier implementaci\u00f3n de Quest ( HolyGrailQuest , RescueDamselQuest , etc.) Construcci\u00f3n con spring \u00b6 A trav\u00e9s de un fichero de configuraci\u00f3n XML le indicamos los valores inyectables: <?xml version=\"1.0\" encoding=\"UTF-8\"?> <!DOCTYPE beans PUBLIC \"-//SPRING//DTD BEAN//EN\" \"http://www.springframework.org/dtd/spring-beans.dtd\"> <beans> <bean id= \"quest\" class= \"HolyGrailQuest\" /> <bean id= \"knight\" class= \"KnightOfTheRoundTable\" > <constructor-arg> <value> CruzadoMagico </value> </constructor-arg> <property name= \"quest\" > <ref bean= \"quest\" /> </property> </bean> </beans> La inyecci\u00f3n de la dependencia concreta la hace el contenedor ( spring en este ejemplo): import org.springframework.beans.factory.BeanFactory ; import org.springframework.beans.factory.xml.XmlBeanFactory ; public class KnightApp { public static void main ( String [] args ) throws Exception { BeanFactory factory = new XmlBeanFactory ( new FileInputStream ( \"knight.xml\" )); KnightOfTheRoundTable knight = ( KnightOfTheRoundTable ) factory . getBean ( \"knight\" ); knight . embarkOnQuest (); } } Ejemplo: Logger \u00b6 Tambi\u00e9n se puede inyectar la dependencia en el constructor. import java.util.logging.Logger ; public class MyClass { private final static Logger logger ; public MyClass ( Logger logger ) { this . logger = logger ; // write an info log message logger . info ( \"This is a log message.\" ) } } Un contenedor de dependencias en el framework debe responsabilizarse de crear las instancias de Logger e inyectarlas en su sitio (normalmente v\u00eda reflexi\u00f3n o introspecci\u00f3n ) Implementaci\u00f3n final de la Orquesta v0.8 \u00b6 Los new de PruebaOrquesta de la versi\u00f3n v0.7 siguen introduciendo dependencias de PruebaOrquesta con respecto a los tipos concretos de Instrumento . A trav\u00e9s de un fichero de configuraci\u00f3n orquesta.xml de Spring le indicamos los valores inyectables: <?xml version=\"1.0\" encoding=\"UTF-8\"?> <!DOCTYPE beans PUBLIC \"-//SPRING//DTD BEAN//EN\" \"http://www.springframework.org/dtd/spring-beans.dtd\"> <beans> <bean id= \"trompeta\" class= \"Viento\" /> <bean id= \"violin\" class= \"Cuerda\" /> <bean id= \"tambor\" class= \"Percusion\" /> <bean id= \"viola\" class= \"Cuerda\" /> <bean id= \"cuarteto\" class= \"Orquesta\" > <property name= \"instrumento1\" > <ref bean= \"trompeta\" /> </property> <property name= \"instrumento2\" > <ref bean= \"violin\" /> </property> <property name= \"instrumento3\" > <ref bean= \"viola\" /> </property> <property name= \"instrumento4\" > <ref bean= \"tambor\" /> </property> </bean> </beans> La inyecci\u00f3n de la dependencia concreta la hace el contenedor ( Spring en este ejemplo): import org.springframework.beans.factory.BeanFactory ; import org.springframework.beans.factory.xml.XmlBeanFactory ; public class PruebaOrquesta { public static void main ( String [] args ) throws Exception { BeanFactory factory = new XmlBeanFactory ( new FileInputStream ( \"orquesta.xml\" )); Orquesta orquesta = ( Orquesta ) factory . getBean ( \"cuarteto\" ); for ( Instrumento i : orquesta ) orquesta . afinar ( i ); orquesta . tocar (); } } Dependencias en Java \u00b6 JSR 330 es un est\u00e1ndar de Java para describir las dependencias de una clase con @Inject y otras anotaciones. Hay diversas implementaciones de JSR 330 . public class MyPart { @Inject private Logger logger ; // inject class for database access @Inject private DatabaseAccessClass dao ; @Inject public void createControls ( Composite parent ) { logger . info ( \"UI will start to build\" ); Label label = new Label ( parent , SWT . NONE ); label . setText ( \"Eclipse 4\" ); Text text = new Text ( parent , SWT . NONE ); text . setText ( dao . getNumber ()); } } Esta clase sigue usando new para ciertos elementos de la interfaz. Esto significa que no pensamos reemplazarlos ni siquiera para hacer pruebas. Ejercicio: Identificador de BankAccount con inyecci\u00f3n de dependencias \u00b6 Supongamos que queremos obtener un listado ordenado por fecha de creaci\u00f3n de todas las cuentas bancarias. \u00bfC\u00f3mo afecta este cambio a la versi\u00f3n de BankAccount ya implementada con JDK 1.5? Resolver mediante inyecci\u00f3n de dependencias BankAcccount.java : import java.util.* ; import java.io.* ; import java.time.* ; public final class BankAccount implements Comparable < BankAccount > { private final String id ; private LocalDate creationDate ; private Comparator comparator ; public BankAccount ( String number ) { this . id = number ; comparator = new BankAccountComparatorById (); } public LocalDate getCreationDate () { return creationDate ; } public void setCreationDate ( LocalDate date ) { this . creationDate = date ; } public String getId () { return id ; } public void setComparator ( Comparator cmp ) { comparator = cmp ; } @Override public int compareTo ( BankAccount other ) { if ( this == other ) return 0 ; assert this . equals ( other ) : \"compareTo inconsistent with equals.\" ; return comparator . compare ( this , other ); } @Override public boolean equals ( Object other ) { if ( this == other ) return true ; if ( ! ( other instanceof BankAccount )) return false ; BankAccount that = ( BankAccount ) other ; return this . id . equals ( that . getId ()); } @Override public String toString () { return id . toString (); } } BankAcccountComparatorById.java : import java.util.* ; class BankAccountComparatorById implements Comparator < BankAccount > { public int compare ( BankAccount o1 , BankAccount o2 ) { return o1 . getId (). compareTo ( o2 . getId ()); } } BankAcccountComparatorByCreationDate.java : import java.util.* ; class BankAccountComparatorByCreationDate implements Comparator < BankAccount > { public int compare ( BankAccount o1 , BankAccount o2 ) { return o1 . getCreationDate (). compareTo ( o2 . getCreationDate ()); } } Ahora podr\u00eda definirse una anotaci\u00f3n del tipo @comparator(BankAccountComparatorById.className) o @compareById que inyecte a BankAccount una dependencia BankAccountComparatorById en BankAccount.comparator . Creaci\u00f3n de anotaciones en Java Ejemplo de c\u00f3mo crear una anotaci\u00f3n a medida en Java Decoradores en TypeScript \u00b6 Los decoradores de TypeScript son una forma de modificar program\u00e1ticamente la definici\u00f3n de una clase. La definici\u00f3n de una clase describe la forma de la clase, es decir, sus m\u00e9todos y propiedades. S\u00f3lo cuando se instancie la clase, estas propiedades y m\u00e9todos estar\u00e1n disponibles. Los decoradores permiten inyectar c\u00f3digo en la definici\u00f3n real de una clase. Pueden emplearse sobre: definiciones de clase definiciones de propiedades definiciones de funciones par\u00e1metros de m\u00e9todos Los decoradores de TypeScript se llaman atributos en C# y anotaciones en Java Los decoradores de TypeScript son una caracter\u00edstica experimental del compilador y se han propuesto como parte del est\u00e1ndar ECMAScript 7 . Deben activarse modificando el par\u00e1metro experimentalDecorators en tsconfig.json : { \"compilerOptions\" : { \"module\" : \"commonjs\" , \"target\" : \"es3\" , \"sourceMap\" : true , \"experimentalDecorators\" : true }, \"exclude\" : [ \"node_modules\" ] } Declaraci\u00f3n \u00b6 function simpleDecorator ( constructor : Function ) { console . log ( 'simpleDecorator called.' ); } Uso \u00b6 @simpleDecorator class ClassWithSimpleDecorator { } \u00bfCu\u00e1l es la salida del siguiente c\u00f3digo TypeScript? simpleDecorator called. instance_1 : [object Object] instance_2 : [object Object] let instance_1 = new ClassWithSimpleDecorator (); let instance_2 = new ClassWithSimpleDecorator (); console . log ( `instance_1: ${ instance_1 } ` ); console . log ( `instance_2 : ${ instance_2 } ` ); Decoradores m\u00fatiples \u00b6 \u00bfCu\u00e1l es la salida del siguiente c\u00f3digo TypeScript? secondDecorator called. simpleDecorator called. instance_1 : [object Object] function simpleDecorator ( constructor : Function ) { console . log ( 'simpleDecorator called.' ); } function secondDecorator ( constructor : Function ) { console . log ( 'secondDecorator called.' ) } @simpleDecorator @secondDecorator class ClassWithMultipleDecorators { } let instance_1 = new ClassWithMultipleDecorators (); console . log ( `instance_1: ${ instance_1 } ` ); Factor\u00edas de decoradores \u00b6 Los decoradores pueden aceptar par\u00e1metros Una factor\u00eda de decoradores es una funci\u00f3n que devuelve el propio decorador. Ejemplo de factor\u00eda de decoradores \u00b6 function decoratorFactory ( name : string ) { return function ( constructor : Function ) { console . log ( `decorator function called with: ${ name } ` ); } } @decoratorFactory ( 'testName' ) class ClassWithDecoratorFactory { } Salida: decorator function called with: testName Tipos de decoradores \u00b6 Decoradores de clases Decoradores de propiedades Decoradores de propiedades est\u00e1ticas Decoradores de m\u00e9todos Decoradores de par\u00e1metros Lectura recomendada Nathan Rozentals: Mastering TypeScript , Packt Publishing, 2 nd edition, 2017","title":"Inyecci\u00f3n"},{"location":"iiss-oop-3/#caso-3-inyeccion-de-dependencias","text":"","title":"Caso 3 - Inyecci\u00f3n de dependencias"},{"location":"iiss-oop-3/#caballeros-de-la-mesa-redonda","text":"","title":"Caballeros de la mesa redonda"},{"location":"iiss-oop-3/#tomado-de-spring-in-action","text":"A\u00f1adir pruebas unitarias a la soluci\u00f3n siguiente: public class KnightOfTheRoundTable { private String name ; private HolyGrailQuest quest ; public KnightOfTheRoundTable ( String name ) { this . name = name ; quest = new HolyGrailQuest (); } public HolyGrail embarkOnQuest () throws GrailNotFoundException { return quest . embark (); } } public class HolyGrailQuest { public HolyGrailQuest () {} public HolyGrail embark () throws GrailNotFoundException { HolyGrail grail = null ; // Look for grail ... return grail ; } }","title":"Tomado de Spring in Action"},{"location":"iiss-oop-3/#construir-pruebas-con-junit-3","text":"\u00bfD\u00f3nde est\u00e1 el acoplamiento? import junit.framework.TestCase ; public class KnightOfTheRoundTableTest extends TestCase { public void testEmbarkOnQuest () throws GrailNotFoundException { KnightOfTheRoundTable knight = new KnightOfTheRoundTable ( \"CruzadoMagico\" ); HolyGrail grail = knight . embarkOnQuest (); assertNotNull ( grail ); assertTrue ( grail . isHoly ()); } } Instanciaci\u00f3n de HolyGrail Cada vez que se prueba KnightOfTheRoundTable , tambi\u00e9n se prueba HolyGrailQuest . No se puede pedir a HolyGrailQuest que se comporte de otra forma (v.g. devolver null o elevar una excepci\u00f3n)","title":"Construir pruebas con jUnit 3"},{"location":"iiss-oop-3/#ocultar-la-implementacion-detras-de-una-interfaz","text":"public interface Knight { Object embarkOnQuest () throws QuestFailedException ; } public class KnightOfTheRoundTable implements Knight { private String name ; private Quest quest ; public KnightOfTheRoundTable ( String name ) { this . name = name ; quest = new HolyGrailQuest (); } public Object embarkOnQuest () throws QuestFailedException { return quest . embark (); } } public interface Quest { abstract Object embark () throws QuestFailedException ; } public class HolyGrailQuest implements Quest { public HolyGrailQuest () {} public Object embark () throws QuestFailedException { // Do whatever it means to embark on a quest return new HolyGrail (); } } El Knight a\u00fan recibe un tipo espec\u00edfico de Quest \u00bfDebe ser el caballero responsable de obtener un desaf\u00edo?","title":"Ocultar la implementaci\u00f3n detr\u00e1s de una interfaz"},{"location":"iiss-oop-3/#inyectar-dependencias","text":"public class KnightOfTheRoundTable implements Knight { private String name ; private Quest quest ; public KnightOfTheRoundTable ( String name ) { this . name = name ; } public Object embarkOnQuest () throws QuestFailedException { return quest . embark (); } public void setQuest ( Quest quest ) { this . quest = quest ; } } El caballero no es el responsable de averiguar su misi\u00f3n. El caballero s\u00f3lo sabe de su misi\u00f3n a trav\u00e9s de la interfaz Quest . El caballero recibe la misi\u00f3n (se le inyecta) a trav\u00e9s de setQuest() Puede asign\u00e1rsele cualquier implementaci\u00f3n de Quest ( HolyGrailQuest , RescueDamselQuest , etc.)","title":"Inyectar dependencias"},{"location":"iiss-oop-3/#construccion-con-spring","text":"A trav\u00e9s de un fichero de configuraci\u00f3n XML le indicamos los valores inyectables: <?xml version=\"1.0\" encoding=\"UTF-8\"?> <!DOCTYPE beans PUBLIC \"-//SPRING//DTD BEAN//EN\" \"http://www.springframework.org/dtd/spring-beans.dtd\"> <beans> <bean id= \"quest\" class= \"HolyGrailQuest\" /> <bean id= \"knight\" class= \"KnightOfTheRoundTable\" > <constructor-arg> <value> CruzadoMagico </value> </constructor-arg> <property name= \"quest\" > <ref bean= \"quest\" /> </property> </bean> </beans> La inyecci\u00f3n de la dependencia concreta la hace el contenedor ( spring en este ejemplo): import org.springframework.beans.factory.BeanFactory ; import org.springframework.beans.factory.xml.XmlBeanFactory ; public class KnightApp { public static void main ( String [] args ) throws Exception { BeanFactory factory = new XmlBeanFactory ( new FileInputStream ( \"knight.xml\" )); KnightOfTheRoundTable knight = ( KnightOfTheRoundTable ) factory . getBean ( \"knight\" ); knight . embarkOnQuest (); } }","title":"Construcci\u00f3n con spring"},{"location":"iiss-oop-3/#ejemplo-logger","text":"Tambi\u00e9n se puede inyectar la dependencia en el constructor. import java.util.logging.Logger ; public class MyClass { private final static Logger logger ; public MyClass ( Logger logger ) { this . logger = logger ; // write an info log message logger . info ( \"This is a log message.\" ) } } Un contenedor de dependencias en el framework debe responsabilizarse de crear las instancias de Logger e inyectarlas en su sitio (normalmente v\u00eda reflexi\u00f3n o introspecci\u00f3n )","title":"Ejemplo: Logger"},{"location":"iiss-oop-3/#implementacion-final-de-la-orquesta-v08","text":"Los new de PruebaOrquesta de la versi\u00f3n v0.7 siguen introduciendo dependencias de PruebaOrquesta con respecto a los tipos concretos de Instrumento . A trav\u00e9s de un fichero de configuraci\u00f3n orquesta.xml de Spring le indicamos los valores inyectables: <?xml version=\"1.0\" encoding=\"UTF-8\"?> <!DOCTYPE beans PUBLIC \"-//SPRING//DTD BEAN//EN\" \"http://www.springframework.org/dtd/spring-beans.dtd\"> <beans> <bean id= \"trompeta\" class= \"Viento\" /> <bean id= \"violin\" class= \"Cuerda\" /> <bean id= \"tambor\" class= \"Percusion\" /> <bean id= \"viola\" class= \"Cuerda\" /> <bean id= \"cuarteto\" class= \"Orquesta\" > <property name= \"instrumento1\" > <ref bean= \"trompeta\" /> </property> <property name= \"instrumento2\" > <ref bean= \"violin\" /> </property> <property name= \"instrumento3\" > <ref bean= \"viola\" /> </property> <property name= \"instrumento4\" > <ref bean= \"tambor\" /> </property> </bean> </beans> La inyecci\u00f3n de la dependencia concreta la hace el contenedor ( Spring en este ejemplo): import org.springframework.beans.factory.BeanFactory ; import org.springframework.beans.factory.xml.XmlBeanFactory ; public class PruebaOrquesta { public static void main ( String [] args ) throws Exception { BeanFactory factory = new XmlBeanFactory ( new FileInputStream ( \"orquesta.xml\" )); Orquesta orquesta = ( Orquesta ) factory . getBean ( \"cuarteto\" ); for ( Instrumento i : orquesta ) orquesta . afinar ( i ); orquesta . tocar (); } }","title":"Implementaci\u00f3n final de la Orquesta v0.8"},{"location":"iiss-oop-3/#dependencias-en-java","text":"JSR 330 es un est\u00e1ndar de Java para describir las dependencias de una clase con @Inject y otras anotaciones. Hay diversas implementaciones de JSR 330 . public class MyPart { @Inject private Logger logger ; // inject class for database access @Inject private DatabaseAccessClass dao ; @Inject public void createControls ( Composite parent ) { logger . info ( \"UI will start to build\" ); Label label = new Label ( parent , SWT . NONE ); label . setText ( \"Eclipse 4\" ); Text text = new Text ( parent , SWT . NONE ); text . setText ( dao . getNumber ()); } } Esta clase sigue usando new para ciertos elementos de la interfaz. Esto significa que no pensamos reemplazarlos ni siquiera para hacer pruebas.","title":"Dependencias en Java"},{"location":"iiss-oop-3/#ejercicio-identificador-de-bankaccount-con-inyeccion-de-dependencias","text":"Supongamos que queremos obtener un listado ordenado por fecha de creaci\u00f3n de todas las cuentas bancarias. \u00bfC\u00f3mo afecta este cambio a la versi\u00f3n de BankAccount ya implementada con JDK 1.5? Resolver mediante inyecci\u00f3n de dependencias BankAcccount.java : import java.util.* ; import java.io.* ; import java.time.* ; public final class BankAccount implements Comparable < BankAccount > { private final String id ; private LocalDate creationDate ; private Comparator comparator ; public BankAccount ( String number ) { this . id = number ; comparator = new BankAccountComparatorById (); } public LocalDate getCreationDate () { return creationDate ; } public void setCreationDate ( LocalDate date ) { this . creationDate = date ; } public String getId () { return id ; } public void setComparator ( Comparator cmp ) { comparator = cmp ; } @Override public int compareTo ( BankAccount other ) { if ( this == other ) return 0 ; assert this . equals ( other ) : \"compareTo inconsistent with equals.\" ; return comparator . compare ( this , other ); } @Override public boolean equals ( Object other ) { if ( this == other ) return true ; if ( ! ( other instanceof BankAccount )) return false ; BankAccount that = ( BankAccount ) other ; return this . id . equals ( that . getId ()); } @Override public String toString () { return id . toString (); } } BankAcccountComparatorById.java : import java.util.* ; class BankAccountComparatorById implements Comparator < BankAccount > { public int compare ( BankAccount o1 , BankAccount o2 ) { return o1 . getId (). compareTo ( o2 . getId ()); } } BankAcccountComparatorByCreationDate.java : import java.util.* ; class BankAccountComparatorByCreationDate implements Comparator < BankAccount > { public int compare ( BankAccount o1 , BankAccount o2 ) { return o1 . getCreationDate (). compareTo ( o2 . getCreationDate ()); } } Ahora podr\u00eda definirse una anotaci\u00f3n del tipo @comparator(BankAccountComparatorById.className) o @compareById que inyecte a BankAccount una dependencia BankAccountComparatorById en BankAccount.comparator . Creaci\u00f3n de anotaciones en Java Ejemplo de c\u00f3mo crear una anotaci\u00f3n a medida en Java","title":"Ejercicio: Identificador de BankAccount con inyecci\u00f3n de dependencias"},{"location":"iiss-oop-3/#decoradores-en-typescript","text":"Los decoradores de TypeScript son una forma de modificar program\u00e1ticamente la definici\u00f3n de una clase. La definici\u00f3n de una clase describe la forma de la clase, es decir, sus m\u00e9todos y propiedades. S\u00f3lo cuando se instancie la clase, estas propiedades y m\u00e9todos estar\u00e1n disponibles. Los decoradores permiten inyectar c\u00f3digo en la definici\u00f3n real de una clase. Pueden emplearse sobre: definiciones de clase definiciones de propiedades definiciones de funciones par\u00e1metros de m\u00e9todos Los decoradores de TypeScript se llaman atributos en C# y anotaciones en Java Los decoradores de TypeScript son una caracter\u00edstica experimental del compilador y se han propuesto como parte del est\u00e1ndar ECMAScript 7 . Deben activarse modificando el par\u00e1metro experimentalDecorators en tsconfig.json : { \"compilerOptions\" : { \"module\" : \"commonjs\" , \"target\" : \"es3\" , \"sourceMap\" : true , \"experimentalDecorators\" : true }, \"exclude\" : [ \"node_modules\" ] }","title":"Decoradores en TypeScript"},{"location":"iiss-oop-3/#declaracion","text":"function simpleDecorator ( constructor : Function ) { console . log ( 'simpleDecorator called.' ); }","title":"Declaraci\u00f3n"},{"location":"iiss-oop-3/#uso","text":"@simpleDecorator class ClassWithSimpleDecorator { } \u00bfCu\u00e1l es la salida del siguiente c\u00f3digo TypeScript? simpleDecorator called. instance_1 : [object Object] instance_2 : [object Object] let instance_1 = new ClassWithSimpleDecorator (); let instance_2 = new ClassWithSimpleDecorator (); console . log ( `instance_1: ${ instance_1 } ` ); console . log ( `instance_2 : ${ instance_2 } ` );","title":"Uso"},{"location":"iiss-oop-3/#decoradores-mutiples","text":"\u00bfCu\u00e1l es la salida del siguiente c\u00f3digo TypeScript? secondDecorator called. simpleDecorator called. instance_1 : [object Object] function simpleDecorator ( constructor : Function ) { console . log ( 'simpleDecorator called.' ); } function secondDecorator ( constructor : Function ) { console . log ( 'secondDecorator called.' ) } @simpleDecorator @secondDecorator class ClassWithMultipleDecorators { } let instance_1 = new ClassWithMultipleDecorators (); console . log ( `instance_1: ${ instance_1 } ` );","title":"Decoradores m\u00fatiples"},{"location":"iiss-oop-3/#factorias-de-decoradores","text":"Los decoradores pueden aceptar par\u00e1metros Una factor\u00eda de decoradores es una funci\u00f3n que devuelve el propio decorador.","title":"Factor\u00edas de decoradores"},{"location":"iiss-oop-3/#ejemplo-de-factoria-de-decoradores","text":"function decoratorFactory ( name : string ) { return function ( constructor : Function ) { console . log ( `decorator function called with: ${ name } ` ); } } @decoratorFactory ( 'testName' ) class ClassWithDecoratorFactory { } Salida: decorator function called with: testName","title":"Ejemplo de factor\u00eda de decoradores"},{"location":"iiss-oop-3/#tipos-de-decoradores","text":"Decoradores de clases Decoradores de propiedades Decoradores de propiedades est\u00e1ticas Decoradores de m\u00e9todos Decoradores de par\u00e1metros Lectura recomendada Nathan Rozentals: Mastering TypeScript , Packt Publishing, 2 nd edition, 2017","title":"Tipos de decoradores"},{"location":"iiss-oop-4/","text":"OBJETOS - C\u00f3digo duplicado Caso 4 - C\u00e1lculo de n\u00f3minas \u00b6 C\u00f3digo duplicado \u00b6 Implementaci\u00f3n de n\u00f3minas v0.1 \u00b6 En la siguiente implementaci\u00f3n, \u00bfd\u00f3nde hay c\u00f3digo duplicado? C\u00f3digo duplicado en los constructores de las clases y subclases Refactorizar delegando hacia la superclase public class Empleado { Comparable id ; String name ; public Empleado ( String id , String name ) { this . id = id ; this . name = name ; } public void print () { System . out . println ( id + \" \" + name ); } } public class Autonomo extends Empleado { String vatCode ; public Autonomo ( String id , String name , String vat ) { this . id = id ; this . name = name ; this . vatCode = vat ; } public void print () { System . out . println ( id + \" \" + name + \" \" + vatCode ); } } public class Prueba { public static void main ( String [] args ) { Empleado e = new Empleado ( \"0001\" , \"Enrique\" ); Empleado a = new Autonomo ( \"0002\" , \"Ana\" , \"12345-A\" ); e . print (); a . print (); } } N\u00f3minas v0.2 \u00b6 Requisito: los trabajadores aut\u00f3nomos cobran por horas (no tienen un salario fijo bruto) Incluimos el m\u00e9todo computeMonthlySalary para el c\u00e1lculo de la n\u00f3mina mensual \u00bfEst\u00e1n descohesionadas las clases? \u00bfTodos los empleados deben tener un salario anual yearlyGrossSalary bruto? Los aut\u00f3nomos no... El m\u00e9todo de c\u00e1lculo del salario est\u00e1 descohesionado public class Empleado { Comparable id ; String name ; float yearlyGrossSalary ; public Empleado ( String id , String name ) { this . id = id ; this . name = name ; } void setSalary ( float s ) { yearlyGrossSalary = s ; } public void print () { System . out . print ( id + \" \" + name ); } public float computeMonthlySalary () { return yearlyGrossSalary / 12 ; } } public class Autonomo extends Empleado { String vatCode ; float workingHours ; public Autonomo ( String id , String name , String vat ) { super ( id , name ); this . vatCode = vat ; this . workingHours = 0.0 ; } public float computeMonthlySalary () { return workingHours * Company . getHourlyRate () * ( 1.0 + Company . getVatRate ()); } @Override public void print () { super . print (); System . out . print ( \" \" + vatCode ); } } public class Prueba { public static void main ( String [] args ) { Empleado e = new Empleado ( \"0001\" , \"Enrique\" ); Empleado a = new Autonomo ( \"0001\" , \"Ana\" , \"12345-A\" ); e . print (); System . out . println (); a . print (); System . out . println (); } } N\u00f3minas v0.3 \u00b6 public abstract class Empleado { /* ... */ public abstract float computeMonthlySalary (); } public class Plantilla extends Empleado { float yearlyGrossSalary ; /* ... */ float setSalary ( float s ) { yearlyGrossSalary = s ; } public float computeMonthlySalary () { return yearlyGrossSalary / 12 ; } } public class Autonomo extends Empleado { String vatCode ; float workingHours ; public Autonomo ( String id , String name , String vat ) { super ( id , name ); this . vatCode = vat ; this . workingHours = 0.0 ; } public void addWorkingHours ( float workingHours ){ this . workingHours += workingHours ; } public float computeMonthlySalary () { return workingHours * Company . getHourlyRate () * ( 1.0 + Company . getVatRate ()); } @Override public void print () { super . print (); System . out . print ( \" \" + vatCode ); } } public class Prueba { public static void main ( String [] args ) { Empleado e = new Plantilla ( \"0001\" , \"Pepe\" ); e . setSalary ( 25000.0 ); Empleado a = new Autonomo ( \"0001\" , \"Ana\" , \"12345-A\" ); a . addWorkingHours ( 30.0 ); e . print (); System . out . println ( \" Salario: \" + e . computeMonthlySalary () + \" EUR\" ); a . print (); System . out . println ( \" Salario: \" + a . computeMonthlySalary () + \" EUR\" ); } } Refactoring \u00b6 Hacer refactoring es hacer peque\u00f1as transformaciones en el c\u00f3digo que mantienen el sistema funcional, sin a\u00f1adir nuevas funcionalidades. Refactoring is a disciplined technique for restructuring an existing body of code, altering its internal structure without changing its external behavior \u2014 M. Fowler , www.refactoring.com A change made to the internal structure of the software to make it easier to understand and cheaper to modify without changing its observable behavior \u2013 M. Fowler (2008): Refactoring... Lectura recomendada Hunt & Thomas. The Pragmatic Programmer , 1999. Cap\u00edtulo: Refactoring Motivos para refactoring \u00b6 C\u00f3digo duplicado Rutinas demasiado largas Bucles demasiado largos o demasiado anidados Clases poco cohesionadas Interfaz de una clase con un nivel de abstracci\u00f3n poco consistente Demasiados par\u00e1metros en una lista de par\u00e1metros Muchos cambios en una clase tienden a estar compartimentalizados (afectan solo a una parte) Muchos cambios requieren modificaciones en paralelo a varias clases Hay que cambiar jerarqu\u00edas de herencia en paralelo Hay que cambiar muchas sentencias case en paralelo Etc. Lectura recomendada McConnell. Code Complete , 2004. \u00bfCu\u00e1l es la primera raz\u00f3n para hacer refactoring? C\u00f3digo duplicado C\u00f3digo duplicado \u00b6 Lectura recomendada Hunt & Thomas. The Pragmatic Programmer , 1999. Cap\u00edtulo DRY\u2014The Evils of Duplication \u00bfPor qu\u00e9 no duplicar? \u00b6 Mantenimiento Cambios (no s\u00f3lo a nivel de c\u00f3digo) Trazabilidad Causas de la duplicaci\u00f3n \u00b6 Impuesta : No hay elecci\u00f3n Inadvertida : No me he dado cuenta Impaciencia : No puedo esperar Simultaneidad : Ha sido otro Principio DRY \u2013 Don't Repeat Yourself! \u00b6 by Hunt & Thomas (1999) Copy and paste is a design error \u2013 McConnell (1998) Duplicaci\u00f3n impuesta \u00b6 La gesti\u00f3n del proyecto as\u00ed nos lo exige. Algunos ejemplos: Representaciones m\u00faltiples de la informaci\u00f3n: varias implementaciones de un TAD que necesita guardar elementos de distintos tipos, cuando el lenguaje no permite genericidad el esquema de una BD configurado en la BD y en el c\u00f3digo fuente a trav\u00e9s de un ORM Documentaci\u00f3n del c\u00f3digo: c\u00f3digo incrustado en javadocs Casos de prueba: pruebas unitarias con jUnit Caracter\u00edsticas del lenguaje: C/C++ header files IDL specs C\u00f3mo evitaba Java la duplicaci\u00f3n en sus containers Cuando el lenguaje no ten\u00eda capacidad de usar tipos gen\u00e9ricos (hasta el JDK 1.4), podr\u00eda aparecer la necesidad de duplicar c\u00f3digo a la hora de implementar un TAD contenedor, pues habr\u00eda que repetir todo el c\u00f3digo de manejo del TAD para cada tipo de elemento contenido. Para evitarlo, Java us\u00f3 un workaround : todas las clases en Java heredan de Object . As\u00ed una clase que implementara un TAD contenedor de elementos de otra clase, tan solo ten\u00eda que declarar los elementos contenidos de tipo Object . M\u00e1s tarde (a partir del JDK 1.5) introdujo los tipos gen\u00e9ricos y ya no era necesario usar dicho workaround basado en Object para evitar la duplicaci\u00f3n T\u00e9cnicas de soluci\u00f3n \u00b6 Generadores de c\u00f3digo : para evitar duplicar representaciones m\u00faltiples de la informaci\u00f3n Herramientas de ingenier\u00eda inversa : para generar c\u00f3digo a partir de un esquema de BD \u2013 v.g. jeddict para crear clases JPA, visualizar y modificar BDs y automatizar la generaci\u00f3n de c\u00f3digo Java EE. Plantillas : Tipos gen\u00e9ricos del lenguaje (Java, C++, TypeScript, etc.) o mediante un motor de plantillas \u2013 v.g. Apache Velocity template language ( VTL ) Metadatos : Anotaciones @ en Java, decoradores en TypeScript, etc. Herramientas de documentaci\u00f3n (v.g. asciidoctor : inclusi\u00f3n de ficheros y formateo de c\u00f3digo fuente ). Herramientas de programaci\u00f3n literaria Ayuda del IDE Herramientas de property-based testing , como Hypothesis (python), RapidCheck (C++), jqwik (Java) o QuickCheck (originalmente para Haskell). Property-based testing \u00bfC\u00f3mo reducir la duplicaci\u00f3n de c\u00f3digo al programar pruebas unitarias? Ejemplo de property-based testing con Hypothesis en Python: from hypothesis import given import hypothesis.strategies as some @given ( some . lists ( some . integers ())) def test_list_size_is_invariant_across_sorting ( a_list ): original_length = len ( a_list ) a_list . sort () assert len ( a_list ) == original_length @given ( some . lists ( some . text ())) def test_sorted_result_is_ordered ( a_list ): a_list . sort () for i in range ( len ( a_list ) - 1 ): assert a_list [ i ] <= a_list [ i + 1 ] Leer el Consejo n\u00ba 71 del libro de Hunt & Thomas (2020) . Duplicaci\u00f3n inadvertida \u00b6 Normalmente tiene origen en un dise\u00f1o inapropiado. Fuente de numerosos problemas de integraci\u00f3n. Ejemplo: c\u00f3digo duplicado \u2013 versi\u00f3n 1 \u00b6 public class Line { public Point start ; public Point end ; public double length ; } \u00bfD\u00f3nde est\u00e1 la duplicaci\u00f3n? Realmente length ya est\u00e1 definido con start y end . \u00bfMejor as\u00ed...? public class Line { public Point start ; public Point end ; public double length () { return start . distanceTo ( end ); } } \u00bfEs conveniente aplicar siempre DRY? A veces se puede optar por violar DRY por razones de rendimiento. Ejemplo: aplicando memoization \u2013 versi\u00f3n 2 \u00b6 Memoization : cachear los resultados de c\u00f3mputos costosos public class Line { private boolean changed ; private double length ; private Point start ; private Point end ; public void setStart ( Point p ) { start = p ; changed = true ; } public void setEnd ( Point p ) { end = p ; changed = true ; } public Point getStart () { return start ; } public Point getEnd () { return end ; } public double getLength () { if ( changed ) { length = start . distanceTo ( end ); changed = false ; } return length ; } } La t\u00e9cnica de memoization es menos problem\u00e1tica si queda dentro de los l\u00edmites de la clase/m\u00f3dulo. Otras veces no merece la pena violar DRY por rendimiento: \u00a1las cach\u00e9s y los optimizadores de c\u00f3digo tambi\u00e9n hacen su labor! Principio de acceso uniforme \u00b6 All services offered by a module should be available through a uniform notation, which does not betray whether they are implemented through storage or through computation B. Meyer Conviene aplicar el principio de acceso uniforme para que sea m\u00e1s f\u00e1cil a\u00f1adir mejoras de rendimiento (v.g. caching) Ejemplo: acceso uniforme en C# \u2013 versi\u00f3n 3 \u00b6 public class Line { private Point Start ; private Point End ; private double Length ; public Point Start { get { return Start ; } set { Start = value ; } } public Point End { get { return End ; } set { Start = value ; } } public double Length { get { return Start . distanceTo ( End ); } } } Ejemplo: acceso uniforme en Scala \u00b6 Llamadas a m\u00e9todos con par\u00e9ntesis: class Complejo ( real : Double , imaginaria : Double ) { def re () = real def im () = imaginaria override def toString () = \"\" + re () + ( if ( im () < 0 ) \"\" else \"+\" ) + im () + \"i\" } object NumerosComplejos { def main () : Unit = { val c = new Complejo ( 1.2 , 3.4 ) println ( \"N\u00famero complejo: \" + c . toString ()) println ( \"Parte imaginaria: \" + c . im ()) } } Llamadas a m\u00e9todos sin par\u00e9ntesis, igual que si fueran atributos: class Complejo ( real : Double , imaginaria : Double ) { def re = real def im = imaginaria override def toString () = \"\" + re + ( if ( im < 0 ) \"\" else \"+\" ) + im + \"i\" } object NumerosComplejos { def main () : Unit = { val c = new Complejo ( 1.2 , 3.4 ) println ( \"N\u00famero complejo: \" + c ) println ( \"Parte imaginaria: \" + c . im ) } } Duplicaci\u00f3n por impaciencia \u00b6 Los peligros del copy&paste \"V\u00edsteme despacio que tengo prisa\" ( shortcuts make for long delays ). Ejemplos: Meter el main de Java en cualquier clase Fiasco del a\u00f1o 2000 Duplicaci\u00f3n por simultaneidad \u00b6 No resoluble a nivel de t\u00e9cnicas de construcci\u00f3n Hace falta metodolog\u00eda, gesti\u00f3n de equipos + herramientas de comunicaci\u00f3n Ortogonalidad \u00b6 Dos componentes A y B son ortogonales ( A \\perp B A \\perp B ) si los cambios en uno no afectan al otro. Suponen m\u00e1s independencia y menos acoplamiento. Por ejemplo: La base de datos debe ser ortogonal a la interfaz de usuario En un helic\u00f3ptero, los mandos de control no suelen ser ortogonales A Nonorthogonal System ( Hunt, 2020 ) Helicopters have four basic controls. The cyclic is the stick you hold in your right hand. Move it, and the helicopter moves in the corresponding direction. Your left hand holds the collective pitch lever. Pull up on this and you increase the pitch on all the blades, generating lift. At the end of the pitch lever is the throttle. Finally you have two foot pedals, which vary the amount of tail rotor thrust and so help turn the helicopter. \u201cEasy!,\u201d you think. \u201cGently lower the collective pitch lever and you\u2019ll descend gracefully to the ground, a hero.\u201d However, when you try it, you discover that life isn\u2019t that simple. The helicopter\u2019s nose drops, and you start to spiral down to the left. Suddenly you discover that you\u2019re flying a system where every control input has secondary effects. Lower the left-hand lever and you need to add compensating backward movement to the right-hand stick and push the right pedal. But then each of these changes affects all of the other controls again. Suddenly you\u2019re juggling an unbelievably complex system, where every change impacts all the other inputs. Your workload is phenomenal: your hands and feet are constantly moving, trying to balance all the interacting forces. Helicopter controls are decidedly not orthogonal. Beneficios de la ortogonalidad \u00b6 Mayor productividad \u00b6 Es m\u00e1s f\u00e1cil escribir un componente peque\u00f1o y auto-contenido que un bloque muy grande de c\u00f3digo. El tiempo de desarrollo y pruebas se reduce Se pueden combinar unos componentes con otros m\u00e1s f\u00e1cilmente. Mayor reutilizaci\u00f3n . En teor\u00eda, si A \\perp B A \\perp B , el componente A sirve para m m prop\u00f3sitos y B sirve para n n , entonces A \\cup B A \\cup B sirve para m \\times n m \\times n prop\u00f3sitos. La falta de cohesi\u00f3n perjudica la reutilizaci\u00f3n \u2192 \u00bfy si hay que hacer una nueva versi\u00f3n gr\u00e1fica de una aplicaci\u00f3n de l\u00ednea de comandos que lleva incrustada la escritura en consola con System.out.println ? Pueden descohesionar! Menor riesgo \u00b6 Defectos aislados, m\u00e1s f\u00e1ciles de arreglar Menor fragilidad del sistema global. Los problemas provocados por cambios en un \u00e1rea se limitan a ese \u00e1rea M\u00e1s f\u00e1cil de probar , pues ser\u00e1 m\u00e1s f\u00e1cil construir pruebas individuales de cada uno de sus componentes (por ejemplo, las t\u00e9cnicas de mocking son m\u00e1s sencillas) Niveles de aplicaci\u00f3n de la ortogonalizad \u00b6 La ortogonalidad es aplicable a: el dise\u00f1o la codificaci\u00f3n las pruebas bibliotecas la documentaci\u00f3n A nivel de dise\u00f1o , los patrones de dise\u00f1o y las arquitecturas como MVC facilitan la construcci\u00f3n de componentes ortogonales. Lectura recomendada Leer el Topic 10: Orthogonality de ( Hunt, 2020 ). T\u00e9cnicas de codificaci\u00f3n \u00b6 T\u00e9cnicas de codificaci\u00f3n para fomentar la ortogonalidad: Hacer refactoring Codificar patrones de dise\u00f1o: strategy, template method, etc. Evitar datos globales y singletons : \u00bfqu\u00e9 pasar\u00eda si hubiera que hacer una versi\u00f3n multithreaded de una aplicaci\u00f3n? Inyectar : pasar expl\u00edcitamente el contexto (dependencia) como par\u00e1metro a los constructores Usar anotaciones (Java), decoradores (TypeScript) o atributos (C#) Desacoplar : Ley de Demeter \u2014No hables con extra\u00f1os Usar programaci\u00f3n orientada a aspectos Desacoplar - ley de Demeter \u00b6 Al pedir un servicio a un objeto, el servicio debe ser realizado de parte nuestra, no que nos devuelva un tercero con el que tratar para realizarlo Ejemplo : public boolean canWrite ( User user ) { if ( user . isAnonymous ()) return false ; else { return user . getGroup (). hasPermission ( Permission . WRITE ); } } Refactorizaci\u00f3n: definir un m\u00e9todo User.hasPermission() Lectura recomendada Leer el Topic 28: Decoupling de ( Hunt, 2020 ). Inyectar el contexto \u00b6 Pasar expl\u00edcitamente el contexto (dependencia) como par\u00e1metro a los constructores de la clase Ejemplo: patr\u00f3n estrategia \u00b6 En el patr\u00f3n de dise\u00f1o strategy , pasar el contexto a la estrategia en su creaci\u00f3n Ejemplo: caballeros de la mesa redonda \u00b6 public interface Knight { Object embarkOnQuest () throws QuestFailedException ; } public class KnightOfTheRoundTable implements Knight { private String name ; private Quest quest ; public KnightOfTheRoundTable ( String name , Quest quest ) { this . name = name ; this . quest = quest ; } public Object embarkOnQuest () throws QuestFailedException { return quest . embark (); } public void setQuest ( Quest quest ) { this . quest = quest ; } } public interface Quest { abstract Object embark () throws QuestFailedException ; } Ley de Demeter para funciones \u00b6 Los m\u00e9todos de un objeto solo deben hacer llamadas a m\u00e9todos... propios de objetos pasados como par\u00e1metros de objetos creados por ellos mismos de objetos declarados en el mismo m\u00e9todo class Demeter { private A a ; private int func (); public void example ( B b ); void example ( B b ) { C c ; int f = func (); // (caso 1) b . invert (); // (caso 2) a = new A (); a . setActive (); // (caso 3) c . print (); // (caso 4) } Interfaces fluent \u00b6 Excepci\u00f3n a la ley de Demeter Hay una excepci\u00f3n notable a la prohibici\u00f3n de encadenar llamadas a funciones de la ley de Demeter. Esta regla no aplica si es muy poco probable que haya cambios en las cosas que se encadenan. En la pr\u00e1ctica, cualquier parte de tu aplicaci\u00f3n debe considerarse como algo que es probable que cambie; cualquier elemento de una biblioteca de un tercero debe considerarse vol\u00e1til, en particular si quienes mantienen dicha biblioteca suelen cambiar su API de una versi\u00f3n a otra. Las librer\u00edas que vienen con el lenguaje suelen ser bastante estables, as\u00ed que ejemplos de c\u00f3digo como el siguiente son aceptables como excepci\u00f3n a esta interpretaci\u00f3n de la ley de Demeter: List < String > myList = Arrays . asList ( \"a1\" , \"a2\" , \"b1\" , \"c2\" , \"c1\" ); myList . stream () . filter ( s -> s . startsWith ( \"c\" )) . map ( String :: toUpperCase ) . sorted () . forEach ( System . out :: println ); Los m\u00e9todos stream , filter , map , sorted y forEach son parte de las nuevas interfaces funcionales para manejar streams , incorporadas a las colecciones (v.g. List ) del lenguaje desde la versi\u00f3n Java 8. Este tipo de interfaces como la del API de streams de Java se conoce como fluent interfaces . La programaci\u00f3n con streams se tratar\u00e1 en el cap\u00edtulo sobre Programaci\u00f3n basada en Eventos Las interfaces funcionales se tratar\u00e1n en el cap\u00edtulo sobre Programaci\u00f3n Funcional Cr\u00edticas a la ley de Demeter \u00b6 La ley de Demeter, \u00bfrealmente ayuda a crear c\u00f3digo m\u00e1s mantenible? Ejemplo: pintar gr\u00e1ficos de grabadoras \u00b6 Pintar un gr\u00e1fico con los datos registrados por una serie de grabadoras ( Recorder ) dispersas por el mundo. Cada grabadora est\u00e1 en una ubicaci\u00f3n ( Location ), que tiene una zona horaria ( TimeZone ). Los usuarios seleccionan ( Selection ) una grabadora y pintan sus datos etiquetados con la zona horaria correcta... public void plotDate ( Date aDate , Selection aSelection ) { TimeZone tz = aSelection . getRecorder (). getLocation (). getZone (); } Cr\u00edticas \u00b6 Multiplicidad de dependencias: plotDate \\dashrightarrow \\dashrightarrow Selection , Recorder , Location , TimeZone . Si cambia la implementaci\u00f3n de Location de forma que ya no incluye directamente una TimeZone , hay que cambiar plotDate A\u00f1adir un m\u00e9todo delegado getTimeZone a Selection . As\u00ed plotDate no se entera de si la TimeZone le llega desde Recorder o desde un objeto contenido en Recorder . public void plotDate ( Date aDate , TimeZone tz ) { /* ... */ } plotDate ( someDate , someSelection . getTimeZone ()); Ahora plotDate \\dashrightarrow \\dashrightarrow Selection , TimeZone , pero se han eliminado las restantes dependencias. Costes de espacio y ejecuci\u00f3n de m\u00e9todos wrapper que reenv\u00edan la petici\u00f3n al objeto delegado: violar la ley de Demeter para mejorar el rendimiento Otros ejemplos de mejora del rendimiento: desnormalizaci\u00f3n de BBDD Ortogonalidad en toolkits y bibliotecas \u00b6 Muchas bibliotecas actuales implementan la ortogonalidad a trav\u00e9s de metadatos, o atributos o etiquetas (@ tag ), tambi\u00e9n llamados anotaciones en Java y decoradores en TypeScript. Los metadatos se emplean para proporcionar prop\u00f3sitos espec\u00edficos, como v.g. persistencia de objetos, transacciones, etc. Por ejemplo, Spring o EJB utilizan anotaciones @ declarativas para expresar la transaccionalidad de una operaci\u00f3n o la persistencia de una propiedad de una clase fuera del m\u00e9todo que debe ejecutar dichas funcionalidades. Otro m\u00e9todo para implementar la ortogonalidad es usar Aspectos y Aspect-Oriented Programming (AOP). Este m\u00e9todo es empleado por el framework Spring. Estudiar ahora el cap\u00edtulo Aspectos Estudiar luego el cap\u00edtulo Calidad","title":"Duplicaci\u00f3n"},{"location":"iiss-oop-4/#caso-4-calculo-de-nominas","text":"","title":"Caso 4 - C\u00e1lculo de n\u00f3minas"},{"location":"iiss-oop-4/#codigo-duplicado","text":"","title":"C\u00f3digo duplicado"},{"location":"iiss-oop-4/#implementacion-de-nominas-v01","text":"En la siguiente implementaci\u00f3n, \u00bfd\u00f3nde hay c\u00f3digo duplicado? C\u00f3digo duplicado en los constructores de las clases y subclases Refactorizar delegando hacia la superclase public class Empleado { Comparable id ; String name ; public Empleado ( String id , String name ) { this . id = id ; this . name = name ; } public void print () { System . out . println ( id + \" \" + name ); } } public class Autonomo extends Empleado { String vatCode ; public Autonomo ( String id , String name , String vat ) { this . id = id ; this . name = name ; this . vatCode = vat ; } public void print () { System . out . println ( id + \" \" + name + \" \" + vatCode ); } } public class Prueba { public static void main ( String [] args ) { Empleado e = new Empleado ( \"0001\" , \"Enrique\" ); Empleado a = new Autonomo ( \"0002\" , \"Ana\" , \"12345-A\" ); e . print (); a . print (); } }","title":"Implementaci\u00f3n de n\u00f3minas v0.1"},{"location":"iiss-oop-4/#nominas-v02","text":"Requisito: los trabajadores aut\u00f3nomos cobran por horas (no tienen un salario fijo bruto) Incluimos el m\u00e9todo computeMonthlySalary para el c\u00e1lculo de la n\u00f3mina mensual \u00bfEst\u00e1n descohesionadas las clases? \u00bfTodos los empleados deben tener un salario anual yearlyGrossSalary bruto? Los aut\u00f3nomos no... El m\u00e9todo de c\u00e1lculo del salario est\u00e1 descohesionado public class Empleado { Comparable id ; String name ; float yearlyGrossSalary ; public Empleado ( String id , String name ) { this . id = id ; this . name = name ; } void setSalary ( float s ) { yearlyGrossSalary = s ; } public void print () { System . out . print ( id + \" \" + name ); } public float computeMonthlySalary () { return yearlyGrossSalary / 12 ; } } public class Autonomo extends Empleado { String vatCode ; float workingHours ; public Autonomo ( String id , String name , String vat ) { super ( id , name ); this . vatCode = vat ; this . workingHours = 0.0 ; } public float computeMonthlySalary () { return workingHours * Company . getHourlyRate () * ( 1.0 + Company . getVatRate ()); } @Override public void print () { super . print (); System . out . print ( \" \" + vatCode ); } } public class Prueba { public static void main ( String [] args ) { Empleado e = new Empleado ( \"0001\" , \"Enrique\" ); Empleado a = new Autonomo ( \"0001\" , \"Ana\" , \"12345-A\" ); e . print (); System . out . println (); a . print (); System . out . println (); } }","title":"N\u00f3minas v0.2"},{"location":"iiss-oop-4/#nominas-v03","text":"public abstract class Empleado { /* ... */ public abstract float computeMonthlySalary (); } public class Plantilla extends Empleado { float yearlyGrossSalary ; /* ... */ float setSalary ( float s ) { yearlyGrossSalary = s ; } public float computeMonthlySalary () { return yearlyGrossSalary / 12 ; } } public class Autonomo extends Empleado { String vatCode ; float workingHours ; public Autonomo ( String id , String name , String vat ) { super ( id , name ); this . vatCode = vat ; this . workingHours = 0.0 ; } public void addWorkingHours ( float workingHours ){ this . workingHours += workingHours ; } public float computeMonthlySalary () { return workingHours * Company . getHourlyRate () * ( 1.0 + Company . getVatRate ()); } @Override public void print () { super . print (); System . out . print ( \" \" + vatCode ); } } public class Prueba { public static void main ( String [] args ) { Empleado e = new Plantilla ( \"0001\" , \"Pepe\" ); e . setSalary ( 25000.0 ); Empleado a = new Autonomo ( \"0001\" , \"Ana\" , \"12345-A\" ); a . addWorkingHours ( 30.0 ); e . print (); System . out . println ( \" Salario: \" + e . computeMonthlySalary () + \" EUR\" ); a . print (); System . out . println ( \" Salario: \" + a . computeMonthlySalary () + \" EUR\" ); } }","title":"N\u00f3minas v0.3"},{"location":"iiss-oop-4/#refactoring","text":"Hacer refactoring es hacer peque\u00f1as transformaciones en el c\u00f3digo que mantienen el sistema funcional, sin a\u00f1adir nuevas funcionalidades. Refactoring is a disciplined technique for restructuring an existing body of code, altering its internal structure without changing its external behavior \u2014 M. Fowler , www.refactoring.com A change made to the internal structure of the software to make it easier to understand and cheaper to modify without changing its observable behavior \u2013 M. Fowler (2008): Refactoring... Lectura recomendada Hunt & Thomas. The Pragmatic Programmer , 1999. Cap\u00edtulo: Refactoring","title":"Refactoring"},{"location":"iiss-oop-4/#motivos-para-refactoring","text":"C\u00f3digo duplicado Rutinas demasiado largas Bucles demasiado largos o demasiado anidados Clases poco cohesionadas Interfaz de una clase con un nivel de abstracci\u00f3n poco consistente Demasiados par\u00e1metros en una lista de par\u00e1metros Muchos cambios en una clase tienden a estar compartimentalizados (afectan solo a una parte) Muchos cambios requieren modificaciones en paralelo a varias clases Hay que cambiar jerarqu\u00edas de herencia en paralelo Hay que cambiar muchas sentencias case en paralelo Etc. Lectura recomendada McConnell. Code Complete , 2004. \u00bfCu\u00e1l es la primera raz\u00f3n para hacer refactoring? C\u00f3digo duplicado","title":"Motivos para refactoring"},{"location":"iiss-oop-4/#codigo-duplicado_1","text":"Lectura recomendada Hunt & Thomas. The Pragmatic Programmer , 1999. Cap\u00edtulo DRY\u2014The Evils of Duplication","title":"C\u00f3digo duplicado"},{"location":"iiss-oop-4/#por-que-no-duplicar","text":"Mantenimiento Cambios (no s\u00f3lo a nivel de c\u00f3digo) Trazabilidad","title":"\u00bfPor qu\u00e9 no duplicar?"},{"location":"iiss-oop-4/#causas-de-la-duplicacion","text":"Impuesta : No hay elecci\u00f3n Inadvertida : No me he dado cuenta Impaciencia : No puedo esperar Simultaneidad : Ha sido otro","title":"Causas de la duplicaci\u00f3n"},{"location":"iiss-oop-4/#principio-dry-dont-repeat-yourself","text":"by Hunt & Thomas (1999) Copy and paste is a design error \u2013 McConnell (1998)","title":"Principio DRY \u2013 Don't Repeat Yourself!"},{"location":"iiss-oop-4/#duplicacion-impuesta","text":"La gesti\u00f3n del proyecto as\u00ed nos lo exige. Algunos ejemplos: Representaciones m\u00faltiples de la informaci\u00f3n: varias implementaciones de un TAD que necesita guardar elementos de distintos tipos, cuando el lenguaje no permite genericidad el esquema de una BD configurado en la BD y en el c\u00f3digo fuente a trav\u00e9s de un ORM Documentaci\u00f3n del c\u00f3digo: c\u00f3digo incrustado en javadocs Casos de prueba: pruebas unitarias con jUnit Caracter\u00edsticas del lenguaje: C/C++ header files IDL specs C\u00f3mo evitaba Java la duplicaci\u00f3n en sus containers Cuando el lenguaje no ten\u00eda capacidad de usar tipos gen\u00e9ricos (hasta el JDK 1.4), podr\u00eda aparecer la necesidad de duplicar c\u00f3digo a la hora de implementar un TAD contenedor, pues habr\u00eda que repetir todo el c\u00f3digo de manejo del TAD para cada tipo de elemento contenido. Para evitarlo, Java us\u00f3 un workaround : todas las clases en Java heredan de Object . As\u00ed una clase que implementara un TAD contenedor de elementos de otra clase, tan solo ten\u00eda que declarar los elementos contenidos de tipo Object . M\u00e1s tarde (a partir del JDK 1.5) introdujo los tipos gen\u00e9ricos y ya no era necesario usar dicho workaround basado en Object para evitar la duplicaci\u00f3n","title":"Duplicaci\u00f3n impuesta"},{"location":"iiss-oop-4/#tecnicas-de-solucion","text":"Generadores de c\u00f3digo : para evitar duplicar representaciones m\u00faltiples de la informaci\u00f3n Herramientas de ingenier\u00eda inversa : para generar c\u00f3digo a partir de un esquema de BD \u2013 v.g. jeddict para crear clases JPA, visualizar y modificar BDs y automatizar la generaci\u00f3n de c\u00f3digo Java EE. Plantillas : Tipos gen\u00e9ricos del lenguaje (Java, C++, TypeScript, etc.) o mediante un motor de plantillas \u2013 v.g. Apache Velocity template language ( VTL ) Metadatos : Anotaciones @ en Java, decoradores en TypeScript, etc. Herramientas de documentaci\u00f3n (v.g. asciidoctor : inclusi\u00f3n de ficheros y formateo de c\u00f3digo fuente ). Herramientas de programaci\u00f3n literaria Ayuda del IDE Herramientas de property-based testing , como Hypothesis (python), RapidCheck (C++), jqwik (Java) o QuickCheck (originalmente para Haskell). Property-based testing \u00bfC\u00f3mo reducir la duplicaci\u00f3n de c\u00f3digo al programar pruebas unitarias? Ejemplo de property-based testing con Hypothesis en Python: from hypothesis import given import hypothesis.strategies as some @given ( some . lists ( some . integers ())) def test_list_size_is_invariant_across_sorting ( a_list ): original_length = len ( a_list ) a_list . sort () assert len ( a_list ) == original_length @given ( some . lists ( some . text ())) def test_sorted_result_is_ordered ( a_list ): a_list . sort () for i in range ( len ( a_list ) - 1 ): assert a_list [ i ] <= a_list [ i + 1 ] Leer el Consejo n\u00ba 71 del libro de Hunt & Thomas (2020) .","title":"T\u00e9cnicas de soluci\u00f3n"},{"location":"iiss-oop-4/#duplicacion-inadvertida","text":"Normalmente tiene origen en un dise\u00f1o inapropiado. Fuente de numerosos problemas de integraci\u00f3n.","title":"Duplicaci\u00f3n inadvertida"},{"location":"iiss-oop-4/#ejemplo-codigo-duplicado-version-1","text":"public class Line { public Point start ; public Point end ; public double length ; } \u00bfD\u00f3nde est\u00e1 la duplicaci\u00f3n? Realmente length ya est\u00e1 definido con start y end . \u00bfMejor as\u00ed...? public class Line { public Point start ; public Point end ; public double length () { return start . distanceTo ( end ); } } \u00bfEs conveniente aplicar siempre DRY? A veces se puede optar por violar DRY por razones de rendimiento.","title":"Ejemplo: c\u00f3digo duplicado \u2013 versi\u00f3n 1"},{"location":"iiss-oop-4/#ejemplo-aplicando-memoization-version-2","text":"Memoization : cachear los resultados de c\u00f3mputos costosos public class Line { private boolean changed ; private double length ; private Point start ; private Point end ; public void setStart ( Point p ) { start = p ; changed = true ; } public void setEnd ( Point p ) { end = p ; changed = true ; } public Point getStart () { return start ; } public Point getEnd () { return end ; } public double getLength () { if ( changed ) { length = start . distanceTo ( end ); changed = false ; } return length ; } } La t\u00e9cnica de memoization es menos problem\u00e1tica si queda dentro de los l\u00edmites de la clase/m\u00f3dulo. Otras veces no merece la pena violar DRY por rendimiento: \u00a1las cach\u00e9s y los optimizadores de c\u00f3digo tambi\u00e9n hacen su labor!","title":"Ejemplo: aplicando memoization \u2013 versi\u00f3n 2"},{"location":"iiss-oop-4/#principio-de-acceso-uniforme","text":"All services offered by a module should be available through a uniform notation, which does not betray whether they are implemented through storage or through computation B. Meyer Conviene aplicar el principio de acceso uniforme para que sea m\u00e1s f\u00e1cil a\u00f1adir mejoras de rendimiento (v.g. caching)","title":"Principio de acceso uniforme"},{"location":"iiss-oop-4/#ejemplo-acceso-uniforme-en-c-version-3","text":"public class Line { private Point Start ; private Point End ; private double Length ; public Point Start { get { return Start ; } set { Start = value ; } } public Point End { get { return End ; } set { Start = value ; } } public double Length { get { return Start . distanceTo ( End ); } } }","title":"Ejemplo: acceso uniforme en C# \u2013 versi\u00f3n 3"},{"location":"iiss-oop-4/#ejemplo-acceso-uniforme-en-scala","text":"Llamadas a m\u00e9todos con par\u00e9ntesis: class Complejo ( real : Double , imaginaria : Double ) { def re () = real def im () = imaginaria override def toString () = \"\" + re () + ( if ( im () < 0 ) \"\" else \"+\" ) + im () + \"i\" } object NumerosComplejos { def main () : Unit = { val c = new Complejo ( 1.2 , 3.4 ) println ( \"N\u00famero complejo: \" + c . toString ()) println ( \"Parte imaginaria: \" + c . im ()) } } Llamadas a m\u00e9todos sin par\u00e9ntesis, igual que si fueran atributos: class Complejo ( real : Double , imaginaria : Double ) { def re = real def im = imaginaria override def toString () = \"\" + re + ( if ( im < 0 ) \"\" else \"+\" ) + im + \"i\" } object NumerosComplejos { def main () : Unit = { val c = new Complejo ( 1.2 , 3.4 ) println ( \"N\u00famero complejo: \" + c ) println ( \"Parte imaginaria: \" + c . im ) } }","title":"Ejemplo: acceso uniforme en Scala"},{"location":"iiss-oop-4/#duplicacion-por-impaciencia","text":"Los peligros del copy&paste \"V\u00edsteme despacio que tengo prisa\" ( shortcuts make for long delays ). Ejemplos: Meter el main de Java en cualquier clase Fiasco del a\u00f1o 2000","title":"Duplicaci\u00f3n por impaciencia"},{"location":"iiss-oop-4/#duplicacion-por-simultaneidad","text":"No resoluble a nivel de t\u00e9cnicas de construcci\u00f3n Hace falta metodolog\u00eda, gesti\u00f3n de equipos + herramientas de comunicaci\u00f3n","title":"Duplicaci\u00f3n por simultaneidad"},{"location":"iiss-oop-4/#ortogonalidad","text":"Dos componentes A y B son ortogonales ( A \\perp B A \\perp B ) si los cambios en uno no afectan al otro. Suponen m\u00e1s independencia y menos acoplamiento. Por ejemplo: La base de datos debe ser ortogonal a la interfaz de usuario En un helic\u00f3ptero, los mandos de control no suelen ser ortogonales A Nonorthogonal System ( Hunt, 2020 ) Helicopters have four basic controls. The cyclic is the stick you hold in your right hand. Move it, and the helicopter moves in the corresponding direction. Your left hand holds the collective pitch lever. Pull up on this and you increase the pitch on all the blades, generating lift. At the end of the pitch lever is the throttle. Finally you have two foot pedals, which vary the amount of tail rotor thrust and so help turn the helicopter. \u201cEasy!,\u201d you think. \u201cGently lower the collective pitch lever and you\u2019ll descend gracefully to the ground, a hero.\u201d However, when you try it, you discover that life isn\u2019t that simple. The helicopter\u2019s nose drops, and you start to spiral down to the left. Suddenly you discover that you\u2019re flying a system where every control input has secondary effects. Lower the left-hand lever and you need to add compensating backward movement to the right-hand stick and push the right pedal. But then each of these changes affects all of the other controls again. Suddenly you\u2019re juggling an unbelievably complex system, where every change impacts all the other inputs. Your workload is phenomenal: your hands and feet are constantly moving, trying to balance all the interacting forces. Helicopter controls are decidedly not orthogonal.","title":"Ortogonalidad"},{"location":"iiss-oop-4/#beneficios-de-la-ortogonalidad","text":"","title":"Beneficios de la ortogonalidad"},{"location":"iiss-oop-4/#mayor-productividad","text":"Es m\u00e1s f\u00e1cil escribir un componente peque\u00f1o y auto-contenido que un bloque muy grande de c\u00f3digo. El tiempo de desarrollo y pruebas se reduce Se pueden combinar unos componentes con otros m\u00e1s f\u00e1cilmente. Mayor reutilizaci\u00f3n . En teor\u00eda, si A \\perp B A \\perp B , el componente A sirve para m m prop\u00f3sitos y B sirve para n n , entonces A \\cup B A \\cup B sirve para m \\times n m \\times n prop\u00f3sitos. La falta de cohesi\u00f3n perjudica la reutilizaci\u00f3n \u2192 \u00bfy si hay que hacer una nueva versi\u00f3n gr\u00e1fica de una aplicaci\u00f3n de l\u00ednea de comandos que lleva incrustada la escritura en consola con System.out.println ? Pueden descohesionar!","title":"Mayor productividad"},{"location":"iiss-oop-4/#menor-riesgo","text":"Defectos aislados, m\u00e1s f\u00e1ciles de arreglar Menor fragilidad del sistema global. Los problemas provocados por cambios en un \u00e1rea se limitan a ese \u00e1rea M\u00e1s f\u00e1cil de probar , pues ser\u00e1 m\u00e1s f\u00e1cil construir pruebas individuales de cada uno de sus componentes (por ejemplo, las t\u00e9cnicas de mocking son m\u00e1s sencillas)","title":"Menor riesgo"},{"location":"iiss-oop-4/#niveles-de-aplicacion-de-la-ortogonalizad","text":"La ortogonalidad es aplicable a: el dise\u00f1o la codificaci\u00f3n las pruebas bibliotecas la documentaci\u00f3n A nivel de dise\u00f1o , los patrones de dise\u00f1o y las arquitecturas como MVC facilitan la construcci\u00f3n de componentes ortogonales. Lectura recomendada Leer el Topic 10: Orthogonality de ( Hunt, 2020 ).","title":"Niveles de aplicaci\u00f3n de la ortogonalizad"},{"location":"iiss-oop-4/#tecnicas-de-codificacion","text":"T\u00e9cnicas de codificaci\u00f3n para fomentar la ortogonalidad: Hacer refactoring Codificar patrones de dise\u00f1o: strategy, template method, etc. Evitar datos globales y singletons : \u00bfqu\u00e9 pasar\u00eda si hubiera que hacer una versi\u00f3n multithreaded de una aplicaci\u00f3n? Inyectar : pasar expl\u00edcitamente el contexto (dependencia) como par\u00e1metro a los constructores Usar anotaciones (Java), decoradores (TypeScript) o atributos (C#) Desacoplar : Ley de Demeter \u2014No hables con extra\u00f1os Usar programaci\u00f3n orientada a aspectos","title":"T\u00e9cnicas de codificaci\u00f3n"},{"location":"iiss-oop-4/#desacoplar-ley-de-demeter","text":"Al pedir un servicio a un objeto, el servicio debe ser realizado de parte nuestra, no que nos devuelva un tercero con el que tratar para realizarlo Ejemplo : public boolean canWrite ( User user ) { if ( user . isAnonymous ()) return false ; else { return user . getGroup (). hasPermission ( Permission . WRITE ); } } Refactorizaci\u00f3n: definir un m\u00e9todo User.hasPermission() Lectura recomendada Leer el Topic 28: Decoupling de ( Hunt, 2020 ).","title":"Desacoplar - ley de Demeter"},{"location":"iiss-oop-4/#inyectar-el-contexto","text":"Pasar expl\u00edcitamente el contexto (dependencia) como par\u00e1metro a los constructores de la clase","title":"Inyectar el contexto"},{"location":"iiss-oop-4/#ejemplo-patron-estrategia","text":"En el patr\u00f3n de dise\u00f1o strategy , pasar el contexto a la estrategia en su creaci\u00f3n","title":"Ejemplo: patr\u00f3n estrategia"},{"location":"iiss-oop-4/#ejemplo-caballeros-de-la-mesa-redonda","text":"public interface Knight { Object embarkOnQuest () throws QuestFailedException ; } public class KnightOfTheRoundTable implements Knight { private String name ; private Quest quest ; public KnightOfTheRoundTable ( String name , Quest quest ) { this . name = name ; this . quest = quest ; } public Object embarkOnQuest () throws QuestFailedException { return quest . embark (); } public void setQuest ( Quest quest ) { this . quest = quest ; } } public interface Quest { abstract Object embark () throws QuestFailedException ; }","title":"Ejemplo: caballeros de la mesa redonda"},{"location":"iiss-oop-4/#ley-de-demeter-para-funciones","text":"Los m\u00e9todos de un objeto solo deben hacer llamadas a m\u00e9todos... propios de objetos pasados como par\u00e1metros de objetos creados por ellos mismos de objetos declarados en el mismo m\u00e9todo class Demeter { private A a ; private int func (); public void example ( B b ); void example ( B b ) { C c ; int f = func (); // (caso 1) b . invert (); // (caso 2) a = new A (); a . setActive (); // (caso 3) c . print (); // (caso 4) }","title":"Ley de Demeter para funciones"},{"location":"iiss-oop-4/#interfaces-fluent","text":"Excepci\u00f3n a la ley de Demeter Hay una excepci\u00f3n notable a la prohibici\u00f3n de encadenar llamadas a funciones de la ley de Demeter. Esta regla no aplica si es muy poco probable que haya cambios en las cosas que se encadenan. En la pr\u00e1ctica, cualquier parte de tu aplicaci\u00f3n debe considerarse como algo que es probable que cambie; cualquier elemento de una biblioteca de un tercero debe considerarse vol\u00e1til, en particular si quienes mantienen dicha biblioteca suelen cambiar su API de una versi\u00f3n a otra. Las librer\u00edas que vienen con el lenguaje suelen ser bastante estables, as\u00ed que ejemplos de c\u00f3digo como el siguiente son aceptables como excepci\u00f3n a esta interpretaci\u00f3n de la ley de Demeter: List < String > myList = Arrays . asList ( \"a1\" , \"a2\" , \"b1\" , \"c2\" , \"c1\" ); myList . stream () . filter ( s -> s . startsWith ( \"c\" )) . map ( String :: toUpperCase ) . sorted () . forEach ( System . out :: println ); Los m\u00e9todos stream , filter , map , sorted y forEach son parte de las nuevas interfaces funcionales para manejar streams , incorporadas a las colecciones (v.g. List ) del lenguaje desde la versi\u00f3n Java 8. Este tipo de interfaces como la del API de streams de Java se conoce como fluent interfaces . La programaci\u00f3n con streams se tratar\u00e1 en el cap\u00edtulo sobre Programaci\u00f3n basada en Eventos Las interfaces funcionales se tratar\u00e1n en el cap\u00edtulo sobre Programaci\u00f3n Funcional","title":"Interfaces fluent"},{"location":"iiss-oop-4/#criticas-a-la-ley-de-demeter","text":"La ley de Demeter, \u00bfrealmente ayuda a crear c\u00f3digo m\u00e1s mantenible?","title":"Cr\u00edticas a la ley de Demeter"},{"location":"iiss-oop-4/#ejemplo-pintar-graficos-de-grabadoras","text":"Pintar un gr\u00e1fico con los datos registrados por una serie de grabadoras ( Recorder ) dispersas por el mundo. Cada grabadora est\u00e1 en una ubicaci\u00f3n ( Location ), que tiene una zona horaria ( TimeZone ). Los usuarios seleccionan ( Selection ) una grabadora y pintan sus datos etiquetados con la zona horaria correcta... public void plotDate ( Date aDate , Selection aSelection ) { TimeZone tz = aSelection . getRecorder (). getLocation (). getZone (); }","title":"Ejemplo: pintar gr\u00e1ficos de grabadoras"},{"location":"iiss-oop-4/#criticas","text":"Multiplicidad de dependencias: plotDate \\dashrightarrow \\dashrightarrow Selection , Recorder , Location , TimeZone . Si cambia la implementaci\u00f3n de Location de forma que ya no incluye directamente una TimeZone , hay que cambiar plotDate A\u00f1adir un m\u00e9todo delegado getTimeZone a Selection . As\u00ed plotDate no se entera de si la TimeZone le llega desde Recorder o desde un objeto contenido en Recorder . public void plotDate ( Date aDate , TimeZone tz ) { /* ... */ } plotDate ( someDate , someSelection . getTimeZone ()); Ahora plotDate \\dashrightarrow \\dashrightarrow Selection , TimeZone , pero se han eliminado las restantes dependencias. Costes de espacio y ejecuci\u00f3n de m\u00e9todos wrapper que reenv\u00edan la petici\u00f3n al objeto delegado: violar la ley de Demeter para mejorar el rendimiento Otros ejemplos de mejora del rendimiento: desnormalizaci\u00f3n de BBDD","title":"Cr\u00edticas"},{"location":"iiss-oop-4/#ortogonalidad-en-toolkits-y-bibliotecas","text":"Muchas bibliotecas actuales implementan la ortogonalidad a trav\u00e9s de metadatos, o atributos o etiquetas (@ tag ), tambi\u00e9n llamados anotaciones en Java y decoradores en TypeScript. Los metadatos se emplean para proporcionar prop\u00f3sitos espec\u00edficos, como v.g. persistencia de objetos, transacciones, etc. Por ejemplo, Spring o EJB utilizan anotaciones @ declarativas para expresar la transaccionalidad de una operaci\u00f3n o la persistencia de una propiedad de una clase fuera del m\u00e9todo que debe ejecutar dichas funcionalidades. Otro m\u00e9todo para implementar la ortogonalidad es usar Aspectos y Aspect-Oriented Programming (AOP). Este m\u00e9todo es empleado por el framework Spring. Estudiar ahora el cap\u00edtulo Aspectos Estudiar luego el cap\u00edtulo Calidad","title":"Ortogonalidad en toolkits y bibliotecas"},{"location":"iiss-pres/","text":"Construcci\u00f3n de Sistemas Software Problem\u00e1ticas \u00b6 Variabilidad Acoplamiento Complejidad Robustez Reutilizaci\u00f3n Flexibilidad Principios \u00b6 Ocultaci\u00f3n Cohesi\u00f3n Ortogonalidad Delegaci\u00f3n T\u00e9cnicas \u00b6 Orientaci\u00f3n a objetos Herencia Polimorfismo Composici\u00f3n Inyecci\u00f3n de dependencias Refactoring C\u00f3digo duplicado Ortogonalidad y dependencias Aspectos Calidad y Robustez Aserciones Contratos Errores y excepciones Optionals y uso de null Programaci\u00f3n Funcional Funciones An\u00f3nimas Retrollamadas Cierres y Lambdas Mixins Programaci\u00f3n As\u00edncrona Listeners Continuaciones Eventos Paradigmas \u00b6 Objetos Aspectos Contratos Funciones Eventos Casos pr\u00e1cticos \u00b6 Ocultaci\u00f3n de la implementaci\u00f3n - Recorrido de una lista Delegaci\u00f3n - Implementaci\u00f3n de una orquesta Inyecci\u00f3n de dependencias - Caballeros de la mesa redonda C\u00f3digo duplicado - C\u00e1lculo de n\u00f3minas Ortogonalidad con aspectos - Editor de figuras","title":"Presentaci\u00f3n"},{"location":"iiss-pres/#problematicas","text":"Variabilidad Acoplamiento Complejidad Robustez Reutilizaci\u00f3n Flexibilidad","title":"Problem\u00e1ticas"},{"location":"iiss-pres/#principios","text":"Ocultaci\u00f3n Cohesi\u00f3n Ortogonalidad Delegaci\u00f3n","title":"Principios"},{"location":"iiss-pres/#tecnicas","text":"Orientaci\u00f3n a objetos Herencia Polimorfismo Composici\u00f3n Inyecci\u00f3n de dependencias Refactoring C\u00f3digo duplicado Ortogonalidad y dependencias Aspectos Calidad y Robustez Aserciones Contratos Errores y excepciones Optionals y uso de null Programaci\u00f3n Funcional Funciones An\u00f3nimas Retrollamadas Cierres y Lambdas Mixins Programaci\u00f3n As\u00edncrona Listeners Continuaciones Eventos","title":"T\u00e9cnicas"},{"location":"iiss-pres/#paradigmas","text":"Objetos Aspectos Contratos Funciones Eventos","title":"Paradigmas"},{"location":"iiss-pres/#casos-practicos","text":"Ocultaci\u00f3n de la implementaci\u00f3n - Recorrido de una lista Delegaci\u00f3n - Implementaci\u00f3n de una orquesta Inyecci\u00f3n de dependencias - Caballeros de la mesa redonda C\u00f3digo duplicado - C\u00e1lculo de n\u00f3minas Ortogonalidad con aspectos - Editor de figuras","title":"Casos pr\u00e1cticos"},{"location":"iiss-temas/","text":"Temario \u00b6 Principios Caso 1 - Recorrido de listas Cohesi\u00f3n Ocultar la implementaci\u00f3n Herencia: generalizaci\u00f3n y especializaci\u00f3n Polimorfismo Delegaci\u00f3n Caso 2 - Implementaci\u00f3n de una orquesta Composici\u00f3n y dependencias Inyecci\u00f3n de dependencias Caso 3 - Caballeros de la mesa redonda Dependencias en Java Decoradores en Typescript Duplicaci\u00f3n de c\u00f3digo Caso 4 - C\u00e1lculo de n\u00f3minas Refactoring C\u00f3digo duplicado Ortogonalidad Aspectos Caso 5 - Editor de figuras Ortogonalidad con aspectos Programaci\u00f3n orientada a aspectos Ejercicios Calidad Tratamiento de errores Excepciones Uso de null Fronteras Contratos Funcional Interfaces funcionales Lambdas Mixins Eventos Listeners As\u00edncronas Eventos","title":"Temario"},{"location":"iiss-temas/#temario","text":"Principios Caso 1 - Recorrido de listas Cohesi\u00f3n Ocultar la implementaci\u00f3n Herencia: generalizaci\u00f3n y especializaci\u00f3n Polimorfismo Delegaci\u00f3n Caso 2 - Implementaci\u00f3n de una orquesta Composici\u00f3n y dependencias Inyecci\u00f3n de dependencias Caso 3 - Caballeros de la mesa redonda Dependencias en Java Decoradores en Typescript Duplicaci\u00f3n de c\u00f3digo Caso 4 - C\u00e1lculo de n\u00f3minas Refactoring C\u00f3digo duplicado Ortogonalidad Aspectos Caso 5 - Editor de figuras Ortogonalidad con aspectos Programaci\u00f3n orientada a aspectos Ejercicios Calidad Tratamiento de errores Excepciones Uso de null Fronteras Contratos Funcional Interfaces funcionales Lambdas Mixins Eventos Listeners As\u00edncronas Eventos","title":"Temario"}]}