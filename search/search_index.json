{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Pr\u00e1ticas de Implementaci\u00f3n e Implantaci\u00f3n de Sistemas Software Programaci\u00f3n orientada a objetos \u00b6 Pr\u00e1ctica 1 Pr\u00e1ctica 2 Pr\u00e1ctica 3 Pr\u00e1ctica 4 Programaci\u00f3n funcional \u00b6 Pr\u00e1ctica 1 Pr\u00e1ctica 2 Pr\u00e1ctica 3","title":"Home"},{"location":"#programacion-orientada-a-objetos","text":"Pr\u00e1ctica 1 Pr\u00e1ctica 2 Pr\u00e1ctica 3 Pr\u00e1ctica 4","title":"Programaci\u00f3n orientada a objetos"},{"location":"#programacion-funcional","text":"Pr\u00e1ctica 1 Pr\u00e1ctica 2 Pr\u00e1ctica 3","title":"Programaci\u00f3n funcional"},{"location":"fp-p1/","text":"Pr\u00e1ctica 1: An\u00f3nimos & Cierres Repaso de conceptos te\u00f3ricos \u00b6 An\u00f3nimos (Expresiones Lambda) \u00b6 Una expresi\u00f3n lambda es una funci\u00f3n an\u00f3nima (con o sin par\u00e1metros) que es llamada sin necesidad de asociarle un nombre expl\u00edcito. Sirven para pasarlas como argumento a funciones de orden superior, momento en el cual los par\u00e1metros de la funci\u00f3n an\u00f3nima toman un valor en el contexto de ejecuci\u00f3n de la funci\u00f3n contenedora que la recibe y ejecuta. Por tanto, las funciones an\u00f3nimas permiten acceder a variables (no locales) definidas en el \u00e1mbito de la contenedora. In computer programming, an anonymous function (function literal, lambda abstraction, or lambda expression) is a function definition that is not bound to an identifier. Anonymous functions are often arguments being passed to higher-order functions, or used for constructing the result of a higher-order function that needs to return a function.[1] If the function is only used once, or a limited number of times, an anonymous function may be syntactically lighter than using a named function. Anonymous functions are ubiquitous in functional programming languages and other languages with first-class functions, where they fulfill the same role for the function type as literals do for other data types. -- Wikipedia A continuaci\u00f3n, se incluye un ejemplo del recorrido de una lista con la sintaxis de POO tradicional: for ( Integer numero : Arrays . asList ( 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 )) { System . out . print ( numero + \" \" ); } Por otro lado, a continuaci\u00f3n se incluye la misma implementaci\u00f3n, pero utilizando expresiones lambda : //Primera versi\u00f3n Arrays . asList ( 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 ). forEach ( n -> System . out . print ( n + \" \" )); //Segunda versi\u00f3n Arrays . asList ( 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 ). forEach ( System . out :: println ); En este caso, la funci\u00f3n forEach acepta expresiones lambda para poder configurar su comportamiento. En la primera versi\u00f3n se imprimir\u00e1 cada elemento (n) de la lista y posteriormente se a\u00f1adir\u00e1 un espacio. Por lo tanto, la salida del programa en consola ser\u00eda: 1 2 3 4 5 6 7 8 9 10 Por otro lado, en la segunda versi\u00f3n se imprimir\u00e1 cada elemento de la lista y se a\u00f1adir\u00e1 un salto de l\u00ednea posteriormente. Por lo tanto, la salida del programa en este caso ser\u00eda: 1 2 3 4 5 6 7 8 9 10 Stream API (recordatorio de Pr\u00e1ctica 2 + ampliaci\u00f3n) \u00b6 Un stream representa una secuencia de elementos que soportan diferentes tipos de operaciones para realizar c\u00e1lculos sobre ellos. Las posibles operaciones que se pueden realizar sobre un stream pueden ser intermediarias o terminales . - Las operaciones intermediarias devuelven un nuevo stream , permitiendo encadenar m\u00faltiples operaciones intermediarias sin usar punto y coma. - Por otro lado, las operaciones terminales son nulas o devuelven un resultado de un tipo diferente, por ejemplo un tipo num\u00e9rico. por Benjamin, Java 8 Stream Tutorial En el ejemplo anterior, las operaciones filter , map y sorted son operaciones intermediarias, mientras que la operaci\u00f3n forEach es una operaci\u00f3n terminal. M\u00e1s informaci\u00f3n: https://www.oracle.com/technetwork/es/articles/java/procesamiento-streams-java-se-8-2763402-esa.html Por otro lado, se puede observar que la mayor\u00eda de las operaciones que se aplican sobre streams aceptan alg\u00fan tipo de par\u00e1metro en forma de expresi\u00f3n lambda , que es una interfaz funcional que especifica el comportamiento exacto de la operaci\u00f3n Estas operaciones no pueden modificar el contenido del stream original. En el ejemplo anterior, se puede observar que ninguna de las operaciones modifica la variable myList a\u00f1adiendo o eliminando elementos, sino que s\u00f3lo se realiza el filtrado de los elementos que no empiezan por \"c\", se transforman a may\u00fasculas, se ordenan en orden alfab\u00e9tico y se imprimen por pantalla. M\u00e1s informaci\u00f3n: https://www.oracle.com/technetwork/es/articles/java/expresiones-lambda-api-stream-java-2737544-esa.html Finalmente, se incluye otro ejemplo del uso del Stream API en Java: ArrayList < Integer > mayores = ( ArrayList < Integer > ) Arrays . asList ( 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 ) . stream () . filter ( x -> x > 5 ) . collect ( Collectors . toCollection (() -> new ArrayList < Integer > ())); mayores . forEach ( e -> System . out . println ( e )); En el ejemplo anterior se realiza el filtrado de los n\u00fameros que sean mayores que 5 y, posteriormente, se imprimen por pantalla los elementos de la lista. Por lo tanto, la salida del programa por consola en este caso ser\u00eda: 1 2 3 4 5 Cierres (Closures) \u00b6 Cuando se realiza la declaraci\u00f3n de una variable local, esa variable tiene un alcance local. Es decir, la definici\u00f3n de estas variables s\u00f3lo existen dentro del bloque o funci\u00f3n d\u00f3nde se ha realizado su declaraci\u00f3n. Por ejemplo: int suma ( int a , int b ) { int suma = a + b ; return suma ; } int sumaDoble ( int a , int b ) { suma = a * 2 + b + 2 ; //falla return suma ; } En este caso, en la primera funci\u00f3n se realiza la asignaci\u00f3n de la suma de las variables a y b a una variable local suma y posteriormente, se devuelve el valor de esta variable. En la segunda funci\u00f3n, se realiza el mismo procedimiento que en la primera funci\u00f3n pero realizando la suma de los dobles de las variables a y b . El problema en esta funci\u00f3n es que se usa la variable local definida en la primera funci\u00f3n, la cual no est\u00e1 definida fuera de su \u00e1mbito y resultar\u00eda en un error de compilaci\u00f3n. Para solventarlo, se tendr\u00eda que definir la variable local suma tambi\u00e9n en la segunda funci\u00f3n. Sin embargo, el uso de los cierres ( closures ) permiten encapsular funciones completas (incluyendo sus variables locales) en otra variable, permitiendo su uso en diferentes lugares del programa. Closures are nothing but stateful functions! A few definitions from the web include: A closure is a combination of a function bundled together (enclosed) with references to its surrounding state. A closure gives you access to an outer function\u2019s scope from an inner function. Uses of Closures include data privacy, partial application & currying. -- Ramkumar Manavalan Por ejemplo: @FunctionalInterface public interface NumToTextConverter { String convert ( int x ); } static void closureTypeDemo () { NumToTextConverter textOfWeekDay = new NumToTextConverter () { String [] weeks = { \"Mon\" , \"Tue\" , \"Wed\" , \"Thu\" , \"Fri\" , \"Sat\" , \"Sun\" }; @Override public String convert ( int num ) { return ( num > 0 && num <= weeks . length ) ? weeks [ num - 1 ] : null ; }; }; System . out . println ( textOfWeekDay . convert ( 1 )); } En este caso, la variable textOfWeekDay puede considerarse un cierre ( closure ), ya que agrupa la definici\u00f3n de la funci\u00f3n convert , y adem\u00e1s, los datos de los d\u00edas de la semana (privados, pero accesibles desde la funci\u00f3n de conversi\u00f3n). Finalmente, la salida del programa anterior ser\u00eda \"Mon\", ya que la funci\u00f3n convert devolver\u00eda la primera posici\u00f3n del array weeks . Ejercicios propuestos \u00b6 Ejercicio 1 \u00b6 Dado los siguientes fragmentos de c\u00f3digo que implementan un API dado por la interfaz DataOperations , responder a las siguientes preguntas: DataOperations.java \u00b6 public interface DataOperations { public void print ( int [] data ); public int [] filterPairs ( int [] data ); } DataOperationsImpl.java \u00b6 public class DataOperationsImpl implements DataOperations { @Override public void print ( int [] data ) { for ( int element : data ) { System . out . print ( element + \", \" ); } System . out . println (); } @Override public int [] filterPairs ( int [] data ) { int index = 0 ; int [] dataAux = new int [ data . length ] ; for ( int element : data ) { if (( element % 2 ) != 0 ) { dataAux [ index ] = element ; index ++ ; } } return dataAux ; } } Main.java \u00b6 import java.util.Arrays ; public class Main { public static void main ( String args [] ) { int [] data = { 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 }; System . out . println ( \"data = \" + Arrays . toString ( data )); DataOperations operations = new DataOperationsImpl (); operations . print ( data ); data = operations . filterPairs ( data ); operations . print ( data ); } } Preguntas propuestas \u00b6 Utilice el uso de expresiones lambda + Stream API para transformar la implementaci\u00f3n de las operaciones de la interfaz DataOperations a la sintaxis de programaci\u00f3n funcional. Adem\u00e1s, haciendo uso de expresiones labmda + Stream API a\u00f1ada al API de DataOperations la implementaci\u00f3n de las siguientes operaciones: Operaci\u00f3n que devuelva la lista de n\u00fameros ordenada descendentemente. Operaci\u00f3n que multiplique todos los n\u00fameros de la lista por 10 e imprima el resultado. Operaci\u00f3n que devuelva el resultado de la suma de todos los n\u00fameros de la lista. Ejercicio 2 \u00b6 Dado los siguientes fragmentos de c\u00f3digo que implementan un API de interfaz DataSorter , responder a las siguientes preguntas. DataSorter.java \u00b6 public interface DataSorter { public String [] sort ( String [] data ); } DataSorterAsc.java \u00b6 import java.util.Arrays ; public class DataSorterAsc implements DataSorter { public String [] sort ( String [] data ) { Arrays . sort ( data ); return data ; } } DataSorterDesc.java \u00b6 import java.util.Arrays ; import java.util.Collections ; public class DataSorterDesc implements DataSorter { public String [] sort ( String [] data ) { Arrays . sort ( data , Collections . reverseOrder ()); return data ; } } Main.java \u00b6 import java.util.Arrays ; public class Main { public static void main ( String args [] ) { String [] data = { \"H\" , \"S\" , \"I\" , \"V\" , \"E\" , \"W\" , \"M\" , \"P\" , \"L\" , \"C\" , \"N\" , \"K\" , \"O\" , \"A\" , \"Q\" , \"R\" , \"J\" , \"D\" , \"G\" , \"T\" , \"U\" , \"X\" , \"B\" , \"Y\" , \"Z\" , \"F\" }; System . out . println ( \"data = \" + Arrays . toString ( data )); DataSorter dataSorter = new DataSorterDesc (); dataSorter . sort ( data ); System . out . println ( \"data (desc) = \" + Arrays . toString ( data )); dataSorter = new DataSorterAsc (); dataSorter . sort ( data ); System . out . println ( \"data (asc) = \" + Arrays . toString ( data )); } } Preguntas propuestas \u00b6 Utilice cierres ( closures ) para transformar la implementaci\u00f3n de las clases DataSorterAsc y DataSorterDesc a la sintaxis de la programaci\u00f3n funcional. A\u00f1ada una tercera transformaci\u00f3n haciendo uso de cierres ( closures ) de una clase que realice la ordenaci\u00f3n aleatoria de los elementos, siguiendo el mismo enfoque que el que ha seguido con las clases DataSorterAsc y DataSorterDesc en el apartado anterior. Referencias \u00b6 [1] Definici\u00f3n en Wikipedia: Anonymous Function. [2] Blog: Java 8 Stream Tutorial. [3] Documentaci\u00f3n Oficial Java: Procesamiento de datos con streams de Java SE 8. [4] Documentaci\u00f3n Oficial Java: Introducci\u00f3n Expresiones Lambda y API Stream en Java SE 8. [5] Blog: 5 ways to implement Closures in Java 8.","title":"Pr\u00e1ctica 1"},{"location":"fp-p1/#repaso-de-conceptos-teoricos","text":"","title":"Repaso de conceptos te\u00f3ricos"},{"location":"fp-p1/#anonimos-expresiones-lambda","text":"Una expresi\u00f3n lambda es una funci\u00f3n an\u00f3nima (con o sin par\u00e1metros) que es llamada sin necesidad de asociarle un nombre expl\u00edcito. Sirven para pasarlas como argumento a funciones de orden superior, momento en el cual los par\u00e1metros de la funci\u00f3n an\u00f3nima toman un valor en el contexto de ejecuci\u00f3n de la funci\u00f3n contenedora que la recibe y ejecuta. Por tanto, las funciones an\u00f3nimas permiten acceder a variables (no locales) definidas en el \u00e1mbito de la contenedora. In computer programming, an anonymous function (function literal, lambda abstraction, or lambda expression) is a function definition that is not bound to an identifier. Anonymous functions are often arguments being passed to higher-order functions, or used for constructing the result of a higher-order function that needs to return a function.[1] If the function is only used once, or a limited number of times, an anonymous function may be syntactically lighter than using a named function. Anonymous functions are ubiquitous in functional programming languages and other languages with first-class functions, where they fulfill the same role for the function type as literals do for other data types. -- Wikipedia A continuaci\u00f3n, se incluye un ejemplo del recorrido de una lista con la sintaxis de POO tradicional: for ( Integer numero : Arrays . asList ( 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 )) { System . out . print ( numero + \" \" ); } Por otro lado, a continuaci\u00f3n se incluye la misma implementaci\u00f3n, pero utilizando expresiones lambda : //Primera versi\u00f3n Arrays . asList ( 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 ). forEach ( n -> System . out . print ( n + \" \" )); //Segunda versi\u00f3n Arrays . asList ( 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 ). forEach ( System . out :: println ); En este caso, la funci\u00f3n forEach acepta expresiones lambda para poder configurar su comportamiento. En la primera versi\u00f3n se imprimir\u00e1 cada elemento (n) de la lista y posteriormente se a\u00f1adir\u00e1 un espacio. Por lo tanto, la salida del programa en consola ser\u00eda: 1 2 3 4 5 6 7 8 9 10 Por otro lado, en la segunda versi\u00f3n se imprimir\u00e1 cada elemento de la lista y se a\u00f1adir\u00e1 un salto de l\u00ednea posteriormente. Por lo tanto, la salida del programa en este caso ser\u00eda: 1 2 3 4 5 6 7 8 9 10","title":"An\u00f3nimos (Expresiones Lambda)"},{"location":"fp-p1/#stream-api-recordatorio-de-practica-2-ampliacion","text":"Un stream representa una secuencia de elementos que soportan diferentes tipos de operaciones para realizar c\u00e1lculos sobre ellos. Las posibles operaciones que se pueden realizar sobre un stream pueden ser intermediarias o terminales . - Las operaciones intermediarias devuelven un nuevo stream , permitiendo encadenar m\u00faltiples operaciones intermediarias sin usar punto y coma. - Por otro lado, las operaciones terminales son nulas o devuelven un resultado de un tipo diferente, por ejemplo un tipo num\u00e9rico. por Benjamin, Java 8 Stream Tutorial En el ejemplo anterior, las operaciones filter , map y sorted son operaciones intermediarias, mientras que la operaci\u00f3n forEach es una operaci\u00f3n terminal. M\u00e1s informaci\u00f3n: https://www.oracle.com/technetwork/es/articles/java/procesamiento-streams-java-se-8-2763402-esa.html Por otro lado, se puede observar que la mayor\u00eda de las operaciones que se aplican sobre streams aceptan alg\u00fan tipo de par\u00e1metro en forma de expresi\u00f3n lambda , que es una interfaz funcional que especifica el comportamiento exacto de la operaci\u00f3n Estas operaciones no pueden modificar el contenido del stream original. En el ejemplo anterior, se puede observar que ninguna de las operaciones modifica la variable myList a\u00f1adiendo o eliminando elementos, sino que s\u00f3lo se realiza el filtrado de los elementos que no empiezan por \"c\", se transforman a may\u00fasculas, se ordenan en orden alfab\u00e9tico y se imprimen por pantalla. M\u00e1s informaci\u00f3n: https://www.oracle.com/technetwork/es/articles/java/expresiones-lambda-api-stream-java-2737544-esa.html Finalmente, se incluye otro ejemplo del uso del Stream API en Java: ArrayList < Integer > mayores = ( ArrayList < Integer > ) Arrays . asList ( 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 ) . stream () . filter ( x -> x > 5 ) . collect ( Collectors . toCollection (() -> new ArrayList < Integer > ())); mayores . forEach ( e -> System . out . println ( e )); En el ejemplo anterior se realiza el filtrado de los n\u00fameros que sean mayores que 5 y, posteriormente, se imprimen por pantalla los elementos de la lista. Por lo tanto, la salida del programa por consola en este caso ser\u00eda: 1 2 3 4 5","title":"Stream API (recordatorio de Pr\u00e1ctica 2 + ampliaci\u00f3n)"},{"location":"fp-p1/#cierres-closures","text":"Cuando se realiza la declaraci\u00f3n de una variable local, esa variable tiene un alcance local. Es decir, la definici\u00f3n de estas variables s\u00f3lo existen dentro del bloque o funci\u00f3n d\u00f3nde se ha realizado su declaraci\u00f3n. Por ejemplo: int suma ( int a , int b ) { int suma = a + b ; return suma ; } int sumaDoble ( int a , int b ) { suma = a * 2 + b + 2 ; //falla return suma ; } En este caso, en la primera funci\u00f3n se realiza la asignaci\u00f3n de la suma de las variables a y b a una variable local suma y posteriormente, se devuelve el valor de esta variable. En la segunda funci\u00f3n, se realiza el mismo procedimiento que en la primera funci\u00f3n pero realizando la suma de los dobles de las variables a y b . El problema en esta funci\u00f3n es que se usa la variable local definida en la primera funci\u00f3n, la cual no est\u00e1 definida fuera de su \u00e1mbito y resultar\u00eda en un error de compilaci\u00f3n. Para solventarlo, se tendr\u00eda que definir la variable local suma tambi\u00e9n en la segunda funci\u00f3n. Sin embargo, el uso de los cierres ( closures ) permiten encapsular funciones completas (incluyendo sus variables locales) en otra variable, permitiendo su uso en diferentes lugares del programa. Closures are nothing but stateful functions! A few definitions from the web include: A closure is a combination of a function bundled together (enclosed) with references to its surrounding state. A closure gives you access to an outer function\u2019s scope from an inner function. Uses of Closures include data privacy, partial application & currying. -- Ramkumar Manavalan Por ejemplo: @FunctionalInterface public interface NumToTextConverter { String convert ( int x ); } static void closureTypeDemo () { NumToTextConverter textOfWeekDay = new NumToTextConverter () { String [] weeks = { \"Mon\" , \"Tue\" , \"Wed\" , \"Thu\" , \"Fri\" , \"Sat\" , \"Sun\" }; @Override public String convert ( int num ) { return ( num > 0 && num <= weeks . length ) ? weeks [ num - 1 ] : null ; }; }; System . out . println ( textOfWeekDay . convert ( 1 )); } En este caso, la variable textOfWeekDay puede considerarse un cierre ( closure ), ya que agrupa la definici\u00f3n de la funci\u00f3n convert , y adem\u00e1s, los datos de los d\u00edas de la semana (privados, pero accesibles desde la funci\u00f3n de conversi\u00f3n). Finalmente, la salida del programa anterior ser\u00eda \"Mon\", ya que la funci\u00f3n convert devolver\u00eda la primera posici\u00f3n del array weeks .","title":"Cierres (Closures)"},{"location":"fp-p1/#ejercicios-propuestos","text":"","title":"Ejercicios propuestos"},{"location":"fp-p1/#ejercicio-1","text":"Dado los siguientes fragmentos de c\u00f3digo que implementan un API dado por la interfaz DataOperations , responder a las siguientes preguntas:","title":"Ejercicio 1"},{"location":"fp-p1/#dataoperationsjava","text":"public interface DataOperations { public void print ( int [] data ); public int [] filterPairs ( int [] data ); }","title":"DataOperations.java"},{"location":"fp-p1/#dataoperationsimpljava","text":"public class DataOperationsImpl implements DataOperations { @Override public void print ( int [] data ) { for ( int element : data ) { System . out . print ( element + \", \" ); } System . out . println (); } @Override public int [] filterPairs ( int [] data ) { int index = 0 ; int [] dataAux = new int [ data . length ] ; for ( int element : data ) { if (( element % 2 ) != 0 ) { dataAux [ index ] = element ; index ++ ; } } return dataAux ; } }","title":"DataOperationsImpl.java"},{"location":"fp-p1/#mainjava","text":"import java.util.Arrays ; public class Main { public static void main ( String args [] ) { int [] data = { 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 }; System . out . println ( \"data = \" + Arrays . toString ( data )); DataOperations operations = new DataOperationsImpl (); operations . print ( data ); data = operations . filterPairs ( data ); operations . print ( data ); } }","title":"Main.java"},{"location":"fp-p1/#preguntas-propuestas","text":"Utilice el uso de expresiones lambda + Stream API para transformar la implementaci\u00f3n de las operaciones de la interfaz DataOperations a la sintaxis de programaci\u00f3n funcional. Adem\u00e1s, haciendo uso de expresiones labmda + Stream API a\u00f1ada al API de DataOperations la implementaci\u00f3n de las siguientes operaciones: Operaci\u00f3n que devuelva la lista de n\u00fameros ordenada descendentemente. Operaci\u00f3n que multiplique todos los n\u00fameros de la lista por 10 e imprima el resultado. Operaci\u00f3n que devuelva el resultado de la suma de todos los n\u00fameros de la lista.","title":"Preguntas propuestas"},{"location":"fp-p1/#ejercicio-2","text":"Dado los siguientes fragmentos de c\u00f3digo que implementan un API de interfaz DataSorter , responder a las siguientes preguntas.","title":"Ejercicio 2"},{"location":"fp-p1/#datasorterjava","text":"public interface DataSorter { public String [] sort ( String [] data ); }","title":"DataSorter.java"},{"location":"fp-p1/#datasorterascjava","text":"import java.util.Arrays ; public class DataSorterAsc implements DataSorter { public String [] sort ( String [] data ) { Arrays . sort ( data ); return data ; } }","title":"DataSorterAsc.java"},{"location":"fp-p1/#datasorterdescjava","text":"import java.util.Arrays ; import java.util.Collections ; public class DataSorterDesc implements DataSorter { public String [] sort ( String [] data ) { Arrays . sort ( data , Collections . reverseOrder ()); return data ; } }","title":"DataSorterDesc.java"},{"location":"fp-p1/#mainjava_1","text":"import java.util.Arrays ; public class Main { public static void main ( String args [] ) { String [] data = { \"H\" , \"S\" , \"I\" , \"V\" , \"E\" , \"W\" , \"M\" , \"P\" , \"L\" , \"C\" , \"N\" , \"K\" , \"O\" , \"A\" , \"Q\" , \"R\" , \"J\" , \"D\" , \"G\" , \"T\" , \"U\" , \"X\" , \"B\" , \"Y\" , \"Z\" , \"F\" }; System . out . println ( \"data = \" + Arrays . toString ( data )); DataSorter dataSorter = new DataSorterDesc (); dataSorter . sort ( data ); System . out . println ( \"data (desc) = \" + Arrays . toString ( data )); dataSorter = new DataSorterAsc (); dataSorter . sort ( data ); System . out . println ( \"data (asc) = \" + Arrays . toString ( data )); } }","title":"Main.java"},{"location":"fp-p1/#preguntas-propuestas_1","text":"Utilice cierres ( closures ) para transformar la implementaci\u00f3n de las clases DataSorterAsc y DataSorterDesc a la sintaxis de la programaci\u00f3n funcional. A\u00f1ada una tercera transformaci\u00f3n haciendo uso de cierres ( closures ) de una clase que realice la ordenaci\u00f3n aleatoria de los elementos, siguiendo el mismo enfoque que el que ha seguido con las clases DataSorterAsc y DataSorterDesc en el apartado anterior.","title":"Preguntas propuestas"},{"location":"fp-p1/#referencias","text":"[1] Definici\u00f3n en Wikipedia: Anonymous Function. [2] Blog: Java 8 Stream Tutorial. [3] Documentaci\u00f3n Oficial Java: Procesamiento de datos con streams de Java SE 8. [4] Documentaci\u00f3n Oficial Java: Introducci\u00f3n Expresiones Lambda y API Stream en Java SE 8. [5] Blog: 5 ways to implement Closures in Java 8.","title":"Referencias"},{"location":"fp-p2/","text":"Pr\u00e1ctica 2: Retrollamadas Repaso de conceptos te\u00f3ricos \u00b6 Programaci\u00f3n as\u00edncrona en Java \u00b6 En Java 5 se a\u00f1adi\u00f3 la interfaz Future para integrar la programaci\u00f3n as\u00edncrona. Sin embargo, esta interfaz no proporcionaba la posibilidad de combinar los resultados obtenidos al aplicar diferentes operaciones o manejar los posibles errores. Por este motivo, en Java 8 se incluy\u00f3 la clase CompletableFuture , junto a la interfaz Future , la cual implementa tambi\u00e9n la interfaz CompletionStage . Esta interfaz incluye el contrato de operaciones para incluir la combinaci\u00f3n de resultados procedentes de diferentes operaciones. En las secciones posteriores se ver\u00e1n algunos de los usos propuestos por esta interfaz en Java 8. CompletableFuture como (simple) Future \u00b6 A continuaci\u00f3n se muestra un ejemplo de uso de la clase CompletableFuture : Main.java \u00b6 import java.util.concurrent.ExecutionException ; import java.util.concurrent.Future ; public class Main { public static void main ( String args [] ) throws InterruptedException , ExecutionException { Future < String > completableFuture = AsynchronousAPI . helloWorldAsync (); String result = completableFuture . get (); System . out . println ( \"The result is \" + result ); } } AsynchronousAPI.java \u00b6 import java.util.concurrent.CompletableFuture ; import java.util.concurrent.Executors ; import java.util.concurrent.Future ; public class AsynchronousAPI { public static Future < String > helloWorldAsync () throws InterruptedException { CompletableFuture < String > completableFuture = new CompletableFuture <> (); Executors . newCachedThreadPool (). submit (() -> { Thread . sleep ( 1000 ); completableFuture . complete ( \"Hello world\" ); return null ; }); return completableFuture ; } } En primer lugar, en la funci\u00f3n main se obtiene la variable completableFuture , la cual es de tipo Future<String> , esta variable obtendr\u00e1 su valor cuando la funci\u00f3n helloWorldAsync() se resuelva. A tr\u00e1ves de la operaci\u00f3n completableFuture.get() se obtiene el resultado de la funci\u00f3n y posteriormente, se muestra en consola. Por otro lado, el comportamiento de la funci\u00f3n helloWorldAsync se basa en el uso de la operaci\u00f3n submit() de Executors.newCachedThreadPool() , la cual crea un nuevo hilo que se suspende durante 10 segundos para a\u00f1adir un retardo temporal y posteriormente completa la operaci\u00f3n con el valor Hello world . En este caso, cuando finalice el procesamiento del programa se mostrar\u00e1 por consola el mensaje The result is Hello world . Procesamiento de resultados as\u00edncronos \u00b6 A continuaci\u00f3n, se muestra un ejemplo del uso del resultado devuelto en un CompletableFuture desde otra variable del mismo tipo: Main.java \u00b6 import java.util.concurrent.CompletableFuture ; import java.util.concurrent.ExecutionException ; public class Main { public static void main ( String args [] ) throws InterruptedException , ExecutionException { //Then apply CompletableFuture < String > completableFuture = AsynchronousAPI . helloWorldAsync (); CompletableFuture < String > future = completableFuture . thenApply ( s -> s + \" world\" ); String result = future . get (); System . out . println ( result ); //Then accept completableFuture = AsynchronousAPI . helloWorldAsync (); CompletableFuture < Void > futureVoid = completableFuture . thenAccept ( s -> System . out . println ( s + \" world\" )); futureVoid . get (); //Then run completableFuture = AsynchronousAPI . helloWorldAsync (); futureVoid = completableFuture . thenRun (() -> System . out . println ( \"world\" )); futureVoid . get (); } } AsynchronousAPI.java \u00b6 import java.util.concurrent.CompletableFuture ; import java.util.concurrent.Executors ; import java.util.concurrent.Future ; public class AsynchronousAPI { public static CompletableFuture < String > helloWorldAsync () throws InterruptedException { CompletableFuture < String > completableFuture = new CompletableFuture <> (); Executors . newCachedThreadPool (). submit (() -> { Thread . sleep ( 1000 ); completableFuture . complete ( \"Hello\" ); return null ; }); return completableFuture ; } } En este caso, la funci\u00f3n helloWorldAsync realiza el mismo comportamiento que en el ejemplo anterior, \u00fanicamente con la diferencia de que devuelve Hello y no Hello world completo como en el ejemplo anterior. Por otro lado, en la funci\u00f3n main se utilizan tres funciones de la clase CompletableFuture , a continuaci\u00f3n se detalla el comportamiento de cada una de ellas: thenApply() : La variable future espera el resultado de la resoluci\u00f3n de la variable completableFuture . En este caso, espera un resultado de tipo String . Finalmente, concatena a ese resultado la palabra world y obtiene el valor completo de la cadena en su resoluci\u00f3n, es decir, Hello world . thenAccept() : La variable futureVoid espera el resultado de la resoluci\u00f3n de la variable completableFuture , como en el caso anterior. La diferencia es que la variable futureVoid no podr\u00e1 devolver un resultado de tipo String en su resoluci\u00f3n, sino que ser\u00e1 de tipo Void . Por este motivo, se lanzar\u00e1 directamente la funci\u00f3n System.out.println en la resoluci\u00f3n de la variable futureVoid . thenRun() : La variable futureVoid en este caso no espera ning\u00fan resultado, sino que s\u00f3lo espera la resoluci\u00f3n de la variable completableFuture . Como en el caso anterior, la variable futureVoid lanzar\u00e1 directamente la funci\u00f3n System.out.println en su resoluci\u00f3n, pero no concatenar\u00e1 el resultado de la variable completableFuture , mostrando \u00fanicamente la palabra world . Combinaci\u00f3n de Futures \u00b6 A continuaci\u00f3n, se muestran varios fragmentos de c\u00f3digo que ilustran la forma de combinar varios resultados procedentes de diferentes variables de tipo CompletableFuture : CompletableFuture < String > completableFuture = CompletableFuture . supplyAsync (() -> \"Hello\" ) . thenCompose ( s -> CompletableFuture . supplyAsync (() -> s + \" World\" )); CompletableFuture < String > completableFuture = CompletableFuture . supplyAsync (() -> \"Hello\" ) . thenCombine ( CompletableFuture . supplyAsync ( () -> \" World\" ), ( s1 , s2 ) -> s1 + s2 )); CompletableFuture future = CompletableFuture . supplyAsync (() -> \"Hello\" ) . thenAcceptBoth ( CompletableFuture . supplyAsync (() -> \" World\" ), ( s1 , s2 ) -> System . out . println ( s1 + s2 )); En la secci\u00f3n anterior se utilizan tres funciones de la clase CompletableFuture para combinar los resultados. A continuaci\u00f3n se detalla el comportamiento de cada una de ellas: thenCompose() : Esta funci\u00f3n permite \"concatenar\" el resultado de una variable CompletableFuture en otra una vez que haya finalizado su procesamiento. En este caso, la ejecuci\u00f3n de los CompletableFuture no es independiente, sino que se encadenan de forma secuencial. thenCombine() : Esta funci\u00f3n permite ejecutar los CompletableFuture de forma independiente y, posteriormente, combinar los resultados en la variable CompletableFuture resultante (future). thenAcceptBoth() : Esta funci\u00f3n realiza el mismo procesamiento que thenCombine() , pero con la diferencia que la variable CompletableFuture resultante (future) es de tipo Void y realiza una acci\u00f3n. En este caso, invoca a la funci\u00f3n System.out.println . Ejecuci\u00f3n de Futures en paralelo \u00b6 A continuaci\u00f3n, se muestra un fragmento de c\u00f3digo que ilustra la forma de combinar varios resultados procedentes de diferentes variables de tipo CompletableFuture , como en la secci\u00f3n anterior, pero realizando su procesamiento en paralelo: CompletableFuture < String > future1 = CompletableFuture . supplyAsync (() -> \"Hello\" ); CompletableFuture < String > future2 = CompletableFuture . supplyAsync (() -> \"Beautiful\" ); CompletableFuture < String > future3 = CompletableFuture . supplyAsync (() -> \"World\" ); CompletableFuture < Void > combinedFuture = CompletableFuture . allOf ( future1 , future2 , future3 ); // ... combinedFuture . get (); En este caso, hay que tener en cuenta que el resultado de la funci\u00f3n allOf de la clase CompletableFuture es de tipo Void y, por tanto, una limitaci\u00f3n de este m\u00e9todo es que no se pueden combinar los resultados de las variables future1 , future2 y future3 . No obstante, haciendo uso del API para Streams de Java 8 se puede solventar este problema: String combined = Stream . of ( future1 , future2 , future3 ) . map ( CompletableFuture :: join ) . collect ( Collectors . joining ( \" \" )); Ejercicios propuestos \u00b6 Ejercicio 1 \u00b6 Dados los siguientes fragmentos de c\u00f3digo, responder a las siguientes preguntas: AsynchronousAPI.java \u00b6 import java.util.List ; import java.util.concurrent.CompletableFuture ; import java.util.concurrent.Executors ; import java.util.concurrent.Future ; public class AsynchronousAPI { public static Future < Integer > additionAsync ( List < Integer > elements ) throws InterruptedException { CompletableFuture < Integer > completableFuture = new CompletableFuture <> (); Executors . newCachedThreadPool (). submit (() -> { //TO-DO }); return completableFuture ; } } Main.java \u00b6 import java.util.Arrays ; import java.util.List ; import java.util.concurrent.ExecutionException ; import java.util.concurrent.Future ; public class Main { public static void main ( String args [] ) throws InterruptedException , ExecutionException { List < Integer > elements = Arrays . asList ( 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 ); Future < Integer > completableFuture = //TO-DO; Integer result = //TO-DO; System . out . println ( \"The result is \" + result ); } } Preguntas propuestas \u00b6 Complete las secciones TO-DO de las clases AsynchronousAPI y Main , teniendo en cuenta que: El m\u00e9todo additionAsync debe devolver la suma de todos los n\u00fameros contenidos en elements . El m\u00e9todo additionAsync debe mostrar por consola cada uno de los elementos que esta sumando con el mensaje Adding (element) . El m\u00e9todo additionAsync debe a\u00f1adir un retardo de 5 segundos en la suma de cada elemento. En la funci\u00f3n main se debe mostrar en consola el resultado de la suma completa con el mensaje The result is (result) . Ejercicio 2 \u00b6 Dado los siguientes fragmentos de c\u00f3digo responder a las siguientes preguntas: AsynchronousAPI.java \u00b6 import java.util.List ; import java.util.concurrent.CompletableFuture ; import java.util.concurrent.Executors ; public class AsynchronousAPI { public static CompletableFuture < Integer > additionAsync ( List < Integer > elements ) throws InterruptedException { //TO-DO } public static CompletableFuture < Integer > mutiplicationAsync ( List < Integer > elements ) throws InterruptedException { //TO-DO } } Main.java \u00b6 import java.util.Arrays ; import java.util.List ; import java.util.concurrent.CompletableFuture ; import java.util.concurrent.ExecutionException ; public class Main { public static void main ( String args [] ) throws InterruptedException , ExecutionException { List < Integer > elements = Arrays . asList ( 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 ); List < Integer > elements2 = Arrays . asList ( 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 ); CompletableFuture < Void > completableFuture = //TO-DO; completableFuture . get (); } } Preguntas propuestas \u00b6 Complete las secciones TO-DO de las clases AsynchronousAPI y Main , teniendo en cuenta que: El m\u00e9todo additionAsync debe devolver la suma de todos los n\u00fameros contenidos en elements . El m\u00e9todo additionAsync debe mostrar por consola cada uno de los elementos que esta sumando con el mensaje Adding (element) . El m\u00e9todo additionAsync debe a\u00f1adir un retardo de 2 segundos en la suma de cada elemento. El m\u00e9todo multiplicationAsync debe devolver la producto de todos los n\u00fameros contenidos en elements2 . El m\u00e9todo multiplicationAsync debe mostrar por consola cada uno de los elementos que esta multiplicando con el mensaje Multiplying (element) . El m\u00e9todo multiplicationAsync debe a\u00f1adir un retardo de 3 segundos en el producto de cada elemento. En la funci\u00f3n main se debe mostrar en consola el resultado de la suma completa con el mensaje The result is (result) . Este mensaje debe ser mostrado de forma directa cuando se complete el resultado de la variable completableFuture . Modifique el c\u00f3digo de la clase Main para que el procesamiento se realice en paralelo y se obtenga el mismo resultado por consola que en el apartado anterior. Referencias \u00b6 [1] Blog Guide to CompletableFuture [2] CompletableFuture API Java 8","title":"Pr\u00e1ctica 2"},{"location":"fp-p2/#repaso-de-conceptos-teoricos","text":"","title":"Repaso de conceptos te\u00f3ricos"},{"location":"fp-p2/#programacion-asincrona-en-java","text":"En Java 5 se a\u00f1adi\u00f3 la interfaz Future para integrar la programaci\u00f3n as\u00edncrona. Sin embargo, esta interfaz no proporcionaba la posibilidad de combinar los resultados obtenidos al aplicar diferentes operaciones o manejar los posibles errores. Por este motivo, en Java 8 se incluy\u00f3 la clase CompletableFuture , junto a la interfaz Future , la cual implementa tambi\u00e9n la interfaz CompletionStage . Esta interfaz incluye el contrato de operaciones para incluir la combinaci\u00f3n de resultados procedentes de diferentes operaciones. En las secciones posteriores se ver\u00e1n algunos de los usos propuestos por esta interfaz en Java 8.","title":"Programaci\u00f3n as\u00edncrona en Java"},{"location":"fp-p2/#completablefuture-como-simple-future","text":"A continuaci\u00f3n se muestra un ejemplo de uso de la clase CompletableFuture :","title":"CompletableFuture como (simple) Future"},{"location":"fp-p2/#mainjava","text":"import java.util.concurrent.ExecutionException ; import java.util.concurrent.Future ; public class Main { public static void main ( String args [] ) throws InterruptedException , ExecutionException { Future < String > completableFuture = AsynchronousAPI . helloWorldAsync (); String result = completableFuture . get (); System . out . println ( \"The result is \" + result ); } }","title":"Main.java"},{"location":"fp-p2/#asynchronousapijava","text":"import java.util.concurrent.CompletableFuture ; import java.util.concurrent.Executors ; import java.util.concurrent.Future ; public class AsynchronousAPI { public static Future < String > helloWorldAsync () throws InterruptedException { CompletableFuture < String > completableFuture = new CompletableFuture <> (); Executors . newCachedThreadPool (). submit (() -> { Thread . sleep ( 1000 ); completableFuture . complete ( \"Hello world\" ); return null ; }); return completableFuture ; } } En primer lugar, en la funci\u00f3n main se obtiene la variable completableFuture , la cual es de tipo Future<String> , esta variable obtendr\u00e1 su valor cuando la funci\u00f3n helloWorldAsync() se resuelva. A tr\u00e1ves de la operaci\u00f3n completableFuture.get() se obtiene el resultado de la funci\u00f3n y posteriormente, se muestra en consola. Por otro lado, el comportamiento de la funci\u00f3n helloWorldAsync se basa en el uso de la operaci\u00f3n submit() de Executors.newCachedThreadPool() , la cual crea un nuevo hilo que se suspende durante 10 segundos para a\u00f1adir un retardo temporal y posteriormente completa la operaci\u00f3n con el valor Hello world . En este caso, cuando finalice el procesamiento del programa se mostrar\u00e1 por consola el mensaje The result is Hello world .","title":"AsynchronousAPI.java"},{"location":"fp-p2/#procesamiento-de-resultados-asincronos","text":"A continuaci\u00f3n, se muestra un ejemplo del uso del resultado devuelto en un CompletableFuture desde otra variable del mismo tipo:","title":"Procesamiento de resultados as\u00edncronos"},{"location":"fp-p2/#mainjava_1","text":"import java.util.concurrent.CompletableFuture ; import java.util.concurrent.ExecutionException ; public class Main { public static void main ( String args [] ) throws InterruptedException , ExecutionException { //Then apply CompletableFuture < String > completableFuture = AsynchronousAPI . helloWorldAsync (); CompletableFuture < String > future = completableFuture . thenApply ( s -> s + \" world\" ); String result = future . get (); System . out . println ( result ); //Then accept completableFuture = AsynchronousAPI . helloWorldAsync (); CompletableFuture < Void > futureVoid = completableFuture . thenAccept ( s -> System . out . println ( s + \" world\" )); futureVoid . get (); //Then run completableFuture = AsynchronousAPI . helloWorldAsync (); futureVoid = completableFuture . thenRun (() -> System . out . println ( \"world\" )); futureVoid . get (); } }","title":"Main.java"},{"location":"fp-p2/#asynchronousapijava_1","text":"import java.util.concurrent.CompletableFuture ; import java.util.concurrent.Executors ; import java.util.concurrent.Future ; public class AsynchronousAPI { public static CompletableFuture < String > helloWorldAsync () throws InterruptedException { CompletableFuture < String > completableFuture = new CompletableFuture <> (); Executors . newCachedThreadPool (). submit (() -> { Thread . sleep ( 1000 ); completableFuture . complete ( \"Hello\" ); return null ; }); return completableFuture ; } } En este caso, la funci\u00f3n helloWorldAsync realiza el mismo comportamiento que en el ejemplo anterior, \u00fanicamente con la diferencia de que devuelve Hello y no Hello world completo como en el ejemplo anterior. Por otro lado, en la funci\u00f3n main se utilizan tres funciones de la clase CompletableFuture , a continuaci\u00f3n se detalla el comportamiento de cada una de ellas: thenApply() : La variable future espera el resultado de la resoluci\u00f3n de la variable completableFuture . En este caso, espera un resultado de tipo String . Finalmente, concatena a ese resultado la palabra world y obtiene el valor completo de la cadena en su resoluci\u00f3n, es decir, Hello world . thenAccept() : La variable futureVoid espera el resultado de la resoluci\u00f3n de la variable completableFuture , como en el caso anterior. La diferencia es que la variable futureVoid no podr\u00e1 devolver un resultado de tipo String en su resoluci\u00f3n, sino que ser\u00e1 de tipo Void . Por este motivo, se lanzar\u00e1 directamente la funci\u00f3n System.out.println en la resoluci\u00f3n de la variable futureVoid . thenRun() : La variable futureVoid en este caso no espera ning\u00fan resultado, sino que s\u00f3lo espera la resoluci\u00f3n de la variable completableFuture . Como en el caso anterior, la variable futureVoid lanzar\u00e1 directamente la funci\u00f3n System.out.println en su resoluci\u00f3n, pero no concatenar\u00e1 el resultado de la variable completableFuture , mostrando \u00fanicamente la palabra world .","title":"AsynchronousAPI.java"},{"location":"fp-p2/#combinacion-de-futures","text":"A continuaci\u00f3n, se muestran varios fragmentos de c\u00f3digo que ilustran la forma de combinar varios resultados procedentes de diferentes variables de tipo CompletableFuture : CompletableFuture < String > completableFuture = CompletableFuture . supplyAsync (() -> \"Hello\" ) . thenCompose ( s -> CompletableFuture . supplyAsync (() -> s + \" World\" )); CompletableFuture < String > completableFuture = CompletableFuture . supplyAsync (() -> \"Hello\" ) . thenCombine ( CompletableFuture . supplyAsync ( () -> \" World\" ), ( s1 , s2 ) -> s1 + s2 )); CompletableFuture future = CompletableFuture . supplyAsync (() -> \"Hello\" ) . thenAcceptBoth ( CompletableFuture . supplyAsync (() -> \" World\" ), ( s1 , s2 ) -> System . out . println ( s1 + s2 )); En la secci\u00f3n anterior se utilizan tres funciones de la clase CompletableFuture para combinar los resultados. A continuaci\u00f3n se detalla el comportamiento de cada una de ellas: thenCompose() : Esta funci\u00f3n permite \"concatenar\" el resultado de una variable CompletableFuture en otra una vez que haya finalizado su procesamiento. En este caso, la ejecuci\u00f3n de los CompletableFuture no es independiente, sino que se encadenan de forma secuencial. thenCombine() : Esta funci\u00f3n permite ejecutar los CompletableFuture de forma independiente y, posteriormente, combinar los resultados en la variable CompletableFuture resultante (future). thenAcceptBoth() : Esta funci\u00f3n realiza el mismo procesamiento que thenCombine() , pero con la diferencia que la variable CompletableFuture resultante (future) es de tipo Void y realiza una acci\u00f3n. En este caso, invoca a la funci\u00f3n System.out.println .","title":"Combinaci\u00f3n de Futures"},{"location":"fp-p2/#ejecucion-de-futures-en-paralelo","text":"A continuaci\u00f3n, se muestra un fragmento de c\u00f3digo que ilustra la forma de combinar varios resultados procedentes de diferentes variables de tipo CompletableFuture , como en la secci\u00f3n anterior, pero realizando su procesamiento en paralelo: CompletableFuture < String > future1 = CompletableFuture . supplyAsync (() -> \"Hello\" ); CompletableFuture < String > future2 = CompletableFuture . supplyAsync (() -> \"Beautiful\" ); CompletableFuture < String > future3 = CompletableFuture . supplyAsync (() -> \"World\" ); CompletableFuture < Void > combinedFuture = CompletableFuture . allOf ( future1 , future2 , future3 ); // ... combinedFuture . get (); En este caso, hay que tener en cuenta que el resultado de la funci\u00f3n allOf de la clase CompletableFuture es de tipo Void y, por tanto, una limitaci\u00f3n de este m\u00e9todo es que no se pueden combinar los resultados de las variables future1 , future2 y future3 . No obstante, haciendo uso del API para Streams de Java 8 se puede solventar este problema: String combined = Stream . of ( future1 , future2 , future3 ) . map ( CompletableFuture :: join ) . collect ( Collectors . joining ( \" \" ));","title":"Ejecuci\u00f3n de Futures en paralelo"},{"location":"fp-p2/#ejercicios-propuestos","text":"","title":"Ejercicios propuestos"},{"location":"fp-p2/#ejercicio-1","text":"Dados los siguientes fragmentos de c\u00f3digo, responder a las siguientes preguntas:","title":"Ejercicio 1"},{"location":"fp-p2/#asynchronousapijava_2","text":"import java.util.List ; import java.util.concurrent.CompletableFuture ; import java.util.concurrent.Executors ; import java.util.concurrent.Future ; public class AsynchronousAPI { public static Future < Integer > additionAsync ( List < Integer > elements ) throws InterruptedException { CompletableFuture < Integer > completableFuture = new CompletableFuture <> (); Executors . newCachedThreadPool (). submit (() -> { //TO-DO }); return completableFuture ; } }","title":"AsynchronousAPI.java"},{"location":"fp-p2/#mainjava_2","text":"import java.util.Arrays ; import java.util.List ; import java.util.concurrent.ExecutionException ; import java.util.concurrent.Future ; public class Main { public static void main ( String args [] ) throws InterruptedException , ExecutionException { List < Integer > elements = Arrays . asList ( 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 ); Future < Integer > completableFuture = //TO-DO; Integer result = //TO-DO; System . out . println ( \"The result is \" + result ); } }","title":"Main.java"},{"location":"fp-p2/#preguntas-propuestas","text":"Complete las secciones TO-DO de las clases AsynchronousAPI y Main , teniendo en cuenta que: El m\u00e9todo additionAsync debe devolver la suma de todos los n\u00fameros contenidos en elements . El m\u00e9todo additionAsync debe mostrar por consola cada uno de los elementos que esta sumando con el mensaje Adding (element) . El m\u00e9todo additionAsync debe a\u00f1adir un retardo de 5 segundos en la suma de cada elemento. En la funci\u00f3n main se debe mostrar en consola el resultado de la suma completa con el mensaje The result is (result) .","title":"Preguntas propuestas"},{"location":"fp-p2/#ejercicio-2","text":"Dado los siguientes fragmentos de c\u00f3digo responder a las siguientes preguntas:","title":"Ejercicio 2"},{"location":"fp-p2/#asynchronousapijava_3","text":"import java.util.List ; import java.util.concurrent.CompletableFuture ; import java.util.concurrent.Executors ; public class AsynchronousAPI { public static CompletableFuture < Integer > additionAsync ( List < Integer > elements ) throws InterruptedException { //TO-DO } public static CompletableFuture < Integer > mutiplicationAsync ( List < Integer > elements ) throws InterruptedException { //TO-DO } }","title":"AsynchronousAPI.java"},{"location":"fp-p2/#mainjava_3","text":"import java.util.Arrays ; import java.util.List ; import java.util.concurrent.CompletableFuture ; import java.util.concurrent.ExecutionException ; public class Main { public static void main ( String args [] ) throws InterruptedException , ExecutionException { List < Integer > elements = Arrays . asList ( 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 ); List < Integer > elements2 = Arrays . asList ( 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 ); CompletableFuture < Void > completableFuture = //TO-DO; completableFuture . get (); } }","title":"Main.java"},{"location":"fp-p2/#preguntas-propuestas_1","text":"Complete las secciones TO-DO de las clases AsynchronousAPI y Main , teniendo en cuenta que: El m\u00e9todo additionAsync debe devolver la suma de todos los n\u00fameros contenidos en elements . El m\u00e9todo additionAsync debe mostrar por consola cada uno de los elementos que esta sumando con el mensaje Adding (element) . El m\u00e9todo additionAsync debe a\u00f1adir un retardo de 2 segundos en la suma de cada elemento. El m\u00e9todo multiplicationAsync debe devolver la producto de todos los n\u00fameros contenidos en elements2 . El m\u00e9todo multiplicationAsync debe mostrar por consola cada uno de los elementos que esta multiplicando con el mensaje Multiplying (element) . El m\u00e9todo multiplicationAsync debe a\u00f1adir un retardo de 3 segundos en el producto de cada elemento. En la funci\u00f3n main se debe mostrar en consola el resultado de la suma completa con el mensaje The result is (result) . Este mensaje debe ser mostrado de forma directa cuando se complete el resultado de la variable completableFuture . Modifique el c\u00f3digo de la clase Main para que el procesamiento se realice en paralelo y se obtenga el mismo resultado por consola que en el apartado anterior.","title":"Preguntas propuestas"},{"location":"fp-p2/#referencias","text":"[1] Blog Guide to CompletableFuture [2] CompletableFuture API Java 8","title":"Referencias"},{"location":"fp-p3/","text":"Pr\u00e1ctica 3: Streams Repaso de conceptos te\u00f3ricos \u00b6 Stream API en Java \u00b6 Definici\u00f3n de Stream procedente de pr\u00e1cticas anteriores \u00b6 Un stream representa una secuencia de elementos que soportan diferentes tipos de operaciones para realizar c\u00e1lculos sobre ellos. Las posibles operaciones que se pueden realizar sobre un stream pueden ser intermediarias o terminales . Las operaciones intermediarias devuelven un nuevo stream , permitiendo encadenar m\u00faltiples operaciones intermediarias sin usar punto y coma. Por otro lado, las operaciones terminales son nulas o devuelven un resultado de un tipo diferente, por ejemplo un tipo num\u00e9rico. por Benjamin, Java 8 Stream Tutorial En el ejemplo anterior, las operaciones filter , map y sorted son operaciones intermediarias, mientras que la operaci\u00f3n forEach es una operaci\u00f3n terminal. M\u00e1s informaci\u00f3n: https://www.oracle.com/technetwork/es/articles/java/procesamiento-streams-java-se-8-2763402-esa.html Por otro lado, se puede observar que la mayor\u00eda de las operaciones que se aplican sobre streams aceptan alg\u00fan tipo de par\u00e1metro en forma de expresi\u00f3n lambda , que es una interfaz funcional que especifica el comportamiento exacto de la operaci\u00f3n. Estas operaciones no pueden modificar el contenido del stream original. En el ejemplo anterior, se puede observar que ninguna de las operaciones modifica la variable myList a\u00f1adiendo o eliminando elementos, sino que s\u00f3lo se realiza el filtrado de los elementos que no empiezan por \"c\", se transforman a may\u00fasculas, se ordenan en orden alfab\u00e9tico y se imprimen por pantalla. M\u00e1s informaci\u00f3n: https://www.oracle.com/technetwork/es/articles/java/expresiones-lambda-api-stream-java-2737544-esa.html Finalmente, se incluye otro ejemplo del uso del Stream API en Java: ArrayList < Integer > mayores = ( ArrayList < Integer > ) Arrays . asList ( 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 ) . stream () . filter ( x -> x > 5 ) . collect ( Collectors . toCollection (() -> new ArrayList < Integer > ()) ); mayores . forEach ( e -> System . out . println ( e )); En el ejemplo anterior se realiza el filtrado de los n\u00fameros que sean mayores que 5 y, posteriormente, se imprimen por pantalla los elementos de la lista. Por lo tanto, la salida del programa por consola en este caso ser\u00eda: 6 7 8 9 10 Definici\u00f3n de operaciones disponibles en la API \u00b6 A continuaci\u00f3n, se describen las operaciones disponibles en el Stream API haciendo la comparativa con las consultas realizadas en SQL: Consultas simples \u00b6 En este caso se desea listar el nombre de todos los productos disponibles en la base de datos. Si se considera la siguiente consulta SQL: select name from products ; El equivalente con Stream API ser\u00eda: List < Products > products ; ... Stream < String > streams = products . stream (). map ( Product :: getName ); Con el m\u00e9todo stream() se obtiene la secuencia de elementos de tipo Product . Ser\u00eda equivalente al from de SQL. Con el m\u00e9todo map se recupera \u00fanicamente el atributo name . Ser\u00eda equivalente al select de SQL. Consultas con filtrado \u00b6 En este caso se desea listar los nombres de los productos cuya existencia en el almacen sea menor a 10 unidades. Si se considera la siguiente consulta SQL: select name from products where units_in_stock < 10 ; El equivalente con Stream API ser\u00eda: Stream < String > streams = products . stream (). filter ( p -> p . getUnitsInStock () < 10 ). map ( Product :: getName ); streams . forEach ( product -> System . out . println ( product )); Con el m\u00e9todo stream() se obtiene la secuencia de elementos de tipo Product . Ser\u00eda equivalente al from de SQL. Con el m\u00e9todo filter se recuperan \u00fanicamente los productos que cumplan la condici\u00f3n que se le pasa como par\u00e1metro. En este caso, los que su n\u00famero de unidades sea mayor a 10. Ser\u00eda equivalente al where de SQL. Con el m\u00e9todo map se recupera \u00fanicamente el atributo name . Ser\u00eda equivalente al select de SQL. Consultas con ordenaci\u00f3n \u00b6 En este caso se desea listar los nombres de los productos cuya existencia en el almac\u00e9n sea menor a 10 unidades pero en orden ascendente, es decir, de menor existencia a mayor existencia. Si se considera la siguiente consulta SQL: select name from products where units_in_stock < 10 order by units_in_stock asc ; El equivalente con Stream API ser\u00eda: Stream < String > streams = products . stream () . filter ( p -> p . getUnitsInStock () < 10 ) . sorted ( Comparator . comparingDouble ( Product :: getUnitsInStock )) . map ( Product :: getName ); Con el m\u00e9todo stream() se obtiene la secuencia de elementos de tipo Product . Ser\u00eda equivalente al from de SQL. Con el m\u00e9todo filter se recuperan \u00fanicamente los productos que cumplan la condici\u00f3n que se le pasa como par\u00e1metro. En este caso, los que su n\u00famero de unidades sea mayor a 10. Ser\u00eda equivalente al where de SQL. Con el m\u00e9todo sorted se recuperan los productos utilizando el m\u00e9todo de ordenaci\u00f3n que recibe como par\u00e1metro. En este caso, los recupera en orden ascendente comparando su n\u00famero de unidades. Ser\u00eda equivalente al order by de SQL. Con el m\u00e9todo map se recupera \u00fanicamente el atributo name . Ser\u00eda equivalente al select de SQL. Consultas con agrupaci\u00f3n \u00b6 En este caso se desea listar el n\u00famero de productos agrupados por proveedor. Si se considera la siguiente consulta SQL: select count ( 1 ), supplierID from products group by supplierID El equivalente con Stream API ser\u00eda: Map < Integer , Long > collect = products . stream () . collect ( Collectors . groupingBy ( Product :: getSupplier , Collectors . counting () ) ); collect . forEach (( s , c ) -> System . out . printf ( \"proveedor: %s: productos: %s \\n\" , s , c )); Con el m\u00e9todo stream() se obtiene la secuencia de elementos de tipo Product . Ser\u00eda equivalente al from de SQL. Con el m\u00e9todo collect se realiza el agrupamiento a trav\u00e9s de los criterios recibidos como par\u00e1metros. En este caso, los productos se agrupan por proveedor y se cuentan. Ser\u00eda el equivalent a group by en SQL. Consultas con sumatorios \u00b6 En este caso se desea obtener la suma del precio unitario de todos los productos agrupados por el n\u00famero existente en el almacen. Si se considera la siguiente consulta SQL: select unitsInStock , sum ( unitPrice ) from products group by unitsInStock ; El equivalente con Stream API ser\u00eda: Map < Integer , Double > collect = products . stream () . collect ( Collectors . groupingBy ( Product :: getUnitsInStock , Collectors . summingDouble ( Product :: getUnitPrice ) ) ); collect . forEach (( stock , suma ) -> System . out . printf ( \"en stock: %s: suma: %s \\n\" , stock , suma )); Con el m\u00e9todo stream() se obtiene la secuencia de elementos de tipo Product . Ser\u00eda equivalente al from de SQL. Con el m\u00e9todo collect se realiza el agrupamiento a trav\u00e9s de los criterios recibidos como par\u00e1metros. En este caso, los productos se agrupan por n\u00famero de unidades existentes en el almacen y se suman. Ser\u00eda el equivalent a group by con el uso de sum en SQL. Consultas con filtrado sobre grupos \u00b6 En este caso se desea obtener la suma del precio unitario de todos los productos agrupados por su n\u00famero de existencias en el almacen, pero solo obtener aquellos productos cuya suma sea mayor a 100. Si se considera la siguiente consulta SQL: select unitsInStock , sum ( unitPrice ) from products group by unitsInStock having sum ( unitPrice ) > 100 ; El equivalente con Stream API ser\u00eda: List < Map . Entry < Integer , Double >> entryList = products . stream () . collect ( Collectors . groupingBy ( Product :: getUnitsInStock , Collectors . summingDouble ( Product :: getUnitPrice ) ) ). entrySet () . stream () . filter ( p -> p . getValue () > 100 ) . collect ( Collectors . toList ()); entryList . forEach ( list -> System . out . printf ( \"en stock: %s, suma: %s\\n\" , list . getKey (), list . getValue ())); Con el m\u00e9todo stream() se obtiene la secuencia de elementos de tipo Product . Ser\u00eda equivalente al from de SQL Con el m\u00e9todo collect se realiza el agrupamiento a trav\u00e9s de los criterios recibidos como par\u00e1metros. En este caso, los productos se agrupan por n\u00famero de unidades existentes en el almacen y se suman. Ser\u00eda el equivalent a group by con el uso de sum en SQL. Con el m\u00e9todo filter se recuperan \u00fanicamente los productos que cumplan la condici\u00f3n que se le pasa como par\u00e1metro. En este caso, los que la suma sea mayor a 100. En este caso, ser\u00eda equivalente al having de SQL porque va detr\u00e1s de una operaci\u00f3n con criterios de agrupaci\u00f3n. Ejercicios propuestos \u00b6 Ejercicio 1 \u00b6 Dados los siguientes fragmentos de c\u00f3digo, responder a las siguientes preguntas: Employee.java \u00b6 public class Employee { String name ; int age ; public Employee ( String name , int age ) { this . name = name ; this . age = age ; } public String getName () { return name ; } public void setName ( String name ) { this . name = name ; } public int getAge () { return age ; } public void setAge ( int age ) { this . age = age ; } public String toString () { return \"Name = \" + name + \", Age = \" + age ; } } EmployeeDatabase.java \u00b6 import java.util.ArrayList ; import java.util.Arrays ; import java.util.List ; public class EmployeeDatabase { private static List < Employee > employees = Arrays . asList ( new Employee ( \"Employee1\" , 20 ), new Employee ( \"Employee2\" , 30 ), new Employee ( \"Employee3\" , 40 ), new Employee ( \"Employee4\" , 50 )); public static Employee getEmployeeByName ( String name ) { Employee result = null ; for ( Employee e : employees ) { if ( e . getName (). equals ( name )) { result = e ; } } return result ; } public static Employee getEmployeeByNameAndAge ( String name , int age ) { Employee result = null ; for ( Employee e : employees ) { if ( e . getName (). equals ( name ) && e . getAge () == age ) { result = e ; } } return result ; } public static List < Employee > getEmployeeByAgeOver ( int limitAge ) { List < Employee > result = new ArrayList < Employee > (); for ( Employee e : employees ) { if ( e . getAge () > limitAge ) { result . add ( e ); } } return result ; } public static List < Employee > getEmployeeByAgeUnder ( int limitAge ) { List < Employee > result = new ArrayList < Employee > (); for ( Employee e : employees ) { if ( e . getAge () < limitAge ) { result . add ( e ); } } return result ; } } Main.java \u00b6 public class Main { public static void main ( String args [] ) { System . out . println ( \"Employee = \" + EmployeeDatabase . getEmployeeByName ( \"Employee1\" )); System . out . println ( \"Employee = \" + EmployeeDatabase . getEmployeeByName ( \"EmployeeNull\" )); System . out . println ( \"Employee = \" + EmployeeDatabase . getEmployeeByNameAndAge ( \"Employee2\" , 30 )); System . out . println ( \"Employee = \" + EmployeeDatabase . getEmployeeByNameAndAge ( \"Employee2\" , 20 )); System . out . println ( \"Employees = \" + EmployeeDatabase . getEmployeeByAgeOver ( 30 )); System . out . println ( \"Employees = \" + EmployeeDatabase . getEmployeeByAgeUnder ( 30 )); } } Modifique las operaciones de la clase EmployeeDatabase utilizando las operaciones de la API para Stream de Java 8. Extienda la API de la clase EmployeeDatabase a\u00f1adiendo las siguientes operaciones: Obtener los empleados cuya edad este comprendida entre un rango dado en la operaci\u00f3n como par\u00e1metros ( maxAge y minAge ). Obtener los empleados ordenados ascendentemente por su edad. Obtener los empleados ordenados descendentemente por su edad. Obtener el n\u00famero de empleados que existen en la base de datos. Obtener el n\u00famero de empleados que existen en la base de datos y su nombre es igual a uno dado en la operaci\u00f3n como par\u00e1metro. Ejercicio 2 \u00b6 Bas\u00e1ndose en el c\u00f3digo del ejercicio anterior, implemente una API para una tienda de videojuegos, teniendo en cuenta lo siguiente: Implemente la clase Videogame contemplando los siguientes criterios: a) La clase contendr\u00e1 los siguientes atributos: El t\u00edtulo de tipo string. La categor\u00eda de tipo string. El precio de tipo double. b) La clase contendr\u00e1 las operaciones set y get necesarias para el acceso a los atributos anteriores. Implemente la clase VideogameDatabase contemplando los siguientes criterios: a) La clase contendr\u00e1 los siguientes atributos: La lista de videojuegos existentes de tipo Videogame . b) La clase contendr\u00e1 las siguientes operaciones implementadas con el Stream API de Java 8: Listar todos los t\u00edtulos de los videojuegos. Listar todos los t\u00edtulos de los videojuegos cuyo precio sea superior a 20\u20ac. Listar todos los t\u00edtulos de los videojuegos cuya categor\u00eda sea terror. Listar todos los t\u00edtulos de los videojuegos cuyo precio sea superior a 20\u20ac ordenados ascendentemente por el precio. Listar todos los t\u00edtulos de los videojuegos cuyo precio sea superior a 20\u20ac ordenados descendentemente por el precio. Obtener el n\u00famero de videojuegos agrupados por categor\u00eda. Obtener la suma de los precios de los videojuegos agrupados por categor\u00eda. Obtener la suma de los precios de los videojuegos agrupados por cateogor\u00eda, siempre que el precio obtenido de la suma sea superior a 200\u20ac. Implemente adem\u00e1s un programa de prueba Main que ilustre el uso de las operaciones anteriores. Referencias \u00b6 [1] Blog: Java 8 Stream Tutorial. [2] Documentaci\u00f3n Oficial Java: Procesamiento de datos con streams de Java SE 8. [3] Documentaci\u00f3n Oficial Java: Introducci\u00f3n Expresiones Lambda y API Stream en Java SE 8. [4] Blog: API Stream de Java 8 (workshop).","title":"Pr\u00e1ctica 3"},{"location":"fp-p3/#repaso-de-conceptos-teoricos","text":"","title":"Repaso de conceptos te\u00f3ricos"},{"location":"fp-p3/#stream-api-en-java","text":"","title":"Stream API en Java"},{"location":"fp-p3/#definicion-de-stream-procedente-de-practicas-anteriores","text":"Un stream representa una secuencia de elementos que soportan diferentes tipos de operaciones para realizar c\u00e1lculos sobre ellos. Las posibles operaciones que se pueden realizar sobre un stream pueden ser intermediarias o terminales . Las operaciones intermediarias devuelven un nuevo stream , permitiendo encadenar m\u00faltiples operaciones intermediarias sin usar punto y coma. Por otro lado, las operaciones terminales son nulas o devuelven un resultado de un tipo diferente, por ejemplo un tipo num\u00e9rico. por Benjamin, Java 8 Stream Tutorial En el ejemplo anterior, las operaciones filter , map y sorted son operaciones intermediarias, mientras que la operaci\u00f3n forEach es una operaci\u00f3n terminal. M\u00e1s informaci\u00f3n: https://www.oracle.com/technetwork/es/articles/java/procesamiento-streams-java-se-8-2763402-esa.html Por otro lado, se puede observar que la mayor\u00eda de las operaciones que se aplican sobre streams aceptan alg\u00fan tipo de par\u00e1metro en forma de expresi\u00f3n lambda , que es una interfaz funcional que especifica el comportamiento exacto de la operaci\u00f3n. Estas operaciones no pueden modificar el contenido del stream original. En el ejemplo anterior, se puede observar que ninguna de las operaciones modifica la variable myList a\u00f1adiendo o eliminando elementos, sino que s\u00f3lo se realiza el filtrado de los elementos que no empiezan por \"c\", se transforman a may\u00fasculas, se ordenan en orden alfab\u00e9tico y se imprimen por pantalla. M\u00e1s informaci\u00f3n: https://www.oracle.com/technetwork/es/articles/java/expresiones-lambda-api-stream-java-2737544-esa.html Finalmente, se incluye otro ejemplo del uso del Stream API en Java: ArrayList < Integer > mayores = ( ArrayList < Integer > ) Arrays . asList ( 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 ) . stream () . filter ( x -> x > 5 ) . collect ( Collectors . toCollection (() -> new ArrayList < Integer > ()) ); mayores . forEach ( e -> System . out . println ( e )); En el ejemplo anterior se realiza el filtrado de los n\u00fameros que sean mayores que 5 y, posteriormente, se imprimen por pantalla los elementos de la lista. Por lo tanto, la salida del programa por consola en este caso ser\u00eda: 6 7 8 9 10","title":"Definici\u00f3n de Stream procedente de pr\u00e1cticas anteriores"},{"location":"fp-p3/#definicion-de-operaciones-disponibles-en-la-api","text":"A continuaci\u00f3n, se describen las operaciones disponibles en el Stream API haciendo la comparativa con las consultas realizadas en SQL:","title":"Definici\u00f3n de operaciones disponibles en la API"},{"location":"fp-p3/#consultas-simples","text":"En este caso se desea listar el nombre de todos los productos disponibles en la base de datos. Si se considera la siguiente consulta SQL: select name from products ; El equivalente con Stream API ser\u00eda: List < Products > products ; ... Stream < String > streams = products . stream (). map ( Product :: getName ); Con el m\u00e9todo stream() se obtiene la secuencia de elementos de tipo Product . Ser\u00eda equivalente al from de SQL. Con el m\u00e9todo map se recupera \u00fanicamente el atributo name . Ser\u00eda equivalente al select de SQL.","title":"Consultas simples"},{"location":"fp-p3/#consultas-con-filtrado","text":"En este caso se desea listar los nombres de los productos cuya existencia en el almacen sea menor a 10 unidades. Si se considera la siguiente consulta SQL: select name from products where units_in_stock < 10 ; El equivalente con Stream API ser\u00eda: Stream < String > streams = products . stream (). filter ( p -> p . getUnitsInStock () < 10 ). map ( Product :: getName ); streams . forEach ( product -> System . out . println ( product )); Con el m\u00e9todo stream() se obtiene la secuencia de elementos de tipo Product . Ser\u00eda equivalente al from de SQL. Con el m\u00e9todo filter se recuperan \u00fanicamente los productos que cumplan la condici\u00f3n que se le pasa como par\u00e1metro. En este caso, los que su n\u00famero de unidades sea mayor a 10. Ser\u00eda equivalente al where de SQL. Con el m\u00e9todo map se recupera \u00fanicamente el atributo name . Ser\u00eda equivalente al select de SQL.","title":"Consultas con filtrado"},{"location":"fp-p3/#consultas-con-ordenacion","text":"En este caso se desea listar los nombres de los productos cuya existencia en el almac\u00e9n sea menor a 10 unidades pero en orden ascendente, es decir, de menor existencia a mayor existencia. Si se considera la siguiente consulta SQL: select name from products where units_in_stock < 10 order by units_in_stock asc ; El equivalente con Stream API ser\u00eda: Stream < String > streams = products . stream () . filter ( p -> p . getUnitsInStock () < 10 ) . sorted ( Comparator . comparingDouble ( Product :: getUnitsInStock )) . map ( Product :: getName ); Con el m\u00e9todo stream() se obtiene la secuencia de elementos de tipo Product . Ser\u00eda equivalente al from de SQL. Con el m\u00e9todo filter se recuperan \u00fanicamente los productos que cumplan la condici\u00f3n que se le pasa como par\u00e1metro. En este caso, los que su n\u00famero de unidades sea mayor a 10. Ser\u00eda equivalente al where de SQL. Con el m\u00e9todo sorted se recuperan los productos utilizando el m\u00e9todo de ordenaci\u00f3n que recibe como par\u00e1metro. En este caso, los recupera en orden ascendente comparando su n\u00famero de unidades. Ser\u00eda equivalente al order by de SQL. Con el m\u00e9todo map se recupera \u00fanicamente el atributo name . Ser\u00eda equivalente al select de SQL.","title":"Consultas con ordenaci\u00f3n"},{"location":"fp-p3/#consultas-con-agrupacion","text":"En este caso se desea listar el n\u00famero de productos agrupados por proveedor. Si se considera la siguiente consulta SQL: select count ( 1 ), supplierID from products group by supplierID El equivalente con Stream API ser\u00eda: Map < Integer , Long > collect = products . stream () . collect ( Collectors . groupingBy ( Product :: getSupplier , Collectors . counting () ) ); collect . forEach (( s , c ) -> System . out . printf ( \"proveedor: %s: productos: %s \\n\" , s , c )); Con el m\u00e9todo stream() se obtiene la secuencia de elementos de tipo Product . Ser\u00eda equivalente al from de SQL. Con el m\u00e9todo collect se realiza el agrupamiento a trav\u00e9s de los criterios recibidos como par\u00e1metros. En este caso, los productos se agrupan por proveedor y se cuentan. Ser\u00eda el equivalent a group by en SQL.","title":"Consultas con agrupaci\u00f3n"},{"location":"fp-p3/#consultas-con-sumatorios","text":"En este caso se desea obtener la suma del precio unitario de todos los productos agrupados por el n\u00famero existente en el almacen. Si se considera la siguiente consulta SQL: select unitsInStock , sum ( unitPrice ) from products group by unitsInStock ; El equivalente con Stream API ser\u00eda: Map < Integer , Double > collect = products . stream () . collect ( Collectors . groupingBy ( Product :: getUnitsInStock , Collectors . summingDouble ( Product :: getUnitPrice ) ) ); collect . forEach (( stock , suma ) -> System . out . printf ( \"en stock: %s: suma: %s \\n\" , stock , suma )); Con el m\u00e9todo stream() se obtiene la secuencia de elementos de tipo Product . Ser\u00eda equivalente al from de SQL. Con el m\u00e9todo collect se realiza el agrupamiento a trav\u00e9s de los criterios recibidos como par\u00e1metros. En este caso, los productos se agrupan por n\u00famero de unidades existentes en el almacen y se suman. Ser\u00eda el equivalent a group by con el uso de sum en SQL.","title":"Consultas con sumatorios"},{"location":"fp-p3/#consultas-con-filtrado-sobre-grupos","text":"En este caso se desea obtener la suma del precio unitario de todos los productos agrupados por su n\u00famero de existencias en el almacen, pero solo obtener aquellos productos cuya suma sea mayor a 100. Si se considera la siguiente consulta SQL: select unitsInStock , sum ( unitPrice ) from products group by unitsInStock having sum ( unitPrice ) > 100 ; El equivalente con Stream API ser\u00eda: List < Map . Entry < Integer , Double >> entryList = products . stream () . collect ( Collectors . groupingBy ( Product :: getUnitsInStock , Collectors . summingDouble ( Product :: getUnitPrice ) ) ). entrySet () . stream () . filter ( p -> p . getValue () > 100 ) . collect ( Collectors . toList ()); entryList . forEach ( list -> System . out . printf ( \"en stock: %s, suma: %s\\n\" , list . getKey (), list . getValue ())); Con el m\u00e9todo stream() se obtiene la secuencia de elementos de tipo Product . Ser\u00eda equivalente al from de SQL Con el m\u00e9todo collect se realiza el agrupamiento a trav\u00e9s de los criterios recibidos como par\u00e1metros. En este caso, los productos se agrupan por n\u00famero de unidades existentes en el almacen y se suman. Ser\u00eda el equivalent a group by con el uso de sum en SQL. Con el m\u00e9todo filter se recuperan \u00fanicamente los productos que cumplan la condici\u00f3n que se le pasa como par\u00e1metro. En este caso, los que la suma sea mayor a 100. En este caso, ser\u00eda equivalente al having de SQL porque va detr\u00e1s de una operaci\u00f3n con criterios de agrupaci\u00f3n.","title":"Consultas con filtrado sobre grupos"},{"location":"fp-p3/#ejercicios-propuestos","text":"","title":"Ejercicios propuestos"},{"location":"fp-p3/#ejercicio-1","text":"Dados los siguientes fragmentos de c\u00f3digo, responder a las siguientes preguntas:","title":"Ejercicio 1"},{"location":"fp-p3/#employeejava","text":"public class Employee { String name ; int age ; public Employee ( String name , int age ) { this . name = name ; this . age = age ; } public String getName () { return name ; } public void setName ( String name ) { this . name = name ; } public int getAge () { return age ; } public void setAge ( int age ) { this . age = age ; } public String toString () { return \"Name = \" + name + \", Age = \" + age ; } }","title":"Employee.java"},{"location":"fp-p3/#employeedatabasejava","text":"import java.util.ArrayList ; import java.util.Arrays ; import java.util.List ; public class EmployeeDatabase { private static List < Employee > employees = Arrays . asList ( new Employee ( \"Employee1\" , 20 ), new Employee ( \"Employee2\" , 30 ), new Employee ( \"Employee3\" , 40 ), new Employee ( \"Employee4\" , 50 )); public static Employee getEmployeeByName ( String name ) { Employee result = null ; for ( Employee e : employees ) { if ( e . getName (). equals ( name )) { result = e ; } } return result ; } public static Employee getEmployeeByNameAndAge ( String name , int age ) { Employee result = null ; for ( Employee e : employees ) { if ( e . getName (). equals ( name ) && e . getAge () == age ) { result = e ; } } return result ; } public static List < Employee > getEmployeeByAgeOver ( int limitAge ) { List < Employee > result = new ArrayList < Employee > (); for ( Employee e : employees ) { if ( e . getAge () > limitAge ) { result . add ( e ); } } return result ; } public static List < Employee > getEmployeeByAgeUnder ( int limitAge ) { List < Employee > result = new ArrayList < Employee > (); for ( Employee e : employees ) { if ( e . getAge () < limitAge ) { result . add ( e ); } } return result ; } }","title":"EmployeeDatabase.java"},{"location":"fp-p3/#mainjava","text":"public class Main { public static void main ( String args [] ) { System . out . println ( \"Employee = \" + EmployeeDatabase . getEmployeeByName ( \"Employee1\" )); System . out . println ( \"Employee = \" + EmployeeDatabase . getEmployeeByName ( \"EmployeeNull\" )); System . out . println ( \"Employee = \" + EmployeeDatabase . getEmployeeByNameAndAge ( \"Employee2\" , 30 )); System . out . println ( \"Employee = \" + EmployeeDatabase . getEmployeeByNameAndAge ( \"Employee2\" , 20 )); System . out . println ( \"Employees = \" + EmployeeDatabase . getEmployeeByAgeOver ( 30 )); System . out . println ( \"Employees = \" + EmployeeDatabase . getEmployeeByAgeUnder ( 30 )); } } Modifique las operaciones de la clase EmployeeDatabase utilizando las operaciones de la API para Stream de Java 8. Extienda la API de la clase EmployeeDatabase a\u00f1adiendo las siguientes operaciones: Obtener los empleados cuya edad este comprendida entre un rango dado en la operaci\u00f3n como par\u00e1metros ( maxAge y minAge ). Obtener los empleados ordenados ascendentemente por su edad. Obtener los empleados ordenados descendentemente por su edad. Obtener el n\u00famero de empleados que existen en la base de datos. Obtener el n\u00famero de empleados que existen en la base de datos y su nombre es igual a uno dado en la operaci\u00f3n como par\u00e1metro.","title":"Main.java"},{"location":"fp-p3/#ejercicio-2","text":"Bas\u00e1ndose en el c\u00f3digo del ejercicio anterior, implemente una API para una tienda de videojuegos, teniendo en cuenta lo siguiente: Implemente la clase Videogame contemplando los siguientes criterios: a) La clase contendr\u00e1 los siguientes atributos: El t\u00edtulo de tipo string. La categor\u00eda de tipo string. El precio de tipo double. b) La clase contendr\u00e1 las operaciones set y get necesarias para el acceso a los atributos anteriores. Implemente la clase VideogameDatabase contemplando los siguientes criterios: a) La clase contendr\u00e1 los siguientes atributos: La lista de videojuegos existentes de tipo Videogame . b) La clase contendr\u00e1 las siguientes operaciones implementadas con el Stream API de Java 8: Listar todos los t\u00edtulos de los videojuegos. Listar todos los t\u00edtulos de los videojuegos cuyo precio sea superior a 20\u20ac. Listar todos los t\u00edtulos de los videojuegos cuya categor\u00eda sea terror. Listar todos los t\u00edtulos de los videojuegos cuyo precio sea superior a 20\u20ac ordenados ascendentemente por el precio. Listar todos los t\u00edtulos de los videojuegos cuyo precio sea superior a 20\u20ac ordenados descendentemente por el precio. Obtener el n\u00famero de videojuegos agrupados por categor\u00eda. Obtener la suma de los precios de los videojuegos agrupados por categor\u00eda. Obtener la suma de los precios de los videojuegos agrupados por cateogor\u00eda, siempre que el precio obtenido de la suma sea superior a 200\u20ac. Implemente adem\u00e1s un programa de prueba Main que ilustre el uso de las operaciones anteriores.","title":"Ejercicio 2"},{"location":"fp-p3/#referencias","text":"[1] Blog: Java 8 Stream Tutorial. [2] Documentaci\u00f3n Oficial Java: Procesamiento de datos con streams de Java SE 8. [3] Documentaci\u00f3n Oficial Java: Introducci\u00f3n Expresiones Lambda y API Stream en Java SE 8. [4] Blog: API Stream de Java 8 (workshop).","title":"Referencias"},{"location":"oop-p1/","text":"Pr\u00e1ctica 1: Herencia, composici\u00f3n y polimorfismo Repaso de conceptos te\u00f3ricos \u00b6 Herencia \u00b6 Definici\u00f3n \u00b6 Se puede definir la herencia como el mecanismo por el cual una clase permite heredar sus caracter\u00edsticas (atributos y m\u00e9todos) a otra clase. Este mecanismo puede ser usado para la reutilizaci\u00f3n de c\u00f3digo, la cual permite realizar extensiones independientes del software original. por Carlos Villag\u00f3mez, Enciclopedia de Programaci\u00f3n Orientada a Objetos En el ejemplo de la imagen anterior existe una jerarqu\u00eda de herencia de tres niveles en los que: Todas las clases heredan las funciones y propiedades de la clase \"Animal\". La clase \"Conejo\" hereda las funciones y propiedades de la clase \"Herb\u00edvoro\", las clases \"Le\u00f3n\" y \"Hiena\" las de la clase \"Carn\u00edvoro\" y la clase \"Hombre\" las de la clase \"Omn\u00edvoro\". \u00bfCu\u00e1ndo utilizar la herencia? \u00b6 La herencia debe ser utilizada cuando se cumplen al menos las siguientes condiciones: Existe una relaci\u00f3n \"es un/una\" entre las entidades . Por ejemplo: un le\u00f3n o una hiena son animales, pero un animal no tiene porque ser un le\u00f3n (puede ser cualquiera de las otras subclases). Esto es debido a que la relaci\u00f3n de herencia es unidireccional. Se conoce el 100% de los requisitos del software y \u00e9stos no van a cambiar . Si se conoce perfectamente los requisitos del software que se va a implementar y estos no van a cambiar, se puede deducir las relaciones de herencia que existir\u00e1n entre las clases desde el principio. No obstante, en cualquier otro caso puede ser costoso durante el desarrollo eliminar/mantener estas relaciones si los requisitos van evolucionando en otro sentido. Por ejemplo, esto suceder\u00eda dentro de un proyecto donde se aplica una metodolog\u00eda de desarrollo \u00e1gil. Polimorfismo en la herencia \u00b6 La herencia otorga la propiedad de polimorfismo, que significa que cualquiera de las subclases pueden adoptar la forma de la superclase. Esta es una de las principales ventajas de la herencia, ya que el polimorfismo permite la abstracci\u00f3n del objeto concreto y usar su superclase. Por ejemplo, podr\u00edamos tratar cualquier instancia de la clase \"Hombre\" o \"Le\u00f3n\" como una instancia de la clase \"Animal\", ya que han herendado todas sus funciones y propiedades. Pero no al contrario, ya que la clase \"Le\u00f3n\" podr\u00eda haber a\u00f1adido nuevas propiedades o funciones que no est\u00e9n disponibles en la clase \"Animal\". \u00bfCu\u00e1les son las ventajas de la herencia? \u00b6 Las ventajas que nos propone el uso de la herencia son las siguientes: Permite reutilizar c\u00f3digo de una manera r\u00e1pida y sencilla. Permite el uso del polimorfismo con facilidad. Permite sobreescribir m\u00e9todos, adapt\u00e1ndolos a necesidades espec\u00edficas. Permite crear clases abstractas que hacen de plantilla a las subclases (parecido al patr\u00f3n de dise\u00f1o \"Template Method\"). Composici\u00f3n \u00b6 Definici\u00f3n \u00b6 La composici\u00f3n se basa en la creaci\u00f3n de clases que realizar\u00e1n una \u00fanica y espec\u00edfica funci\u00f3n que complementaran a otras clases, las cuales estar\u00e1n compuestas por ellas. Este mecanismo, nos permitir\u00e1 delegar las funciones a aquellas clases que se han implementado \u00fanicamente para cubrirlas, reutilizando su c\u00f3digo fuente donde sea necesario. por Arturo Verbel de Le\u00f3n, Diagrama de clases para dummies En el ejemplo anterior se puede observar: La clase \"Empresa\" esta compuesta por instancias de la clase \"Empleado\". La clase \"Empleado\" es el compuesto de la clase \"Empresa\", de hecho se establece una relaci\u00f3n donde la cardinalidad es 1..N por lo que la clase \"Empresa\" en su implementaci\u00f3n mantendr\u00e1 una lista de instancias de la clase \"Empleado\". \u00bfCu\u00e1ndo utilizar la composici\u00f3n? \u00b6 La composici\u00f3n debe ser utilizada cuando se cumplen al menos las siguientes condiciones: No existe una relaci\u00f3n \"es un/una\" entre las entidades, si no \"tiene\" . Por ejemplo: a una persona que le encanta correr se le podr\u00eda clasificar como \"runner\", pero establecerlo como herencia ser\u00eda un error, ya que la persona con el paso del tiempo podr\u00eda dejar de serlo. En este caso, ser\u00eda m\u00e1s correcto decir que tiene el \"rol\" de runner usando la composici\u00f3n, pudi\u00e9ndolo eliminar cuando fuese necesario. No se conocen 100% los requisitos del software y \u00e9stos ser\u00e1n actualizados . Cuando no se conocen por completo los requisitos del sistema es m\u00e1s correcto no establecer relaciones de herencia que pudiesen ser eliminadas posteriormente. Por este motivo, crear clases con las funciones espec\u00edficas y vincularlas a otras haciendo uso de la composici\u00f3n, proporciona mayor flexibilidad y tolerancia a cambios en la implementaci\u00f3n. Adem\u00e1s, permite modularizar el sistemma de forma de que sea posteriormente m\u00e1s facil de mantener. Polimorfismo en la composici\u00f3n \u00b6 La composici\u00f3n por si misma no es polim\u00f3rfica, lo cual puede ser de sus mayores desventajas. No obstante, esto puede ser facilmente solventado con el uso de interfaces. De esta manera, los objetos compuestos implementar\u00e1n las interfaces que interese en cada situaci\u00f3n, consiguiendo a\u00f1adir/eliminar las funciones que implementan sin necesidad de afectar a la funcionalidad propuesta por otras clases. por Sergio Mart\u00ednez Rodr\u00edguez, Herencia vs Composici\u00f3n \u00bfTienes claro cu\u00e1l es el rival m\u00e1s d\u00e9bil? En el ejemplo anterior se puede observar: La clase \"MainActivity\" tiene una funcionalidad dada por un elemento que contiene de la clase \"NavigationDelegate\". Por otro lado, la forma de notificar al resto de clases de que proporciona la funcionalidad \"navigate()\" es implementando la interfaz \"NavigationInterface\". Cuando la clase \"MainActivity\" no deba proporcionar la funcionalidad \"navigate()\" \u00fanicamente debe dejar de implementar la interfaz \"NavigationInterface\" y eliminar la instancia de la clase \"NavigationDelegate\" o dejar de invocar a su funci\u00f3n \"navigate()\". Herencia vs composici\u00f3n \u00b6 Como se ha comentado anteriormente, la herencia es un mecanismo muy potente para reutilizar c\u00f3digo fuente, pero no siempre es la mejor t\u00e9cnica para conseguir este objetivo. Ya que, si se usa la herencia de forma inapropiada se puede conseguir software poco seguro y robusto. Adem\u00e1s, el uso de herencia viola el principio de encapsulaci\u00f3n, ya que la subclase siempre depender\u00e1 de la implementaci\u00f3n de los m\u00e9todos en la superclase (a no ser que los sobreescriba), y \u00e9stos m\u00e9todos se actualizar\u00e1n en futuras versiones, con lo que se conseguir\u00e1 incertidumbre en la funcionalidad del c\u00f3digo fuente programado. A continuaci\u00f3n, se muestra una tabla que incluye las diferencias de uso entre la herencia y la composici\u00f3n en algunas de las etapas del desarrollo software y en otros aspectos de inter\u00e9s: por Sergio Mart\u00ednez Rodr\u00edguez, Herencia vs Composici\u00f3n \u00bfTienes claro cu\u00e1l es el rival m\u00e1s d\u00e9bil? Ejercicios propuestos \u00b6 Ejercicio 1 \u00b6 Dado los siguientes fragmentos de c\u00f3digo responder a las siguientes preguntas: ElementsSet.java \u00b6 public class ElementsSet < E > extends HashSet < E > { //Number of attempted elements insertions using the \"add\" method private int numberOfAddedElements = 0 ; public ElementsSet () {} @Override public boolean add ( E element ) { numberOfAddedElements ++ ; //Counting the element added return super . add ( element ); } @Override public boolean addAll ( Collection <? extends E > elements ) { numberOfAddedElements += elements . size (); //Counting the elements added return super . addAll ( elements ); } public int getNumberOfAddedElements () { return numberOfAddedElements ; } } Main.java \u00b6 ... ElementsSet < String > set = new ElementsSet < String > (); set . addAll ( Arrays . asList ( \"One\" , \"Two\" , \"Three\" )); System . out . println ( set . getNumberOfAddedElements ()); ... Preguntas propuestas \u00b6 a) \u00bfEs el uso de herencia adecuado para la implementaci\u00f3n de la clase \"ElementsSet\"?, \u00bfqu\u00e9 salida muestra la funci\u00f3n \"System.out.println\" al invocar el m\u00e9todo \"getNumberOfAddedElements\", 3 o 6?. b) En el caso de que haya alg\u00fan problema en la implementaci\u00f3n anterior, proponga una soluci\u00f3n alternativa usando composici\u00f3n que resuelva el problema. Ejercicio 2 \u00b6 Dado los siguientes fragmentos de c\u00f3digo responder a las siguientes preguntas: Animal.java \u00b6 public abstract class Animal { //Number of legs the animal holds protected int numberOfLegs = 0 ; public abstract String speak (); public abstract boolean eat ( String typeOfFeed ); public abstract int getNumberOfLegs (); } Cat.java \u00b6 public class Cat extends Animal { @Override public String speak () { return \"Meow\" ; } @Override public boolean eat ( String typeOfFeed ) { if ( typeOfFeed . equals ( \"fish\" )) { return true ; } else { return false ; } } @Override public int getNumberOfLegs () { return super . numberOfLegs ; } } Dog.java \u00b6 public class Dog extends Animal { @Override public String speak () { return \"Woof\" ; } @Override public boolean eat ( String typeOfFeed ) { if ( typeOfFeed . equals ( \"meat\" )) { return true ; } else { return false ; } } @Override public int getNumberOfLegs () { return super . numberOfLegs ; } } Main.java \u00b6 ... Animal cat = new Cat (); Animal dog = new Dog (); System . out . println ( cat . speak ()); System . out . println ( dog . speak ()); ... Preguntas propuestas \u00b6 a) \u00bfEs correcto el uso de herencia en la implementaci\u00f3n de las clases \"Cat\" y \"Dog\"?. \u00bfQu\u00e9 beneficios se obtiene?. b) En el caso de que no sea correcto, proponga una soluci\u00f3n alternativa. \u00bfCu\u00e1les son los beneficios de la soluci\u00f3n propuesta frente a la original?. Referencias \u00b6 [1] Blog Herencia vs Composici\u00f3n \u00bfTienes claro cu\u00e1l es el rival m\u00e1s d\u00e9bil?. [2] Libro Effective Java: A programming Language Guide.","title":"Pr\u00e1ctica 1"},{"location":"oop-p1/#repaso-de-conceptos-teoricos","text":"","title":"Repaso de conceptos te\u00f3ricos"},{"location":"oop-p1/#herencia","text":"","title":"Herencia"},{"location":"oop-p1/#definicion","text":"Se puede definir la herencia como el mecanismo por el cual una clase permite heredar sus caracter\u00edsticas (atributos y m\u00e9todos) a otra clase. Este mecanismo puede ser usado para la reutilizaci\u00f3n de c\u00f3digo, la cual permite realizar extensiones independientes del software original. por Carlos Villag\u00f3mez, Enciclopedia de Programaci\u00f3n Orientada a Objetos En el ejemplo de la imagen anterior existe una jerarqu\u00eda de herencia de tres niveles en los que: Todas las clases heredan las funciones y propiedades de la clase \"Animal\". La clase \"Conejo\" hereda las funciones y propiedades de la clase \"Herb\u00edvoro\", las clases \"Le\u00f3n\" y \"Hiena\" las de la clase \"Carn\u00edvoro\" y la clase \"Hombre\" las de la clase \"Omn\u00edvoro\".","title":"Definici\u00f3n"},{"location":"oop-p1/#cuando-utilizar-la-herencia","text":"La herencia debe ser utilizada cuando se cumplen al menos las siguientes condiciones: Existe una relaci\u00f3n \"es un/una\" entre las entidades . Por ejemplo: un le\u00f3n o una hiena son animales, pero un animal no tiene porque ser un le\u00f3n (puede ser cualquiera de las otras subclases). Esto es debido a que la relaci\u00f3n de herencia es unidireccional. Se conoce el 100% de los requisitos del software y \u00e9stos no van a cambiar . Si se conoce perfectamente los requisitos del software que se va a implementar y estos no van a cambiar, se puede deducir las relaciones de herencia que existir\u00e1n entre las clases desde el principio. No obstante, en cualquier otro caso puede ser costoso durante el desarrollo eliminar/mantener estas relaciones si los requisitos van evolucionando en otro sentido. Por ejemplo, esto suceder\u00eda dentro de un proyecto donde se aplica una metodolog\u00eda de desarrollo \u00e1gil.","title":"\u00bfCu\u00e1ndo utilizar la herencia?"},{"location":"oop-p1/#polimorfismo-en-la-herencia","text":"La herencia otorga la propiedad de polimorfismo, que significa que cualquiera de las subclases pueden adoptar la forma de la superclase. Esta es una de las principales ventajas de la herencia, ya que el polimorfismo permite la abstracci\u00f3n del objeto concreto y usar su superclase. Por ejemplo, podr\u00edamos tratar cualquier instancia de la clase \"Hombre\" o \"Le\u00f3n\" como una instancia de la clase \"Animal\", ya que han herendado todas sus funciones y propiedades. Pero no al contrario, ya que la clase \"Le\u00f3n\" podr\u00eda haber a\u00f1adido nuevas propiedades o funciones que no est\u00e9n disponibles en la clase \"Animal\".","title":"Polimorfismo en la herencia"},{"location":"oop-p1/#cuales-son-las-ventajas-de-la-herencia","text":"Las ventajas que nos propone el uso de la herencia son las siguientes: Permite reutilizar c\u00f3digo de una manera r\u00e1pida y sencilla. Permite el uso del polimorfismo con facilidad. Permite sobreescribir m\u00e9todos, adapt\u00e1ndolos a necesidades espec\u00edficas. Permite crear clases abstractas que hacen de plantilla a las subclases (parecido al patr\u00f3n de dise\u00f1o \"Template Method\").","title":"\u00bfCu\u00e1les son las ventajas de la herencia?"},{"location":"oop-p1/#composicion","text":"","title":"Composici\u00f3n"},{"location":"oop-p1/#definicion_1","text":"La composici\u00f3n se basa en la creaci\u00f3n de clases que realizar\u00e1n una \u00fanica y espec\u00edfica funci\u00f3n que complementaran a otras clases, las cuales estar\u00e1n compuestas por ellas. Este mecanismo, nos permitir\u00e1 delegar las funciones a aquellas clases que se han implementado \u00fanicamente para cubrirlas, reutilizando su c\u00f3digo fuente donde sea necesario. por Arturo Verbel de Le\u00f3n, Diagrama de clases para dummies En el ejemplo anterior se puede observar: La clase \"Empresa\" esta compuesta por instancias de la clase \"Empleado\". La clase \"Empleado\" es el compuesto de la clase \"Empresa\", de hecho se establece una relaci\u00f3n donde la cardinalidad es 1..N por lo que la clase \"Empresa\" en su implementaci\u00f3n mantendr\u00e1 una lista de instancias de la clase \"Empleado\".","title":"Definici\u00f3n"},{"location":"oop-p1/#cuando-utilizar-la-composicion","text":"La composici\u00f3n debe ser utilizada cuando se cumplen al menos las siguientes condiciones: No existe una relaci\u00f3n \"es un/una\" entre las entidades, si no \"tiene\" . Por ejemplo: a una persona que le encanta correr se le podr\u00eda clasificar como \"runner\", pero establecerlo como herencia ser\u00eda un error, ya que la persona con el paso del tiempo podr\u00eda dejar de serlo. En este caso, ser\u00eda m\u00e1s correcto decir que tiene el \"rol\" de runner usando la composici\u00f3n, pudi\u00e9ndolo eliminar cuando fuese necesario. No se conocen 100% los requisitos del software y \u00e9stos ser\u00e1n actualizados . Cuando no se conocen por completo los requisitos del sistema es m\u00e1s correcto no establecer relaciones de herencia que pudiesen ser eliminadas posteriormente. Por este motivo, crear clases con las funciones espec\u00edficas y vincularlas a otras haciendo uso de la composici\u00f3n, proporciona mayor flexibilidad y tolerancia a cambios en la implementaci\u00f3n. Adem\u00e1s, permite modularizar el sistemma de forma de que sea posteriormente m\u00e1s facil de mantener.","title":"\u00bfCu\u00e1ndo utilizar la composici\u00f3n?"},{"location":"oop-p1/#polimorfismo-en-la-composicion","text":"La composici\u00f3n por si misma no es polim\u00f3rfica, lo cual puede ser de sus mayores desventajas. No obstante, esto puede ser facilmente solventado con el uso de interfaces. De esta manera, los objetos compuestos implementar\u00e1n las interfaces que interese en cada situaci\u00f3n, consiguiendo a\u00f1adir/eliminar las funciones que implementan sin necesidad de afectar a la funcionalidad propuesta por otras clases. por Sergio Mart\u00ednez Rodr\u00edguez, Herencia vs Composici\u00f3n \u00bfTienes claro cu\u00e1l es el rival m\u00e1s d\u00e9bil? En el ejemplo anterior se puede observar: La clase \"MainActivity\" tiene una funcionalidad dada por un elemento que contiene de la clase \"NavigationDelegate\". Por otro lado, la forma de notificar al resto de clases de que proporciona la funcionalidad \"navigate()\" es implementando la interfaz \"NavigationInterface\". Cuando la clase \"MainActivity\" no deba proporcionar la funcionalidad \"navigate()\" \u00fanicamente debe dejar de implementar la interfaz \"NavigationInterface\" y eliminar la instancia de la clase \"NavigationDelegate\" o dejar de invocar a su funci\u00f3n \"navigate()\".","title":"Polimorfismo en la composici\u00f3n"},{"location":"oop-p1/#herencia-vs-composicion","text":"Como se ha comentado anteriormente, la herencia es un mecanismo muy potente para reutilizar c\u00f3digo fuente, pero no siempre es la mejor t\u00e9cnica para conseguir este objetivo. Ya que, si se usa la herencia de forma inapropiada se puede conseguir software poco seguro y robusto. Adem\u00e1s, el uso de herencia viola el principio de encapsulaci\u00f3n, ya que la subclase siempre depender\u00e1 de la implementaci\u00f3n de los m\u00e9todos en la superclase (a no ser que los sobreescriba), y \u00e9stos m\u00e9todos se actualizar\u00e1n en futuras versiones, con lo que se conseguir\u00e1 incertidumbre en la funcionalidad del c\u00f3digo fuente programado. A continuaci\u00f3n, se muestra una tabla que incluye las diferencias de uso entre la herencia y la composici\u00f3n en algunas de las etapas del desarrollo software y en otros aspectos de inter\u00e9s: por Sergio Mart\u00ednez Rodr\u00edguez, Herencia vs Composici\u00f3n \u00bfTienes claro cu\u00e1l es el rival m\u00e1s d\u00e9bil?","title":"Herencia vs composici\u00f3n"},{"location":"oop-p1/#ejercicios-propuestos","text":"","title":"Ejercicios propuestos"},{"location":"oop-p1/#ejercicio-1","text":"Dado los siguientes fragmentos de c\u00f3digo responder a las siguientes preguntas:","title":"Ejercicio 1"},{"location":"oop-p1/#elementssetjava","text":"public class ElementsSet < E > extends HashSet < E > { //Number of attempted elements insertions using the \"add\" method private int numberOfAddedElements = 0 ; public ElementsSet () {} @Override public boolean add ( E element ) { numberOfAddedElements ++ ; //Counting the element added return super . add ( element ); } @Override public boolean addAll ( Collection <? extends E > elements ) { numberOfAddedElements += elements . size (); //Counting the elements added return super . addAll ( elements ); } public int getNumberOfAddedElements () { return numberOfAddedElements ; } }","title":"ElementsSet.java"},{"location":"oop-p1/#mainjava","text":"... ElementsSet < String > set = new ElementsSet < String > (); set . addAll ( Arrays . asList ( \"One\" , \"Two\" , \"Three\" )); System . out . println ( set . getNumberOfAddedElements ()); ...","title":"Main.java"},{"location":"oop-p1/#preguntas-propuestas","text":"a) \u00bfEs el uso de herencia adecuado para la implementaci\u00f3n de la clase \"ElementsSet\"?, \u00bfqu\u00e9 salida muestra la funci\u00f3n \"System.out.println\" al invocar el m\u00e9todo \"getNumberOfAddedElements\", 3 o 6?. b) En el caso de que haya alg\u00fan problema en la implementaci\u00f3n anterior, proponga una soluci\u00f3n alternativa usando composici\u00f3n que resuelva el problema.","title":"Preguntas propuestas"},{"location":"oop-p1/#ejercicio-2","text":"Dado los siguientes fragmentos de c\u00f3digo responder a las siguientes preguntas:","title":"Ejercicio 2"},{"location":"oop-p1/#animaljava","text":"public abstract class Animal { //Number of legs the animal holds protected int numberOfLegs = 0 ; public abstract String speak (); public abstract boolean eat ( String typeOfFeed ); public abstract int getNumberOfLegs (); }","title":"Animal.java"},{"location":"oop-p1/#catjava","text":"public class Cat extends Animal { @Override public String speak () { return \"Meow\" ; } @Override public boolean eat ( String typeOfFeed ) { if ( typeOfFeed . equals ( \"fish\" )) { return true ; } else { return false ; } } @Override public int getNumberOfLegs () { return super . numberOfLegs ; } }","title":"Cat.java"},{"location":"oop-p1/#dogjava","text":"public class Dog extends Animal { @Override public String speak () { return \"Woof\" ; } @Override public boolean eat ( String typeOfFeed ) { if ( typeOfFeed . equals ( \"meat\" )) { return true ; } else { return false ; } } @Override public int getNumberOfLegs () { return super . numberOfLegs ; } }","title":"Dog.java"},{"location":"oop-p1/#mainjava_1","text":"... Animal cat = new Cat (); Animal dog = new Dog (); System . out . println ( cat . speak ()); System . out . println ( dog . speak ()); ...","title":"Main.java"},{"location":"oop-p1/#preguntas-propuestas_1","text":"a) \u00bfEs correcto el uso de herencia en la implementaci\u00f3n de las clases \"Cat\" y \"Dog\"?. \u00bfQu\u00e9 beneficios se obtiene?. b) En el caso de que no sea correcto, proponga una soluci\u00f3n alternativa. \u00bfCu\u00e1les son los beneficios de la soluci\u00f3n propuesta frente a la original?.","title":"Preguntas propuestas"},{"location":"oop-p1/#referencias","text":"[1] Blog Herencia vs Composici\u00f3n \u00bfTienes claro cu\u00e1l es el rival m\u00e1s d\u00e9bil?. [2] Libro Effective Java: A programming Language Guide.","title":"Referencias"},{"location":"oop-p2/","text":"Pr\u00e1ctica 2: Refactoring Repaso de conceptos te\u00f3ricos \u00b6 Refactoring \u00b6 Definici\u00f3n \u00b6 El proceso de refactoring es un proceso sistem\u00e1tico, en el cual se pretende cambiar la estructura del software implementado para hacerlo m\u00e1s f\u00e1cil de entender y m\u00e1s r\u00e1pido de modificar sin cambiar su comportamiento. Es decir, en este proceso se pretende mejorar la calidad del c\u00f3digo fuente sin crear nueva funcionalidad. Refactoring is a controlled technique for improving the design of an existing code base. Its essence is applying a series of small behavior-preserving transformations, each of which \"too small to be worth doing\". However the cumulative effect of each of these transformations is quite significant. By doing them in small steps you reduce the risk of introducing errors. You also avoid having the system broken while you are carrying out the restructuring \u2014 which allows you to gradually refactor a system over an extended period of time. -- Martin Fowler Por lo tanto, en el proceso de refactorizaci\u00f3n se deben realizar peque\u00f1as modificaciones, las cuales sean manejables y vayan incrementando gradualmente la limpieza de c\u00f3digo mientras se mantiene la funcionalidad del mismo. Conforme se realizan estos cambios, se comienza a transformar el c\u00f3digo inicial en un c\u00f3digo m\u00e1s simple, m\u00e1s f\u00e1cil de leer y m\u00e1s mantenible. No es una simple refactorizaci\u00f3n lo que realiza el cambio, si no el efecto acumulativo de muchos peque\u00f1os \"refactorings\" realizados hac\u00eda un s\u00f3lo objetivo. por Justin Albano, What Is Refactoring? Razones para refactorizar \u00b6 A continuaci\u00f3n, seg\u00fan [1] se listan las posibles razones que promueven la refactorizaci\u00f3n del c\u00f3digo: C\u00f3digo duplicado. Una funci\u00f3n es demasiado larga. Un bucle es demasiado largo o est\u00e1 demasiado anidado (demasiada complejidad). Una clase tiene poca cohesi\u00f3n. Una interfaz no proporciona un nivel consistente de abstracci\u00f3n. Una lista de par\u00e1metros tiene demasiados par\u00e1metros. Los cambios dentro de una clase tienden a afectar a otras clases. Las jerarqu\u00edas de herencia tienen que ser modificadas en paralelo (afecta a todas las subclases un mismo cambio). Los atributos que se utilizan por varias clases no est\u00e1n organizados en una clase (se repiten). Una funci\u00f3n utiliza m\u00e1s caracter\u00edsticas propuestas por otra clase que de su propia clase. Un tipo de datos primitivo esta sobrecargado. Una clase no tiene una finalidad clara (no aporta mucho). Un objeto intermediario no hace nada. Una funci\u00f3n tiene un nombre que no especifica de forma clara su objetivo. Los atributos de una clase son p\u00fablicos. Una subclase s\u00f3lo utiliza un porcentaje m\u00ednimo de las funciones que hereda. Se utilizan comentarios para explicar c\u00f3digo d\u00edficil de entender. Se usan variables globales. Una funci\u00f3n contiene c\u00f3digo que parece que ser\u00e1 necesario alg\u00fan d\u00eda pero en la actualidad no se utiliza. Resumen de posibles refactorizaciones \u00b6 Finalmente, a continuaci\u00f3n se incluye algunas de las posibles refactorizaciones propuestas en [1] . La aplicaci\u00f3n de estas t\u00e9cnicas de refactorizaci\u00f3n depender\u00e1 de si en el softare implementado se encuentran alguno/s de los problemas incluidos en la lista anterior: Refactorizaci\u00f3n en el uso de datos \u00b6 Reemplazar un n\u00famero utilizado directamente por una constante. Renombrar una variable para darle un nombre m\u00e1s claro o explicativo. Convertir una variable que se usa en m\u00faltiples sitios en m\u00faltiples variables de \u00fanico uso. Usar una variable local para prop\u00f3sitos locales en lugar de un par\u00e1metro de una funci\u00f3n. Convertir el uso de datos primitivos en el uso de una clase. Convertir un array (de bajo nivel) en un objeto. Encapsular una colecci\u00f3n. Refactorizaci\u00f3n en la implementaci\u00f3n de sentencias/instrucciones \u00b6 Descomponer una expresi\u00f3n l\u00f3gica. Convertir una expresi\u00f3n l\u00f3gica compleja en una funci\u00f3n l\u00f3gica con un nombre correcto para su definici\u00f3n. Unificar fragmentos de c\u00f3digo duplicado en diferentes partes de una expresi\u00f3n condicional. Eliminar el uso de \"break\" o \"return\" en lugar del uso de variables de control en los bucles. Devolver lo m\u00e1s r\u00e1pido posible la soluci\u00f3n en lugar de asignar el valor a una variable dentro de instrucciones if-else. Reemplazar condicionales (especialmente las sentencias \"case\") por el uso de polimorfismo. Refactorizaci\u00f3n en la implementaci\u00f3n de funciones \u00b6 Extraer una funci\u00f3n desde c\u00f3digo que se repite en varios lugares. Convertir una funci\u00f3n demasiado larga en una clase. Sustituir un algoritmo complejo por uno simple. Combinar funciones similares en una \u00fanica. Pasar el objeto completo en lugar de seleccionar algunos campos espec\u00edficos (en el caso de que sean muchos). Pasar algunos campos espec\u00edficos en lugar del objeto completo (en el caso de que sean pocos campos los utilizados). Refactorizaci\u00f3n en la implementaci\u00f3n de clases/interfaces \u00b6 Extraer c\u00f3digo especializado en subclases. Combinar c\u00f3digo similar en superclases. Mover una funci\u00f3n a otra clase en la que tenga m\u00e1s coherencia. Convertir una clase demasiado larga en dos. Eliminar una clase sin utilidad. Reemplazar herencia por composici\u00f3n (en el caso de que sea necesario). Reemplazar composici\u00f3n por herencia (en el caso de que sea necesario). Unificar una superclase y una subclase si su implementaci\u00f3n es muy similar. Refactorizaci\u00f3n a nivel de sistema \u00b6 Cambiar la asociaci\u00f3n unidireccional de clases a bidireccional (en caso de que sea necesario). Cambiar la asociaci\u00f3n bidireccional de clases a unidireccional (en caso de que sea necesario). Proveer de una factoria para crear los objetos en lugar de usar un constructor simple. Reemplazar los c\u00f3digos de error con excepciones (en caso de que sea necesario). Uso de Streams + expresiones Lambda en Java \u00b6 Un stream representa una secuencia de elementos que soportan diferentes tipos de operaciones que permiten realizar c\u00e1lculos sobre ellos. Las posibles operaciones que se pueden realizar sobre un stream pueden ser intermediarias o terminales. Las operaciones intermediarias devuelven un nuevo stream permitiendo encadenar m\u00faltiples operaciones intermediarias sin usar punto y coma. Por otro lado, las operaciones terminales son nulas o devuelven un resultado de un tipo diferente, por ejemplo un tipo num\u00e9rico. por Benjamin, Java 8 Stream Tutorial En el ejemplo anterior, las operaciones filter , map y sorted son operaciones intermediarias, mientras que la operaci\u00f3n forEach es una operaci\u00f3n terminal. M\u00e1s informaci\u00f3n: https://www.oracle.com/technetwork/es/articles/java/procesamiento-streams-java-se-8-2763402-esa.html Por otro lado, se puede observar que la mayor\u00eda de las operaciones que se aplican sobre streams aceptan alg\u00fan tipo de par\u00e1metro en forma de expresi\u00f3n lambda , la cual es una interfaz funcional que especifica el comportamiento exacto de la operaci\u00f3n. Estas operaciones no pueden modificar el contenido del stream original. En el ejemplo anterior, se puede observar que ninguna de las operaciones modifica la variable myList a\u00f1adiendo o eliminando elementos, s\u00f3lo se realiza el filtrado de los elementos que no empiezan por \"c\", se transforman a may\u00fasculas, se ordenan en orden alfab\u00e9tico y se imprimen por pantalla. M\u00e1s informaci\u00f3n: https://www.oracle.com/technetwork/es/articles/java/expresiones-lambda-api-stream-java-2737544-esa.html Ejercicios propuestos \u00b6 Ejercicio 1 \u00b6 Dado los siguientes fragmentos de c\u00f3digo responder a las siguientes preguntas: GroupOfUsers.java \u00b6 public class GroupOfUsers { private static Map < String , Integer > usersWithPoints = new HashMap < String , Integer > () {{ put ( \"User1\" , 800 ); put ( \"User2\" , 550 ); put ( \"User3\" , 20 ); put ( \"User4\" , 300 ); }}; public List < String > getUsers () { List < String > users = new ArrayList < String > (); //Sorting users by points usersWithPoints . entrySet () . stream () . sorted ( Map . Entry . < String , Integer > comparingByValue (). reversed ()) . forEachOrdered ( x -> users . add ( x . getKey ())); //Capitalizing the names of the users List < String > usersCapitalized = new ArrayList < String > (); users . forEach ( x -> usersCapitalized . add ( x . toUpperCase ())); return usersCapitalized ; } } Main.java \u00b6 ... GroupOfUsers group = new GroupOfUsers (); List < String > users = group . getUsers (); System . out . println ( \"The users are: \" + users ); ... Preguntas propuestas \u00b6 En la siguiente lista se incluyen 10 posibles problemas que pueden encontrarse en el c\u00f3digo de la implementaci\u00f3n anterior: C\u00f3digo duplicado. Funciones con nombre que no especifica de forma clara su objetivo. Rutinas demasiado largas. Bucles demasiado largos o demasiado anidados. Funciones con demasiada responsabilidad (no tienen asignada una \u00fanica responsabilidad u operaci\u00f3n a resolver). Lista de par\u00e1metros con demasiados par\u00e1metros. Los cambios de una clase tienden a afectar a otras. Se utilizan comentarios para explicar c\u00f3digo d\u00edficil de entender. Se usan variables globales. Los cambios dentro de una clase tienden a afectar a otras clases. a) \u00bfExiste alg\u00fan tipo de problema en la implementaci\u00f3n anterior de los que se incluye en la lista anterior?, \u00bfes necesario aplicar refactoring en este caso?. En el caso de que existan problemas, indique cu\u00e1les son y qu\u00e9 tipos de problemas piensa que generar\u00edan en el futuro si no se aplica el refactoring ahora. b) En el caso de que la implementaci\u00f3n necesite la aplicaci\u00f3n de refactoring, realice los cambios oportunos e indique las mejoras que aporta su implementaci\u00f3n respecto a la original. Ejercicio 2 \u00b6 Dado los siguientes fragmentos de c\u00f3digo responder a las siguientes preguntas: GroupOfUsers.java \u00b6 public class GroupOfUsers { private static Map < String , Integer > usersWithPoints_Group1 = new HashMap < String , Integer > () {{ put ( \"User1\" , 800 ); put ( \"User2\" , 550 ); put ( \"User3\" , 20 ); put ( \"User4\" , 300 ); }}; private static Map < String , Integer > usersWithPoints_Group2 = new HashMap < String , Integer > () {{ put ( \"User1\" , 10 ); put ( \"User2\" , 990 ); put ( \"User3\" , 760 ); put ( \"User4\" , 230 ); }}; private static Map < String , Integer > usersWithPoints_Group3 = new HashMap < String , Integer > () {{ put ( \"User1\" , 1000 ); put ( \"User2\" , 200 ); put ( \"User3\" , 5 ); put ( \"User4\" , 780 ); }}; public List < ArrayList < String >> getUsers () { List < String > users1 = new ArrayList < String > (); List < String > users2 = new ArrayList < String > (); List < String > users3 = new ArrayList < String > (); List < ArrayList < String >> users = new ArrayList < ArrayList < String >> (); //Sorting users by points usersWithPoints_Group1 . entrySet () . stream () . sorted ( Map . Entry . < String , Integer > comparingByValue (). reversed ()) . forEachOrdered ( x -> users1 . add ( x . getKey ())); usersWithPoints_Group2 . entrySet () . stream () . sorted ( Map . Entry . < String , Integer > comparingByValue (). reversed ()) . forEachOrdered ( x -> users2 . add ( x . getKey ())); usersWithPoints_Group3 . entrySet () . stream () . sorted ( Map . Entry . < String , Integer > comparingByValue (). reversed ()) . forEachOrdered ( x -> users3 . add ( x . getKey ())); //Capitalizing the names of the users List < String > usersCapitalized1 = new ArrayList < String > (); List < String > usersCapitalized2 = new ArrayList < String > (); List < String > usersCapitalized3 = new ArrayList < String > (); users1 . forEach ( x -> usersCapitalized1 . add ( x . toUpperCase ())); users2 . forEach ( x -> usersCapitalized2 . add ( x . toUpperCase ())); users3 . forEach ( x -> usersCapitalized3 . add ( x . toUpperCase ())); //Adding users to the main list users . add (( ArrayList < String > ) usersCapitalized1 ); users . add (( ArrayList < String > ) usersCapitalized2 ); users . add (( ArrayList < String > ) usersCapitalized3 ); return users ; } } Main.java \u00b6 ... GroupOfUsers group = new GroupOfUsers (); List < ArrayList < String >> users = group . getUsers (); System . out . println ( \"The users are: \" + users ); ... Preguntas propuestas \u00b6 Responda a las siguientes cuestiones teniendo en cuenta la lista de los 10 posibles problemas incluida en el ejercicio anterior. a) El software del ejercicio anterior ha evolucionado a\u00f1adiendo nueva funcionalidad en su implementaci\u00f3n. \u00bfExiste alg\u00fan tipo de problema en esta versi\u00f3n de la implementaci\u00f3n de los que se incluyen en la lista?, \u00bfes necesario aplicar refactoring en este caso?. En el caso de que existan problemas, indique cu\u00e1les son y qu\u00e9 tipos de problemas piensa que generar\u00edan en el futuro si no se aplica el refactoring ahora. b) En el caso de que la implementaci\u00f3n necesite la aplicaci\u00f3n de refactoring, realice los cambios oportunos e indique las mejoras que aporta su implementaci\u00f3n respecto a la original. Referencias \u00b6 [1] Libro Code Complete: A Practical Handbook of Software Construction, Second Edition. [2] Blog What Is Refactoring.","title":"Pr\u00e1ctica 2"},{"location":"oop-p2/#repaso-de-conceptos-teoricos","text":"","title":"Repaso de conceptos te\u00f3ricos"},{"location":"oop-p2/#refactoring","text":"","title":"Refactoring"},{"location":"oop-p2/#definicion","text":"El proceso de refactoring es un proceso sistem\u00e1tico, en el cual se pretende cambiar la estructura del software implementado para hacerlo m\u00e1s f\u00e1cil de entender y m\u00e1s r\u00e1pido de modificar sin cambiar su comportamiento. Es decir, en este proceso se pretende mejorar la calidad del c\u00f3digo fuente sin crear nueva funcionalidad. Refactoring is a controlled technique for improving the design of an existing code base. Its essence is applying a series of small behavior-preserving transformations, each of which \"too small to be worth doing\". However the cumulative effect of each of these transformations is quite significant. By doing them in small steps you reduce the risk of introducing errors. You also avoid having the system broken while you are carrying out the restructuring \u2014 which allows you to gradually refactor a system over an extended period of time. -- Martin Fowler Por lo tanto, en el proceso de refactorizaci\u00f3n se deben realizar peque\u00f1as modificaciones, las cuales sean manejables y vayan incrementando gradualmente la limpieza de c\u00f3digo mientras se mantiene la funcionalidad del mismo. Conforme se realizan estos cambios, se comienza a transformar el c\u00f3digo inicial en un c\u00f3digo m\u00e1s simple, m\u00e1s f\u00e1cil de leer y m\u00e1s mantenible. No es una simple refactorizaci\u00f3n lo que realiza el cambio, si no el efecto acumulativo de muchos peque\u00f1os \"refactorings\" realizados hac\u00eda un s\u00f3lo objetivo. por Justin Albano, What Is Refactoring?","title":"Definici\u00f3n"},{"location":"oop-p2/#razones-para-refactorizar","text":"A continuaci\u00f3n, seg\u00fan [1] se listan las posibles razones que promueven la refactorizaci\u00f3n del c\u00f3digo: C\u00f3digo duplicado. Una funci\u00f3n es demasiado larga. Un bucle es demasiado largo o est\u00e1 demasiado anidado (demasiada complejidad). Una clase tiene poca cohesi\u00f3n. Una interfaz no proporciona un nivel consistente de abstracci\u00f3n. Una lista de par\u00e1metros tiene demasiados par\u00e1metros. Los cambios dentro de una clase tienden a afectar a otras clases. Las jerarqu\u00edas de herencia tienen que ser modificadas en paralelo (afecta a todas las subclases un mismo cambio). Los atributos que se utilizan por varias clases no est\u00e1n organizados en una clase (se repiten). Una funci\u00f3n utiliza m\u00e1s caracter\u00edsticas propuestas por otra clase que de su propia clase. Un tipo de datos primitivo esta sobrecargado. Una clase no tiene una finalidad clara (no aporta mucho). Un objeto intermediario no hace nada. Una funci\u00f3n tiene un nombre que no especifica de forma clara su objetivo. Los atributos de una clase son p\u00fablicos. Una subclase s\u00f3lo utiliza un porcentaje m\u00ednimo de las funciones que hereda. Se utilizan comentarios para explicar c\u00f3digo d\u00edficil de entender. Se usan variables globales. Una funci\u00f3n contiene c\u00f3digo que parece que ser\u00e1 necesario alg\u00fan d\u00eda pero en la actualidad no se utiliza.","title":"Razones para refactorizar"},{"location":"oop-p2/#resumen-de-posibles-refactorizaciones","text":"Finalmente, a continuaci\u00f3n se incluye algunas de las posibles refactorizaciones propuestas en [1] . La aplicaci\u00f3n de estas t\u00e9cnicas de refactorizaci\u00f3n depender\u00e1 de si en el softare implementado se encuentran alguno/s de los problemas incluidos en la lista anterior:","title":"Resumen de posibles refactorizaciones"},{"location":"oop-p2/#refactorizacion-en-el-uso-de-datos","text":"Reemplazar un n\u00famero utilizado directamente por una constante. Renombrar una variable para darle un nombre m\u00e1s claro o explicativo. Convertir una variable que se usa en m\u00faltiples sitios en m\u00faltiples variables de \u00fanico uso. Usar una variable local para prop\u00f3sitos locales en lugar de un par\u00e1metro de una funci\u00f3n. Convertir el uso de datos primitivos en el uso de una clase. Convertir un array (de bajo nivel) en un objeto. Encapsular una colecci\u00f3n.","title":"Refactorizaci\u00f3n en el uso de datos"},{"location":"oop-p2/#refactorizacion-en-la-implementacion-de-sentenciasinstrucciones","text":"Descomponer una expresi\u00f3n l\u00f3gica. Convertir una expresi\u00f3n l\u00f3gica compleja en una funci\u00f3n l\u00f3gica con un nombre correcto para su definici\u00f3n. Unificar fragmentos de c\u00f3digo duplicado en diferentes partes de una expresi\u00f3n condicional. Eliminar el uso de \"break\" o \"return\" en lugar del uso de variables de control en los bucles. Devolver lo m\u00e1s r\u00e1pido posible la soluci\u00f3n en lugar de asignar el valor a una variable dentro de instrucciones if-else. Reemplazar condicionales (especialmente las sentencias \"case\") por el uso de polimorfismo.","title":"Refactorizaci\u00f3n en la implementaci\u00f3n de sentencias/instrucciones"},{"location":"oop-p2/#refactorizacion-en-la-implementacion-de-funciones","text":"Extraer una funci\u00f3n desde c\u00f3digo que se repite en varios lugares. Convertir una funci\u00f3n demasiado larga en una clase. Sustituir un algoritmo complejo por uno simple. Combinar funciones similares en una \u00fanica. Pasar el objeto completo en lugar de seleccionar algunos campos espec\u00edficos (en el caso de que sean muchos). Pasar algunos campos espec\u00edficos en lugar del objeto completo (en el caso de que sean pocos campos los utilizados).","title":"Refactorizaci\u00f3n en la implementaci\u00f3n de funciones"},{"location":"oop-p2/#refactorizacion-en-la-implementacion-de-clasesinterfaces","text":"Extraer c\u00f3digo especializado en subclases. Combinar c\u00f3digo similar en superclases. Mover una funci\u00f3n a otra clase en la que tenga m\u00e1s coherencia. Convertir una clase demasiado larga en dos. Eliminar una clase sin utilidad. Reemplazar herencia por composici\u00f3n (en el caso de que sea necesario). Reemplazar composici\u00f3n por herencia (en el caso de que sea necesario). Unificar una superclase y una subclase si su implementaci\u00f3n es muy similar.","title":"Refactorizaci\u00f3n en la implementaci\u00f3n de clases/interfaces"},{"location":"oop-p2/#refactorizacion-a-nivel-de-sistema","text":"Cambiar la asociaci\u00f3n unidireccional de clases a bidireccional (en caso de que sea necesario). Cambiar la asociaci\u00f3n bidireccional de clases a unidireccional (en caso de que sea necesario). Proveer de una factoria para crear los objetos en lugar de usar un constructor simple. Reemplazar los c\u00f3digos de error con excepciones (en caso de que sea necesario).","title":"Refactorizaci\u00f3n a nivel de sistema"},{"location":"oop-p2/#uso-de-streams-expresiones-lambda-en-java","text":"Un stream representa una secuencia de elementos que soportan diferentes tipos de operaciones que permiten realizar c\u00e1lculos sobre ellos. Las posibles operaciones que se pueden realizar sobre un stream pueden ser intermediarias o terminales. Las operaciones intermediarias devuelven un nuevo stream permitiendo encadenar m\u00faltiples operaciones intermediarias sin usar punto y coma. Por otro lado, las operaciones terminales son nulas o devuelven un resultado de un tipo diferente, por ejemplo un tipo num\u00e9rico. por Benjamin, Java 8 Stream Tutorial En el ejemplo anterior, las operaciones filter , map y sorted son operaciones intermediarias, mientras que la operaci\u00f3n forEach es una operaci\u00f3n terminal. M\u00e1s informaci\u00f3n: https://www.oracle.com/technetwork/es/articles/java/procesamiento-streams-java-se-8-2763402-esa.html Por otro lado, se puede observar que la mayor\u00eda de las operaciones que se aplican sobre streams aceptan alg\u00fan tipo de par\u00e1metro en forma de expresi\u00f3n lambda , la cual es una interfaz funcional que especifica el comportamiento exacto de la operaci\u00f3n. Estas operaciones no pueden modificar el contenido del stream original. En el ejemplo anterior, se puede observar que ninguna de las operaciones modifica la variable myList a\u00f1adiendo o eliminando elementos, s\u00f3lo se realiza el filtrado de los elementos que no empiezan por \"c\", se transforman a may\u00fasculas, se ordenan en orden alfab\u00e9tico y se imprimen por pantalla. M\u00e1s informaci\u00f3n: https://www.oracle.com/technetwork/es/articles/java/expresiones-lambda-api-stream-java-2737544-esa.html","title":"Uso de Streams + expresiones Lambda en Java"},{"location":"oop-p2/#ejercicios-propuestos","text":"","title":"Ejercicios propuestos"},{"location":"oop-p2/#ejercicio-1","text":"Dado los siguientes fragmentos de c\u00f3digo responder a las siguientes preguntas:","title":"Ejercicio 1"},{"location":"oop-p2/#groupofusersjava","text":"public class GroupOfUsers { private static Map < String , Integer > usersWithPoints = new HashMap < String , Integer > () {{ put ( \"User1\" , 800 ); put ( \"User2\" , 550 ); put ( \"User3\" , 20 ); put ( \"User4\" , 300 ); }}; public List < String > getUsers () { List < String > users = new ArrayList < String > (); //Sorting users by points usersWithPoints . entrySet () . stream () . sorted ( Map . Entry . < String , Integer > comparingByValue (). reversed ()) . forEachOrdered ( x -> users . add ( x . getKey ())); //Capitalizing the names of the users List < String > usersCapitalized = new ArrayList < String > (); users . forEach ( x -> usersCapitalized . add ( x . toUpperCase ())); return usersCapitalized ; } }","title":"GroupOfUsers.java"},{"location":"oop-p2/#mainjava","text":"... GroupOfUsers group = new GroupOfUsers (); List < String > users = group . getUsers (); System . out . println ( \"The users are: \" + users ); ...","title":"Main.java"},{"location":"oop-p2/#preguntas-propuestas","text":"En la siguiente lista se incluyen 10 posibles problemas que pueden encontrarse en el c\u00f3digo de la implementaci\u00f3n anterior: C\u00f3digo duplicado. Funciones con nombre que no especifica de forma clara su objetivo. Rutinas demasiado largas. Bucles demasiado largos o demasiado anidados. Funciones con demasiada responsabilidad (no tienen asignada una \u00fanica responsabilidad u operaci\u00f3n a resolver). Lista de par\u00e1metros con demasiados par\u00e1metros. Los cambios de una clase tienden a afectar a otras. Se utilizan comentarios para explicar c\u00f3digo d\u00edficil de entender. Se usan variables globales. Los cambios dentro de una clase tienden a afectar a otras clases. a) \u00bfExiste alg\u00fan tipo de problema en la implementaci\u00f3n anterior de los que se incluye en la lista anterior?, \u00bfes necesario aplicar refactoring en este caso?. En el caso de que existan problemas, indique cu\u00e1les son y qu\u00e9 tipos de problemas piensa que generar\u00edan en el futuro si no se aplica el refactoring ahora. b) En el caso de que la implementaci\u00f3n necesite la aplicaci\u00f3n de refactoring, realice los cambios oportunos e indique las mejoras que aporta su implementaci\u00f3n respecto a la original.","title":"Preguntas propuestas"},{"location":"oop-p2/#ejercicio-2","text":"Dado los siguientes fragmentos de c\u00f3digo responder a las siguientes preguntas:","title":"Ejercicio 2"},{"location":"oop-p2/#groupofusersjava_1","text":"public class GroupOfUsers { private static Map < String , Integer > usersWithPoints_Group1 = new HashMap < String , Integer > () {{ put ( \"User1\" , 800 ); put ( \"User2\" , 550 ); put ( \"User3\" , 20 ); put ( \"User4\" , 300 ); }}; private static Map < String , Integer > usersWithPoints_Group2 = new HashMap < String , Integer > () {{ put ( \"User1\" , 10 ); put ( \"User2\" , 990 ); put ( \"User3\" , 760 ); put ( \"User4\" , 230 ); }}; private static Map < String , Integer > usersWithPoints_Group3 = new HashMap < String , Integer > () {{ put ( \"User1\" , 1000 ); put ( \"User2\" , 200 ); put ( \"User3\" , 5 ); put ( \"User4\" , 780 ); }}; public List < ArrayList < String >> getUsers () { List < String > users1 = new ArrayList < String > (); List < String > users2 = new ArrayList < String > (); List < String > users3 = new ArrayList < String > (); List < ArrayList < String >> users = new ArrayList < ArrayList < String >> (); //Sorting users by points usersWithPoints_Group1 . entrySet () . stream () . sorted ( Map . Entry . < String , Integer > comparingByValue (). reversed ()) . forEachOrdered ( x -> users1 . add ( x . getKey ())); usersWithPoints_Group2 . entrySet () . stream () . sorted ( Map . Entry . < String , Integer > comparingByValue (). reversed ()) . forEachOrdered ( x -> users2 . add ( x . getKey ())); usersWithPoints_Group3 . entrySet () . stream () . sorted ( Map . Entry . < String , Integer > comparingByValue (). reversed ()) . forEachOrdered ( x -> users3 . add ( x . getKey ())); //Capitalizing the names of the users List < String > usersCapitalized1 = new ArrayList < String > (); List < String > usersCapitalized2 = new ArrayList < String > (); List < String > usersCapitalized3 = new ArrayList < String > (); users1 . forEach ( x -> usersCapitalized1 . add ( x . toUpperCase ())); users2 . forEach ( x -> usersCapitalized2 . add ( x . toUpperCase ())); users3 . forEach ( x -> usersCapitalized3 . add ( x . toUpperCase ())); //Adding users to the main list users . add (( ArrayList < String > ) usersCapitalized1 ); users . add (( ArrayList < String > ) usersCapitalized2 ); users . add (( ArrayList < String > ) usersCapitalized3 ); return users ; } }","title":"GroupOfUsers.java"},{"location":"oop-p2/#mainjava_1","text":"... GroupOfUsers group = new GroupOfUsers (); List < ArrayList < String >> users = group . getUsers (); System . out . println ( \"The users are: \" + users ); ...","title":"Main.java"},{"location":"oop-p2/#preguntas-propuestas_1","text":"Responda a las siguientes cuestiones teniendo en cuenta la lista de los 10 posibles problemas incluida en el ejercicio anterior. a) El software del ejercicio anterior ha evolucionado a\u00f1adiendo nueva funcionalidad en su implementaci\u00f3n. \u00bfExiste alg\u00fan tipo de problema en esta versi\u00f3n de la implementaci\u00f3n de los que se incluyen en la lista?, \u00bfes necesario aplicar refactoring en este caso?. En el caso de que existan problemas, indique cu\u00e1les son y qu\u00e9 tipos de problemas piensa que generar\u00edan en el futuro si no se aplica el refactoring ahora. b) En el caso de que la implementaci\u00f3n necesite la aplicaci\u00f3n de refactoring, realice los cambios oportunos e indique las mejoras que aporta su implementaci\u00f3n respecto a la original.","title":"Preguntas propuestas"},{"location":"oop-p2/#referencias","text":"[1] Libro Code Complete: A Practical Handbook of Software Construction, Second Edition. [2] Blog What Is Refactoring.","title":"Referencias"},{"location":"oop-p3/","text":"Pr\u00e1ctica 3: Inyecci\u00f3n de dependencias & Programaci\u00f3n orientada a aspectos Repaso de conceptos te\u00f3ricos \u00b6 Las dos t\u00e9cnicas siguientes, la inyecci\u00f3n de dependencias y la programaci\u00f3n de aspectos, nos permiten implementar el principio de ortogonalidad entre componentes software. Inyecci\u00f3n de dependencias \u00b6 La inyecci\u00f3n de dependencias es una t\u00e9cnica utilizada para implementar la inversi\u00f3n de control (IC, se invierte el flujo tradicional del programa). Por este motivo, permite la creaci\u00f3n de objetos fuera de una clase y proporciona esos objetos a otra clase dependiente de ellos de diferentes formas. Utilizando la IC, se traslada la creaci\u00f3n y uni\u00f3n de los objetos fuera de la clase que depende de ellos. por TutorialsTeacher, Dependency Injection A continuaci\u00f3n, se describen los tipos de inyecci\u00f3n de dependencias existentes: Inyecci\u00f3n a trav\u00e9s del constructor : En este tipo de inyecci\u00f3n la clase inyectora suministra la dependencia (servicio) a trav\u00e9s del constructor de la clase dependente (cliente). Inyecci\u00f3n a trav\u00e9s de propiedades : En este tipo de inyecci\u00f3n la clase inyectora suministra la dependenca (servicio) a trav\u00e9s de un m\u00e9todo \"set\" de la clase dependiente (cliente). Inyecci\u00f3n a trav\u00e9s de m\u00e9todos : En este tipo de inyecci\u00f3n la clase inyectora suministra la dependencia (servicio) a trav\u00e9s de un API establecido por la clase dependiente en el que se especifican el/los m\u00e9todo/s para suministrar la dependencia (cliente). A continuaci\u00f3n, se listan algunos de los frameworks utilizados para facilitar la implementaci\u00f3n de inyecci\u00f3n de dependencias en Java: Google guice: https://github.com/google/guice/wiki/GettingStarted . Spring Framework: https://www.vogella.com/tutorials/SpringDependencyInjection/article.html . Eclipse RCP: https://wiki.eclipse.org/Eclipse4/RCP/Dependency_Injection . Programaci\u00f3n orientada a aspectos \u00b6 Los aspectos nos permiten agrupar c\u00f3digo que se ejecutar\u00e1 en varios lugares en un m\u00f3dulo independiente. Adem\u00e1s, este c\u00f3digo ser\u00e1 inyectado en tiempo de ejecuci\u00f3n o compilaci\u00f3n (dependiendo del framework) en los puntos de corte especificados en el c\u00f3digo fuente. En este caso, la programaci\u00f3n orientada a aspectos (AOP) permite introducir nueva funcionalidad dentro de una clase, sin que \u00e9sta deba tener conocimiento de su existencia. Aspect-oriented programming (AOP) complements object-oriented programming by allowing the developer to dynamically modify the static object-oriented model to create a system that can grow to meet new requirements, allowing an application to adopt new characteristics as it develops. -- Vangie Beal AspectJ, framework para facilitar la implementaci\u00f3n de inyecci\u00f3n de dependencias en Java: Documentaci\u00f3n oficial de AspectJ: https://www.eclipse.org/aspectj/docs.php AspectJ Hello World: https://www.baeldung.com/aspectj Cheat sheet para la definici\u00f3n de etiquetas en AspectJ: https://blog.espenberntsen.net/2010/03/20/aspectj-cheat-sheet/ Ejemplo de configuraci\u00f3n de la etiqueta Before en AspectJ: https://howtodoinjava.com/spring-aop/aspectj-before-annotation-example/ Ejemplo de configuraci\u00f3n de la etiqueta After en AspectJ: https://howtodoinjava.com/spring-aop/aspectj-after-annotation-example/ Ejercicios propuestos \u00b6 Ejercicio 1 \u00b6 Dado los siguientes fragmentos de c\u00f3digo responder a las siguientes preguntas: DBAccess.java \u00b6 public interface DBAccess { public void initConnection (); } DBAccessA.java \u00b6 public class DBAccessA implements DBAccess { public DBAccessA () {} public void initConnection () { System . out . println ( \"Init A connection with database..\" ); } } DBAccessB.java \u00b6 public class DBAccessB implements DBAccess { public DBAccessB () {} public void initConnection () { System . out . println ( \"Init B connection with database..\" ); } } DBClient.java \u00b6 public class DBClient { private DBAccess dbAccess ; public DBClient ( DBAccess dbAccess ) { this . dbAccess = dbAccess ; } public void setDBAccess ( DBAccess dbAccess ) { this . dbAccess = dbAccess ; } public void getAllFromDataBase () { dbAccess . initConnection (); System . out . println ( \"Returning all data from database..\" ); } public void getSomeDataFromDataBase () { dbAccess . initConnection (); System . out . println ( \"Returning some data from database..\" ); } } Main.java \u00b6 public class Main { public static void main ( String args [] ) { DBAccess dbAccessB = new DBAccessB (); DBClient client = new DBClient ( dbAccessB ); System . out . println ( \"Querying all data from database..\" ); client . getAllFromDataBase (); DBAccess dbAccessA = new DBAccessA (); client . setDBAccess ( dbAccessA ); System . out . println ( \"Querying some data from database..\" ); client . getSomeDataFromDataBase (); } } Preguntas propuestas \u00b6 a) \u00bfSe realiza inyecci\u00f3n de dependencias entre las clases anteriores?, si es as\u00ed identifique la clase inyectora, el servicio y el cliente. b) En el caso de que exista inyecci\u00f3n de dependencias adem\u00e1s indique: El m\u00e9todo de inyecci\u00f3n que se realiza (constructor, propiedad o m\u00e9todo). La/s l\u00ednea/s donde se realiza la inyecci\u00f3n de dependencias. Ejercicio 2 \u00b6 Dado los siguientes fragmentos de c\u00f3digo responder a las siguientes preguntas: Bank.java \u00b6 public class Bank { public Bank () {} public void createUser () { System . out . println ( \"Creating user..\" ); } public void makeTransaction () { System . out . println ( \"Making transaction..\" ); } public void takeMoneyOut () { System . out . println ( \"Taking money out..\" ); } public void showUsers () { System . out . println ( \"Showing users..\" ); } } Main.java \u00b6 public class Main { private static Scanner input = new Scanner ( System . in ); public static void main ( String args [] ) { System . out . println ( \"AspectJ Bank\" ); System . out . println ( \"------------\" ); System . out . println ( \"1 - Create user\" ); System . out . println ( \"2 - Make transaction\" ); System . out . println ( \"3 - Take money out\" ); System . out . println ( \"4 - Show users\" ); System . out . println ( \"5 - Exit\" ); int option = Integer . valueOf ( input . nextLine ()); Bank bank = new Bank (); switch ( option ) { case 1 : bank . createUser (); break ; case 2 : bank . makeTransaction (); break ; case 3 : bank . takeMoneyOut (); break ; case 4 : bank . showUsers (); break ; case 5 : System . out . println ( \"Exiting..\" ); break ; } } } LoginAspect.java \u00b6 import org.aspectj.lang.JoinPoint ; import org.aspectj.lang.annotation.After ; import org.aspectj.lang.annotation.Aspect ; import org.aspectj.lang.annotation.Before ; @Aspect public class LoginAspect { @Before ( \"..TO-DO..\" ) public void before ( JoinPoint joinPoint ){ //...TO-DO.. } @After ( \"..TO-DO..\" ) public void after ( JoinPoint joinPoint ){ //...TO-DO.. } } Preguntas propuestas \u00b6 En primer lugar, se tiene que configurar el entorno para realizar el ejercicio: Instalar Eclipse IDE for Java Developers : https://www.eclipse.org/downloads/packages/release/2020-03/r/eclipse-ide-java-developers . Instalar el plug-in de Eclipse para trabajar con AspectJ : Dentro de Eclipse seleccionar Help > Eclipse Marketplace > Buscar AspectJ Development Tools y hacer click en \"Install\". Descargar la plantilla del proyecto : https://drive.google.com/file/d/1_L9cj0BTcqHZEnJK7aPZXplZiDaH9Ow3/view?usp=sharing . Importar el proyecto en Eclipse : Descomprimir el zip descargado en el paso anterior (P3Ejercicio2_template.zip). Posteriormente, en Eclipse seleccionar File > Import > Projects from Folder or Archive > Click en \"Directory\" y seleccionar la ruta de la carpeta descomprimida > Click en \"Finish\". Posteriormente, complete en la clase \"LoginAspect.java\" las secciones \"TO-DO\" de forma que se cumplan las siguientes condiciones: a) Mostrar el mensaje \"The login is required\" antes de la ejecuci\u00f3n de las operaciones \"makeTransaction\" y \"takeMoneyOut\". b) Mostrar el mensaje \"The database is empty\" despu\u00e9s de la ejecuci\u00f3n de la operaci\u00f3n \"showUsers\". Finalmente, sustituya el fichero \"LoginAspect.java\" por el fichero \"LoginAspect.aj\" incluyendo la misma funcionalidad utilizando la sintaxis de AspectJ. Referencias \u00b6 [1] Blog Dependecy Injection. [2] Google Guice Framework. [3] Spring Framework. [4] Eclipse RCP. [5] Blog Aspect-Oriented Programming. [6] AspectJ Documentaci\u00f3n Oficial. [7] Blog Intro to AspectJ. [8] Blog Java and Spring Development. [9] Blog AspectJ Before Annotation. [10] Blog AspectJ After Annotation.","title":"Pr\u00e1ctica 3"},{"location":"oop-p3/#repaso-de-conceptos-teoricos","text":"Las dos t\u00e9cnicas siguientes, la inyecci\u00f3n de dependencias y la programaci\u00f3n de aspectos, nos permiten implementar el principio de ortogonalidad entre componentes software.","title":"Repaso de conceptos te\u00f3ricos"},{"location":"oop-p3/#inyeccion-de-dependencias","text":"La inyecci\u00f3n de dependencias es una t\u00e9cnica utilizada para implementar la inversi\u00f3n de control (IC, se invierte el flujo tradicional del programa). Por este motivo, permite la creaci\u00f3n de objetos fuera de una clase y proporciona esos objetos a otra clase dependiente de ellos de diferentes formas. Utilizando la IC, se traslada la creaci\u00f3n y uni\u00f3n de los objetos fuera de la clase que depende de ellos. por TutorialsTeacher, Dependency Injection A continuaci\u00f3n, se describen los tipos de inyecci\u00f3n de dependencias existentes: Inyecci\u00f3n a trav\u00e9s del constructor : En este tipo de inyecci\u00f3n la clase inyectora suministra la dependencia (servicio) a trav\u00e9s del constructor de la clase dependente (cliente). Inyecci\u00f3n a trav\u00e9s de propiedades : En este tipo de inyecci\u00f3n la clase inyectora suministra la dependenca (servicio) a trav\u00e9s de un m\u00e9todo \"set\" de la clase dependiente (cliente). Inyecci\u00f3n a trav\u00e9s de m\u00e9todos : En este tipo de inyecci\u00f3n la clase inyectora suministra la dependencia (servicio) a trav\u00e9s de un API establecido por la clase dependiente en el que se especifican el/los m\u00e9todo/s para suministrar la dependencia (cliente). A continuaci\u00f3n, se listan algunos de los frameworks utilizados para facilitar la implementaci\u00f3n de inyecci\u00f3n de dependencias en Java: Google guice: https://github.com/google/guice/wiki/GettingStarted . Spring Framework: https://www.vogella.com/tutorials/SpringDependencyInjection/article.html . Eclipse RCP: https://wiki.eclipse.org/Eclipse4/RCP/Dependency_Injection .","title":"Inyecci\u00f3n de dependencias"},{"location":"oop-p3/#programacion-orientada-a-aspectos","text":"Los aspectos nos permiten agrupar c\u00f3digo que se ejecutar\u00e1 en varios lugares en un m\u00f3dulo independiente. Adem\u00e1s, este c\u00f3digo ser\u00e1 inyectado en tiempo de ejecuci\u00f3n o compilaci\u00f3n (dependiendo del framework) en los puntos de corte especificados en el c\u00f3digo fuente. En este caso, la programaci\u00f3n orientada a aspectos (AOP) permite introducir nueva funcionalidad dentro de una clase, sin que \u00e9sta deba tener conocimiento de su existencia. Aspect-oriented programming (AOP) complements object-oriented programming by allowing the developer to dynamically modify the static object-oriented model to create a system that can grow to meet new requirements, allowing an application to adopt new characteristics as it develops. -- Vangie Beal AspectJ, framework para facilitar la implementaci\u00f3n de inyecci\u00f3n de dependencias en Java: Documentaci\u00f3n oficial de AspectJ: https://www.eclipse.org/aspectj/docs.php AspectJ Hello World: https://www.baeldung.com/aspectj Cheat sheet para la definici\u00f3n de etiquetas en AspectJ: https://blog.espenberntsen.net/2010/03/20/aspectj-cheat-sheet/ Ejemplo de configuraci\u00f3n de la etiqueta Before en AspectJ: https://howtodoinjava.com/spring-aop/aspectj-before-annotation-example/ Ejemplo de configuraci\u00f3n de la etiqueta After en AspectJ: https://howtodoinjava.com/spring-aop/aspectj-after-annotation-example/","title":"Programaci\u00f3n orientada a aspectos"},{"location":"oop-p3/#ejercicios-propuestos","text":"","title":"Ejercicios propuestos"},{"location":"oop-p3/#ejercicio-1","text":"Dado los siguientes fragmentos de c\u00f3digo responder a las siguientes preguntas:","title":"Ejercicio 1"},{"location":"oop-p3/#dbaccessjava","text":"public interface DBAccess { public void initConnection (); }","title":"DBAccess.java"},{"location":"oop-p3/#dbaccessajava","text":"public class DBAccessA implements DBAccess { public DBAccessA () {} public void initConnection () { System . out . println ( \"Init A connection with database..\" ); } }","title":"DBAccessA.java"},{"location":"oop-p3/#dbaccessbjava","text":"public class DBAccessB implements DBAccess { public DBAccessB () {} public void initConnection () { System . out . println ( \"Init B connection with database..\" ); } }","title":"DBAccessB.java"},{"location":"oop-p3/#dbclientjava","text":"public class DBClient { private DBAccess dbAccess ; public DBClient ( DBAccess dbAccess ) { this . dbAccess = dbAccess ; } public void setDBAccess ( DBAccess dbAccess ) { this . dbAccess = dbAccess ; } public void getAllFromDataBase () { dbAccess . initConnection (); System . out . println ( \"Returning all data from database..\" ); } public void getSomeDataFromDataBase () { dbAccess . initConnection (); System . out . println ( \"Returning some data from database..\" ); } }","title":"DBClient.java"},{"location":"oop-p3/#mainjava","text":"public class Main { public static void main ( String args [] ) { DBAccess dbAccessB = new DBAccessB (); DBClient client = new DBClient ( dbAccessB ); System . out . println ( \"Querying all data from database..\" ); client . getAllFromDataBase (); DBAccess dbAccessA = new DBAccessA (); client . setDBAccess ( dbAccessA ); System . out . println ( \"Querying some data from database..\" ); client . getSomeDataFromDataBase (); } }","title":"Main.java"},{"location":"oop-p3/#preguntas-propuestas","text":"a) \u00bfSe realiza inyecci\u00f3n de dependencias entre las clases anteriores?, si es as\u00ed identifique la clase inyectora, el servicio y el cliente. b) En el caso de que exista inyecci\u00f3n de dependencias adem\u00e1s indique: El m\u00e9todo de inyecci\u00f3n que se realiza (constructor, propiedad o m\u00e9todo). La/s l\u00ednea/s donde se realiza la inyecci\u00f3n de dependencias.","title":"Preguntas propuestas"},{"location":"oop-p3/#ejercicio-2","text":"Dado los siguientes fragmentos de c\u00f3digo responder a las siguientes preguntas:","title":"Ejercicio 2"},{"location":"oop-p3/#bankjava","text":"public class Bank { public Bank () {} public void createUser () { System . out . println ( \"Creating user..\" ); } public void makeTransaction () { System . out . println ( \"Making transaction..\" ); } public void takeMoneyOut () { System . out . println ( \"Taking money out..\" ); } public void showUsers () { System . out . println ( \"Showing users..\" ); } }","title":"Bank.java"},{"location":"oop-p3/#mainjava_1","text":"public class Main { private static Scanner input = new Scanner ( System . in ); public static void main ( String args [] ) { System . out . println ( \"AspectJ Bank\" ); System . out . println ( \"------------\" ); System . out . println ( \"1 - Create user\" ); System . out . println ( \"2 - Make transaction\" ); System . out . println ( \"3 - Take money out\" ); System . out . println ( \"4 - Show users\" ); System . out . println ( \"5 - Exit\" ); int option = Integer . valueOf ( input . nextLine ()); Bank bank = new Bank (); switch ( option ) { case 1 : bank . createUser (); break ; case 2 : bank . makeTransaction (); break ; case 3 : bank . takeMoneyOut (); break ; case 4 : bank . showUsers (); break ; case 5 : System . out . println ( \"Exiting..\" ); break ; } } }","title":"Main.java"},{"location":"oop-p3/#loginaspectjava","text":"import org.aspectj.lang.JoinPoint ; import org.aspectj.lang.annotation.After ; import org.aspectj.lang.annotation.Aspect ; import org.aspectj.lang.annotation.Before ; @Aspect public class LoginAspect { @Before ( \"..TO-DO..\" ) public void before ( JoinPoint joinPoint ){ //...TO-DO.. } @After ( \"..TO-DO..\" ) public void after ( JoinPoint joinPoint ){ //...TO-DO.. } }","title":"LoginAspect.java"},{"location":"oop-p3/#preguntas-propuestas_1","text":"En primer lugar, se tiene que configurar el entorno para realizar el ejercicio: Instalar Eclipse IDE for Java Developers : https://www.eclipse.org/downloads/packages/release/2020-03/r/eclipse-ide-java-developers . Instalar el plug-in de Eclipse para trabajar con AspectJ : Dentro de Eclipse seleccionar Help > Eclipse Marketplace > Buscar AspectJ Development Tools y hacer click en \"Install\". Descargar la plantilla del proyecto : https://drive.google.com/file/d/1_L9cj0BTcqHZEnJK7aPZXplZiDaH9Ow3/view?usp=sharing . Importar el proyecto en Eclipse : Descomprimir el zip descargado en el paso anterior (P3Ejercicio2_template.zip). Posteriormente, en Eclipse seleccionar File > Import > Projects from Folder or Archive > Click en \"Directory\" y seleccionar la ruta de la carpeta descomprimida > Click en \"Finish\". Posteriormente, complete en la clase \"LoginAspect.java\" las secciones \"TO-DO\" de forma que se cumplan las siguientes condiciones: a) Mostrar el mensaje \"The login is required\" antes de la ejecuci\u00f3n de las operaciones \"makeTransaction\" y \"takeMoneyOut\". b) Mostrar el mensaje \"The database is empty\" despu\u00e9s de la ejecuci\u00f3n de la operaci\u00f3n \"showUsers\". Finalmente, sustituya el fichero \"LoginAspect.java\" por el fichero \"LoginAspect.aj\" incluyendo la misma funcionalidad utilizando la sintaxis de AspectJ.","title":"Preguntas propuestas"},{"location":"oop-p3/#referencias","text":"[1] Blog Dependecy Injection. [2] Google Guice Framework. [3] Spring Framework. [4] Eclipse RCP. [5] Blog Aspect-Oriented Programming. [6] AspectJ Documentaci\u00f3n Oficial. [7] Blog Intro to AspectJ. [8] Blog Java and Spring Development. [9] Blog AspectJ Before Annotation. [10] Blog AspectJ After Annotation.","title":"Referencias"},{"location":"oop-p4/","text":"Pr\u00e1ctica 4: Aserciones & Uso de Null & Optional Repaso de conceptos te\u00f3ricos \u00b6 Aserciones \u00b6 Las aserciones son un m\u00e9todo para aumentar la fiabilidad del c\u00f3digo que se esta implementando. Las aserciones son expresiones que representan una condici\u00f3n que debe cumplirse en una parte espec\u00edfica del c\u00f3digo. Si una aserci\u00f3n no se cumple, el programa generar\u00e1 un error en ese punto. An assertion is a statement in the Java programming language that enables you to test your assumptions about your program. For example, if you write a method that calculates the speed of a particle, you might assert that the calculated speed is less than the speed of light. Each assertion contains a boolean expression that you believe will be true when the assertion executes. If it is not true, the system will throw an error. By verifying that the boolean expression is indeed true, the assertion confirms your assumptions about the behavior of your program, increasing your confidence that the program is free of errors. Experience has shown that writing assertions while programming is one of the quickest and most effective ways to detect and correct bugs. As an added benefit, assertions serve to document the inner workings of your program, enhancing maintainability. -- Documentaci\u00f3n oficial de Java. A continuaci\u00f3n, se muestra un ejemplo de una aserci\u00f3n implementada en Java: assert price > 0 ; En este caso, la aserci\u00f3n comprueba que el valor del atributo price debe ser siempre mayor que 0, en el caso de que el valor sea 0 o inferior la aserci\u00f3n no se cumplir\u00e1. Esto permite comprobar que el programa esta realizando un funcionamiento correcto en este sentido. Como se ha comentado anteriormente, si la condici\u00f3n que sigue al keyword assert no se cumple el programa lanzar\u00e1 una excepci\u00f3n de tipo \"AssertionError\". Para que el mensaje de error asociado sea m\u00e1s descriptivo se puede especificar su contenido como se muestra a continuaci\u00f3n: assert price > 0 : \"El precio es menor que 0.\" ; Estas excepciones pueden ser capturadas, o en caso contrario el int\u00e9rprete de Java se encargar\u00e1 de ellas y mostrar\u00e1 la excepci\u00f3n por consola. A continuaci\u00f3n, se muestra un ejemplo del error generado cuando una aserci\u00f3n no se cumple: Exception in thread \u201c main \u201d java . lang . AssertionError at AssertTest . main ( AssertTest . java : 14 ) En el ejemplo anterior se muestra un error generado donde no se ha especificado ning\u00fan mensaje para que sea m\u00e1s descriptivo. A continuaci\u00f3n, se muestra un error donde se ha especificado el mensaje: Exception in thread \u201c main \u201d java . lang . AssertionError : El precio es menor que 0. at AssertTest . main ( AssertTest . java : 14 ) Como se puede comprobar, la incorporaci\u00f3n de mensajes aclaratorios es una buena pr\u00e1ctica, ya que en el primer caso es d\u00edficil conocer el motivo de error del programa, a no ser que se visualice el contenido de la l\u00ednea 14 del fichero \"AssertTest.java\". Configuraci\u00f3n de Eclipse para usar aserciones \u00b6 Aunque las aserciones sean parte oficial del lenguaje Java, se debe configurar la ejecuci\u00f3n del programa para que se muestren los errores asociados a \u00e9stas. En Eclipse se puede realizar esta opci\u00f3n haciendo click derecho sobre el proyecto: \"Run as\" > \"Run configurations\" > Click derecho sobre \"Java application\" > \"New Configuration\". A continuaci\u00f3n, se abrir\u00e1 la siguiente ventana de configuraci\u00f3n: Configuraci\u00f3n de la clase principal del proyecto (main). En primer lugar, en la pesta\u00f1a \"Main se debe seleccionar la clase principal del proyecto, la cual ser\u00e1 la clase que contenga el funci\u00f3n \"main\", tal y como se muestra en la figura anterior. Incorporaci\u00f3n de argumentos en la ejecuci\u00f3n para permitir usar aserciones. Posteriormente, en la pesta\u00f1a \"Arguments\" se deben a\u00f1adir las opciones \"-ea\" en \"VM arguments\", las cuales habilitar\u00e1n el procesamiento de las aserciones en el proyecto. Finalmente, hacer click en el bot\u00f3n \"Run\" y el programa se ejecutar\u00e1 mostrando los errores existentes en las aserciones en el caso de que existan. Uso de Null & Optional \u00b6 En [3] se describe algunas de las consecuencias del uso del valor null y los mecanismos que pueden ser utilizados para evitar su uso. En Java 8 se incorpora la clase \"Optional\", la cual puede ser utilizada tambi\u00e9n para evitar su uso. Optional is a container object used to contain not-null objects. Optional object is used to represent null with absent value. This class has various utility methods to facilitate code to handle values as \u2018available\u2019 or \u2018not available\u2019 instead of checking null values. It is introduced in Java 8 and is similar to what Optional is in Guava. -- TutorialsPoint.com A continuaci\u00f3n, en el siguiente fragmento de c\u00f3digo se muestra un ejemplo de uso indebido del valor null : Album album = getAlbum ( \"Random Memory Access\" ); if ( album != null ) { return album ; } else { // Avisar al usuario de que no se ha encontrado el album } Por otro lado, en el siguiente fragmento de c\u00f3digo se realiza el uso de la clase \"Optional\". En este caso, se evita la comparaci\u00f3n de la variable \"album\" con el valor null , y se utiliza el m\u00e9todo \"isPresent\" en su lugar. Optional < Album > albumOptional = getAlbum ( \"Random Memory Access\" ); if ( albumOptional . isPresent ()) { return albumOptional . get (); } else { // Avisar al usuario de que no se ha encontrado el album } Ejercicios propuestos \u00b6 Ejercicio 1 \u00b6 Dado los siguientes fragmentos de c\u00f3digo responder a las siguientes preguntas: Product.java \u00b6 public class Product { private int code ; private String name ; private String category ; private double weight ; private double height ; public Product ( int code , String name , String category , double weight , double height ) { this . code = code ; if ( name == null ) { this . name = \"\" ; } else { this . name = name ; } if ( category == null ) { this . category = \"\" ; } else { this . category = category ; } this . category = category ; this . weight = weight ; this . height = height ; } public int getCode () { return code ; } public void setName ( String name ) { this . name = name ; } public String getName () { return this . name ; } public void setCategory ( String category ) { this . category = category ; } public String getCategory () { return this . category ; } public void setWeight ( double weight ) { this . weight = weight ; } public double getWeight () { return this . weight ; } public void setHeight ( double height ) { this . height = height ; } public double getHeight () { return this . height ; } } ShoppingCart.java \u00b6 import java.util.HashMap ; import java.util.Map ; public class ShoppingCart { Map < Product , Integer > shoppingCart ; public ShoppingCart () { shoppingCart = new HashMap < Product , Integer > (); } public void addProduct ( Product product , int number ) { if ( shoppingCart . keySet (). stream (). filter ( element -> element . getCode () == product . getCode ()). count () == 0 ) { shoppingCart . put ( product , number ); } } public Product removeProduct ( Product product ) { if ( shoppingCart . containsKey ( product )) { shoppingCart . remove ( product ); return product ; } else { return null ; } } public void printShoppingCartContent () { System . out . println ( \"The shopping cart content is: \" ); for ( Product product : shoppingCart . keySet ()) { System . out . println ( product . getCode () + \" - \" + product . getName () + \" : \" + shoppingCart . get ( product )); } } } Main.java \u00b6 public class Main { public static void main ( String args [] ) { ShoppingCart shoppingCart = new ShoppingCart (); Product product1 = new Product ( 1 , \"Product1\" , \"Category1\" , - 1.0 , 2.0 ); Product product2 = new Product ( 2 , \"Product2\" , \"Category2\" , 5.0 , - 6.0 ); Product product3 = new Product ( 3 , \"Product3\" , null , 5.0 , 6.0 ); Product product4 = new Product ( 4 , null , \"Category4\" , 5.0 , 6.0 ); Product product5 = new Product ( 4 , \"Product5\" , \"Caregory5\" , 5.0 , 6.0 ); Product product6 = new Product ( - 6 , \"Product6\" , \"Caregory6\" , 5.0 , 6.0 ); shoppingCart . addProduct ( product1 , 2 ); shoppingCart . addProduct ( product2 , 1 ); shoppingCart . addProduct ( product3 , 0 ); shoppingCart . addProduct ( product4 , - 2 ); shoppingCart . addProduct ( product5 , 3 ); shoppingCart . addProduct ( product6 , 3 ); if ( shoppingCart . removeProduct ( product1 ) != null ) { System . out . println ( \"The product has been successfully deleted.\" ); } shoppingCart . printShoppingCartContent (); } } Preguntas propuestas \u00b6 Complete en las clases \"Product.java\" y \"ShoppingCart.java\" a\u00f1adiendo aserciones donde sea necesario que permitan que se cumplan las siguientes condiciones: a) En la clase \"Product.java\": El valor del atributo code no puede ser un n\u00famero negativo. El valor del atributo name no puede estar vac\u00edo. El valor del atributo category no puede estar vac\u00edo. El valor del atributo weight no puede ser un n\u00famero negativo. El valor del atributo height no puede ser un n\u00famero negativo. Adem\u00e1s, a\u00f1ada un mensaje de error descriptivo en cada una de las aserciones que haya implementado. b) En la clase \"ShoppingCart.java\": No se puede a\u00f1adir un producto con un n\u00famero de unidades negativo o nulo. No se puede eliminar un producto que no existe en el carrito. Ejercicio 2 \u00b6 Dado el c\u00f3digo del primer ejercicio, \u00bfexiste alg\u00fan uso indebido del valor null ?. En caso afirmativo, reemplace su uso por el de la clase \"Optional\" en los casos en los que sea necesario. Referencias \u00b6 [1] Java documentaci\u00f3n oficial. [2] Cap\u00edtulo de libro Threads, Exceptions, and Assertions (java21days.com) [3] Blog Null, un viejo enemigo del lado oscuro.","title":"Pr\u00e1ctica 4"},{"location":"oop-p4/#repaso-de-conceptos-teoricos","text":"","title":"Repaso de conceptos te\u00f3ricos"},{"location":"oop-p4/#aserciones","text":"Las aserciones son un m\u00e9todo para aumentar la fiabilidad del c\u00f3digo que se esta implementando. Las aserciones son expresiones que representan una condici\u00f3n que debe cumplirse en una parte espec\u00edfica del c\u00f3digo. Si una aserci\u00f3n no se cumple, el programa generar\u00e1 un error en ese punto. An assertion is a statement in the Java programming language that enables you to test your assumptions about your program. For example, if you write a method that calculates the speed of a particle, you might assert that the calculated speed is less than the speed of light. Each assertion contains a boolean expression that you believe will be true when the assertion executes. If it is not true, the system will throw an error. By verifying that the boolean expression is indeed true, the assertion confirms your assumptions about the behavior of your program, increasing your confidence that the program is free of errors. Experience has shown that writing assertions while programming is one of the quickest and most effective ways to detect and correct bugs. As an added benefit, assertions serve to document the inner workings of your program, enhancing maintainability. -- Documentaci\u00f3n oficial de Java. A continuaci\u00f3n, se muestra un ejemplo de una aserci\u00f3n implementada en Java: assert price > 0 ; En este caso, la aserci\u00f3n comprueba que el valor del atributo price debe ser siempre mayor que 0, en el caso de que el valor sea 0 o inferior la aserci\u00f3n no se cumplir\u00e1. Esto permite comprobar que el programa esta realizando un funcionamiento correcto en este sentido. Como se ha comentado anteriormente, si la condici\u00f3n que sigue al keyword assert no se cumple el programa lanzar\u00e1 una excepci\u00f3n de tipo \"AssertionError\". Para que el mensaje de error asociado sea m\u00e1s descriptivo se puede especificar su contenido como se muestra a continuaci\u00f3n: assert price > 0 : \"El precio es menor que 0.\" ; Estas excepciones pueden ser capturadas, o en caso contrario el int\u00e9rprete de Java se encargar\u00e1 de ellas y mostrar\u00e1 la excepci\u00f3n por consola. A continuaci\u00f3n, se muestra un ejemplo del error generado cuando una aserci\u00f3n no se cumple: Exception in thread \u201c main \u201d java . lang . AssertionError at AssertTest . main ( AssertTest . java : 14 ) En el ejemplo anterior se muestra un error generado donde no se ha especificado ning\u00fan mensaje para que sea m\u00e1s descriptivo. A continuaci\u00f3n, se muestra un error donde se ha especificado el mensaje: Exception in thread \u201c main \u201d java . lang . AssertionError : El precio es menor que 0. at AssertTest . main ( AssertTest . java : 14 ) Como se puede comprobar, la incorporaci\u00f3n de mensajes aclaratorios es una buena pr\u00e1ctica, ya que en el primer caso es d\u00edficil conocer el motivo de error del programa, a no ser que se visualice el contenido de la l\u00ednea 14 del fichero \"AssertTest.java\".","title":"Aserciones"},{"location":"oop-p4/#configuracion-de-eclipse-para-usar-aserciones","text":"Aunque las aserciones sean parte oficial del lenguaje Java, se debe configurar la ejecuci\u00f3n del programa para que se muestren los errores asociados a \u00e9stas. En Eclipse se puede realizar esta opci\u00f3n haciendo click derecho sobre el proyecto: \"Run as\" > \"Run configurations\" > Click derecho sobre \"Java application\" > \"New Configuration\". A continuaci\u00f3n, se abrir\u00e1 la siguiente ventana de configuraci\u00f3n: Configuraci\u00f3n de la clase principal del proyecto (main). En primer lugar, en la pesta\u00f1a \"Main se debe seleccionar la clase principal del proyecto, la cual ser\u00e1 la clase que contenga el funci\u00f3n \"main\", tal y como se muestra en la figura anterior. Incorporaci\u00f3n de argumentos en la ejecuci\u00f3n para permitir usar aserciones. Posteriormente, en la pesta\u00f1a \"Arguments\" se deben a\u00f1adir las opciones \"-ea\" en \"VM arguments\", las cuales habilitar\u00e1n el procesamiento de las aserciones en el proyecto. Finalmente, hacer click en el bot\u00f3n \"Run\" y el programa se ejecutar\u00e1 mostrando los errores existentes en las aserciones en el caso de que existan.","title":"Configuraci\u00f3n de Eclipse para usar aserciones"},{"location":"oop-p4/#uso-de-null-optional","text":"En [3] se describe algunas de las consecuencias del uso del valor null y los mecanismos que pueden ser utilizados para evitar su uso. En Java 8 se incorpora la clase \"Optional\", la cual puede ser utilizada tambi\u00e9n para evitar su uso. Optional is a container object used to contain not-null objects. Optional object is used to represent null with absent value. This class has various utility methods to facilitate code to handle values as \u2018available\u2019 or \u2018not available\u2019 instead of checking null values. It is introduced in Java 8 and is similar to what Optional is in Guava. -- TutorialsPoint.com A continuaci\u00f3n, en el siguiente fragmento de c\u00f3digo se muestra un ejemplo de uso indebido del valor null : Album album = getAlbum ( \"Random Memory Access\" ); if ( album != null ) { return album ; } else { // Avisar al usuario de que no se ha encontrado el album } Por otro lado, en el siguiente fragmento de c\u00f3digo se realiza el uso de la clase \"Optional\". En este caso, se evita la comparaci\u00f3n de la variable \"album\" con el valor null , y se utiliza el m\u00e9todo \"isPresent\" en su lugar. Optional < Album > albumOptional = getAlbum ( \"Random Memory Access\" ); if ( albumOptional . isPresent ()) { return albumOptional . get (); } else { // Avisar al usuario de que no se ha encontrado el album }","title":"Uso de Null &amp; Optional"},{"location":"oop-p4/#ejercicios-propuestos","text":"","title":"Ejercicios propuestos"},{"location":"oop-p4/#ejercicio-1","text":"Dado los siguientes fragmentos de c\u00f3digo responder a las siguientes preguntas:","title":"Ejercicio 1"},{"location":"oop-p4/#productjava","text":"public class Product { private int code ; private String name ; private String category ; private double weight ; private double height ; public Product ( int code , String name , String category , double weight , double height ) { this . code = code ; if ( name == null ) { this . name = \"\" ; } else { this . name = name ; } if ( category == null ) { this . category = \"\" ; } else { this . category = category ; } this . category = category ; this . weight = weight ; this . height = height ; } public int getCode () { return code ; } public void setName ( String name ) { this . name = name ; } public String getName () { return this . name ; } public void setCategory ( String category ) { this . category = category ; } public String getCategory () { return this . category ; } public void setWeight ( double weight ) { this . weight = weight ; } public double getWeight () { return this . weight ; } public void setHeight ( double height ) { this . height = height ; } public double getHeight () { return this . height ; } }","title":"Product.java"},{"location":"oop-p4/#shoppingcartjava","text":"import java.util.HashMap ; import java.util.Map ; public class ShoppingCart { Map < Product , Integer > shoppingCart ; public ShoppingCart () { shoppingCart = new HashMap < Product , Integer > (); } public void addProduct ( Product product , int number ) { if ( shoppingCart . keySet (). stream (). filter ( element -> element . getCode () == product . getCode ()). count () == 0 ) { shoppingCart . put ( product , number ); } } public Product removeProduct ( Product product ) { if ( shoppingCart . containsKey ( product )) { shoppingCart . remove ( product ); return product ; } else { return null ; } } public void printShoppingCartContent () { System . out . println ( \"The shopping cart content is: \" ); for ( Product product : shoppingCart . keySet ()) { System . out . println ( product . getCode () + \" - \" + product . getName () + \" : \" + shoppingCart . get ( product )); } } }","title":"ShoppingCart.java"},{"location":"oop-p4/#mainjava","text":"public class Main { public static void main ( String args [] ) { ShoppingCart shoppingCart = new ShoppingCart (); Product product1 = new Product ( 1 , \"Product1\" , \"Category1\" , - 1.0 , 2.0 ); Product product2 = new Product ( 2 , \"Product2\" , \"Category2\" , 5.0 , - 6.0 ); Product product3 = new Product ( 3 , \"Product3\" , null , 5.0 , 6.0 ); Product product4 = new Product ( 4 , null , \"Category4\" , 5.0 , 6.0 ); Product product5 = new Product ( 4 , \"Product5\" , \"Caregory5\" , 5.0 , 6.0 ); Product product6 = new Product ( - 6 , \"Product6\" , \"Caregory6\" , 5.0 , 6.0 ); shoppingCart . addProduct ( product1 , 2 ); shoppingCart . addProduct ( product2 , 1 ); shoppingCart . addProduct ( product3 , 0 ); shoppingCart . addProduct ( product4 , - 2 ); shoppingCart . addProduct ( product5 , 3 ); shoppingCart . addProduct ( product6 , 3 ); if ( shoppingCart . removeProduct ( product1 ) != null ) { System . out . println ( \"The product has been successfully deleted.\" ); } shoppingCart . printShoppingCartContent (); } }","title":"Main.java"},{"location":"oop-p4/#preguntas-propuestas","text":"Complete en las clases \"Product.java\" y \"ShoppingCart.java\" a\u00f1adiendo aserciones donde sea necesario que permitan que se cumplan las siguientes condiciones: a) En la clase \"Product.java\": El valor del atributo code no puede ser un n\u00famero negativo. El valor del atributo name no puede estar vac\u00edo. El valor del atributo category no puede estar vac\u00edo. El valor del atributo weight no puede ser un n\u00famero negativo. El valor del atributo height no puede ser un n\u00famero negativo. Adem\u00e1s, a\u00f1ada un mensaje de error descriptivo en cada una de las aserciones que haya implementado. b) En la clase \"ShoppingCart.java\": No se puede a\u00f1adir un producto con un n\u00famero de unidades negativo o nulo. No se puede eliminar un producto que no existe en el carrito.","title":"Preguntas propuestas"},{"location":"oop-p4/#ejercicio-2","text":"Dado el c\u00f3digo del primer ejercicio, \u00bfexiste alg\u00fan uso indebido del valor null ?. En caso afirmativo, reemplace su uso por el de la clase \"Optional\" en los casos en los que sea necesario.","title":"Ejercicio 2"},{"location":"oop-p4/#referencias","text":"[1] Java documentaci\u00f3n oficial. [2] Cap\u00edtulo de libro Threads, Exceptions, and Assertions (java21days.com) [3] Blog Null, un viejo enemigo del lado oscuro.","title":"Referencias"}]}